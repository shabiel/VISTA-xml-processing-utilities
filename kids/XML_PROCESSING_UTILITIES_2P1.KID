KIDS Distribution saved on Nov 27, 2013@14:33:51
XML Processing Utilities 2.1
**KIDS**:XML PROCESSING UTILITIES 2.1^

**INSTALL NAME**
XML PROCESSING UTILITIES 2.1
"BLD",9275,0)
XML PROCESSING UTILITIES 2.1^XML PROCESSING UTILITIES^0^3131127^y
"BLD",9275,1,0)
^^13^13^3130813^^^
"BLD",9275,1,1,0)
Created by Sam Habiel of the VISTA Expertise Network.
"BLD",9275,1,2,0)
 
"BLD",9275,1,3,0)
This package updates the VISTA XML Parser. It includes all the 
"BLD",9275,1,4,0)
functionality of the old version.
"BLD",9275,1,5,0)
 
"BLD",9275,1,6,0)
NB: Moved into it's own package file entry.
"BLD",9275,1,7,0)
 
"BLD",9275,1,8,0)
See accompanying documentation.
"BLD",9275,1,9,0)
 
"BLD",9275,1,10,0)
Previous release notes:
"BLD",9275,1,11,0)
This package releases a XML parser that was commissioned by the VA
"BLD",9275,1,12,0)
architects. Developer documentation can be found on the VistA
"BLD",9275,1,13,0)
Documentation Library under Infrastructure in the Kernel ToolKit session.
"BLD",9275,4,0)
^9.64PA^950^1
"BLD",9275,4,950,0)
950
"BLD",9275,4,950,222)
y^y^f^^^^n
"BLD",9275,4,"B",950,950)

"BLD",9275,6.3)
9
"BLD",9275,"ABPKG")
n
"BLD",9275,"KRN",0)
^9.67PA^779.2^22
"BLD",9275,"KRN",.4,0)
.4
"BLD",9275,"KRN",.4,"NM",0)
^9.68A^^
"BLD",9275,"KRN",.401,0)
.401
"BLD",9275,"KRN",.402,0)
.402
"BLD",9275,"KRN",.403,0)
.403
"BLD",9275,"KRN",.5,0)
.5
"BLD",9275,"KRN",.84,0)
.84
"BLD",9275,"KRN",.84,"NM",0)
^9.68A^49^49
"BLD",9275,"KRN",.84,"NM",1,0)
9500001^^0
"BLD",9275,"KRN",.84,"NM",2,0)
9500002^^0
"BLD",9275,"KRN",.84,"NM",3,0)
9500003^^0
"BLD",9275,"KRN",.84,"NM",4,0)
9500004^^0
"BLD",9275,"KRN",.84,"NM",5,0)
9500005^^0
"BLD",9275,"KRN",.84,"NM",6,0)
9500006^^0
"BLD",9275,"KRN",.84,"NM",7,0)
9500007^^0
"BLD",9275,"KRN",.84,"NM",8,0)
9500008^^0
"BLD",9275,"KRN",.84,"NM",9,0)
9500009^^0
"BLD",9275,"KRN",.84,"NM",10,0)
9500010^^0
"BLD",9275,"KRN",.84,"NM",11,0)
9500011^^0
"BLD",9275,"KRN",.84,"NM",12,0)
9500012^^0
"BLD",9275,"KRN",.84,"NM",13,0)
9500013^^0
"BLD",9275,"KRN",.84,"NM",14,0)
9500014^^0
"BLD",9275,"KRN",.84,"NM",15,0)
9500015^^0
"BLD",9275,"KRN",.84,"NM",16,0)
9500016^^0
"BLD",9275,"KRN",.84,"NM",17,0)
9500017^^0
"BLD",9275,"KRN",.84,"NM",18,0)
9500018^^0
"BLD",9275,"KRN",.84,"NM",19,0)
9500019^^0
"BLD",9275,"KRN",.84,"NM",20,0)
9500020^^0
"BLD",9275,"KRN",.84,"NM",21,0)
9500021^^0
"BLD",9275,"KRN",.84,"NM",22,0)
9500022^^0
"BLD",9275,"KRN",.84,"NM",23,0)
9500023^^0
"BLD",9275,"KRN",.84,"NM",24,0)
9500024^^0
"BLD",9275,"KRN",.84,"NM",25,0)
9500025^^0
"BLD",9275,"KRN",.84,"NM",26,0)
9500026^^0
"BLD",9275,"KRN",.84,"NM",27,0)
9500027^^0
"BLD",9275,"KRN",.84,"NM",28,0)
9500028^^0
"BLD",9275,"KRN",.84,"NM",29,0)
9500029^^0
"BLD",9275,"KRN",.84,"NM",30,0)
9500030^^0
"BLD",9275,"KRN",.84,"NM",31,0)
9500031^^0
"BLD",9275,"KRN",.84,"NM",32,0)
9500032^^0
"BLD",9275,"KRN",.84,"NM",33,0)
9500033^^0
"BLD",9275,"KRN",.84,"NM",34,0)
9500034^^0
"BLD",9275,"KRN",.84,"NM",35,0)
9500035^^0
"BLD",9275,"KRN",.84,"NM",36,0)
9500036^^0
"BLD",9275,"KRN",.84,"NM",37,0)
9500037^^0
"BLD",9275,"KRN",.84,"NM",38,0)
9500038^^0
"BLD",9275,"KRN",.84,"NM",39,0)
9500039^^0
"BLD",9275,"KRN",.84,"NM",40,0)
9500040^^0
"BLD",9275,"KRN",.84,"NM",41,0)
9500041^^0
"BLD",9275,"KRN",.84,"NM",42,0)
9500042^^0
"BLD",9275,"KRN",.84,"NM",43,0)
9500043^^0
"BLD",9275,"KRN",.84,"NM",44,0)
9500044^^0
"BLD",9275,"KRN",.84,"NM",45,0)
9500045^^0
"BLD",9275,"KRN",.84,"NM",46,0)
9500046^^0
"BLD",9275,"KRN",.84,"NM",47,0)
9500047^^0
"BLD",9275,"KRN",.84,"NM",48,0)
9500048^^0
"BLD",9275,"KRN",.84,"NM",49,0)
9500049^^0
"BLD",9275,"KRN",.84,"NM","B",9500001,1)

"BLD",9275,"KRN",.84,"NM","B",9500002,2)

"BLD",9275,"KRN",.84,"NM","B",9500003,3)

"BLD",9275,"KRN",.84,"NM","B",9500004,4)

"BLD",9275,"KRN",.84,"NM","B",9500005,5)

"BLD",9275,"KRN",.84,"NM","B",9500006,6)

"BLD",9275,"KRN",.84,"NM","B",9500007,7)

"BLD",9275,"KRN",.84,"NM","B",9500008,8)

"BLD",9275,"KRN",.84,"NM","B",9500009,9)

"BLD",9275,"KRN",.84,"NM","B",9500010,10)

"BLD",9275,"KRN",.84,"NM","B",9500011,11)

"BLD",9275,"KRN",.84,"NM","B",9500012,12)

"BLD",9275,"KRN",.84,"NM","B",9500013,13)

"BLD",9275,"KRN",.84,"NM","B",9500014,14)

"BLD",9275,"KRN",.84,"NM","B",9500015,15)

"BLD",9275,"KRN",.84,"NM","B",9500016,16)

"BLD",9275,"KRN",.84,"NM","B",9500017,17)

"BLD",9275,"KRN",.84,"NM","B",9500018,18)

"BLD",9275,"KRN",.84,"NM","B",9500019,19)

"BLD",9275,"KRN",.84,"NM","B",9500020,20)

"BLD",9275,"KRN",.84,"NM","B",9500021,21)

"BLD",9275,"KRN",.84,"NM","B",9500022,22)

"BLD",9275,"KRN",.84,"NM","B",9500023,23)

"BLD",9275,"KRN",.84,"NM","B",9500024,24)

"BLD",9275,"KRN",.84,"NM","B",9500025,25)

"BLD",9275,"KRN",.84,"NM","B",9500026,26)

"BLD",9275,"KRN",.84,"NM","B",9500027,27)

"BLD",9275,"KRN",.84,"NM","B",9500028,28)

"BLD",9275,"KRN",.84,"NM","B",9500029,29)

"BLD",9275,"KRN",.84,"NM","B",9500030,30)

"BLD",9275,"KRN",.84,"NM","B",9500031,31)

"BLD",9275,"KRN",.84,"NM","B",9500032,32)

"BLD",9275,"KRN",.84,"NM","B",9500033,33)

"BLD",9275,"KRN",.84,"NM","B",9500034,34)

"BLD",9275,"KRN",.84,"NM","B",9500035,35)

"BLD",9275,"KRN",.84,"NM","B",9500036,36)

"BLD",9275,"KRN",.84,"NM","B",9500037,37)

"BLD",9275,"KRN",.84,"NM","B",9500038,38)

"BLD",9275,"KRN",.84,"NM","B",9500039,39)

"BLD",9275,"KRN",.84,"NM","B",9500040,40)

"BLD",9275,"KRN",.84,"NM","B",9500041,41)

"BLD",9275,"KRN",.84,"NM","B",9500042,42)

"BLD",9275,"KRN",.84,"NM","B",9500043,43)

"BLD",9275,"KRN",.84,"NM","B",9500044,44)

"BLD",9275,"KRN",.84,"NM","B",9500045,45)

"BLD",9275,"KRN",.84,"NM","B",9500046,46)

"BLD",9275,"KRN",.84,"NM","B",9500047,47)

"BLD",9275,"KRN",.84,"NM","B",9500048,48)

"BLD",9275,"KRN",.84,"NM","B",9500049,49)

"BLD",9275,"KRN",3.6,0)
3.6
"BLD",9275,"KRN",3.8,0)
3.8
"BLD",9275,"KRN",9.2,0)
9.2
"BLD",9275,"KRN",9.8,0)
9.8
"BLD",9275,"KRN",9.8,"NM",0)
^9.68A^13^13
"BLD",9275,"KRN",9.8,"NM",1,0)
MXMLPRS0^^0^B72264453
"BLD",9275,"KRN",9.8,"NM",2,0)
MXMLPRS1^^0^B16288937
"BLD",9275,"KRN",9.8,"NM",3,0)
MXMLPRSE^^0^B69724072
"BLD",9275,"KRN",9.8,"NM",4,0)
MXMLTEST^^0^B8594598
"BLD",9275,"KRN",9.8,"NM",5,0)
MXMLDOM^^0^B8352721
"BLD",9275,"KRN",9.8,"NM",6,0)
MXMLBLD^^0^B69820515
"BLD",9275,"KRN",9.8,"NM",7,0)
MXMLPATH^^0^B97531332
"BLD",9275,"KRN",9.8,"NM",8,0)
MXMLPATT^^0^B212307526
"BLD",9275,"KRN",9.8,"NM",9,0)
MXMLTMP1^^0^B66308015
"BLD",9275,"KRN",9.8,"NM",10,0)
MXMLTMPL^^0^B113793891
"BLD",9275,"KRN",9.8,"NM",11,0)
MXMLTMPT^^0^B205394209
"BLD",9275,"KRN",9.8,"NM",12,0)
MXMLUTL^^0^B1706569
"BLD",9275,"KRN",9.8,"NM",13,0)
MXMLDOMT^^0^B26822164
"BLD",9275,"KRN",9.8,"NM","B","MXMLBLD",6)

"BLD",9275,"KRN",9.8,"NM","B","MXMLDOM",5)

"BLD",9275,"KRN",9.8,"NM","B","MXMLDOMT",13)

"BLD",9275,"KRN",9.8,"NM","B","MXMLPATH",7)

"BLD",9275,"KRN",9.8,"NM","B","MXMLPATT",8)

"BLD",9275,"KRN",9.8,"NM","B","MXMLPRS0",1)

"BLD",9275,"KRN",9.8,"NM","B","MXMLPRS1",2)

"BLD",9275,"KRN",9.8,"NM","B","MXMLPRSE",3)

"BLD",9275,"KRN",9.8,"NM","B","MXMLTEST",4)

"BLD",9275,"KRN",9.8,"NM","B","MXMLTMP1",9)

"BLD",9275,"KRN",9.8,"NM","B","MXMLTMPL",10)

"BLD",9275,"KRN",9.8,"NM","B","MXMLTMPT",11)

"BLD",9275,"KRN",9.8,"NM","B","MXMLUTL",12)

"BLD",9275,"KRN",19,0)
19
"BLD",9275,"KRN",19.1,0)
19.1
"BLD",9275,"KRN",101,0)
101
"BLD",9275,"KRN",409.61,0)
409.61
"BLD",9275,"KRN",771,0)
771
"BLD",9275,"KRN",779.2,0)
779.2
"BLD",9275,"KRN",869.2,0)
869.2
"BLD",9275,"KRN",870,0)
870
"BLD",9275,"KRN",8989.51,0)
8989.51
"BLD",9275,"KRN",8989.52,0)
8989.52
"BLD",9275,"KRN",8994,0)
8994
"BLD",9275,"KRN",8994.2,0)
8994.2
"BLD",9275,"KRN",8994.2,"NM",0)
^9.68A^^
"BLD",9275,"KRN","B",.4,.4)

"BLD",9275,"KRN","B",.401,.401)

"BLD",9275,"KRN","B",.402,.402)

"BLD",9275,"KRN","B",.403,.403)

"BLD",9275,"KRN","B",.5,.5)

"BLD",9275,"KRN","B",.84,.84)

"BLD",9275,"KRN","B",3.6,3.6)

"BLD",9275,"KRN","B",3.8,3.8)

"BLD",9275,"KRN","B",9.2,9.2)

"BLD",9275,"KRN","B",9.8,9.8)

"BLD",9275,"KRN","B",19,19)

"BLD",9275,"KRN","B",19.1,19.1)

"BLD",9275,"KRN","B",101,101)

"BLD",9275,"KRN","B",409.61,409.61)

"BLD",9275,"KRN","B",771,771)

"BLD",9275,"KRN","B",779.2,779.2)

"BLD",9275,"KRN","B",869.2,869.2)

"BLD",9275,"KRN","B",870,870)

"BLD",9275,"KRN","B",8989.51,8989.51)

"BLD",9275,"KRN","B",8989.52,8989.52)

"BLD",9275,"KRN","B",8994,8994)

"BLD",9275,"KRN","B",8994.2,8994.2)

"BLD",9275,"QUES",0)
^9.62^^
"BLD",9275,"REQB",0)
^9.611^^
"FIA",950)
XML ENTITY CATALOG
"FIA",950,0)
^MXML(950,
"FIA",950,0,0)
950
"FIA",950,0,1)
y^y^f^^^^n
"FIA",950,0,10)

"FIA",950,0,11)

"FIA",950,0,"RLRO")

"FIA",950,0,"VR")
2.1^XML PROCESSING UTILITIES
"FIA",950,950)
0
"FIA",950,950.01)
0
"KRN",.84,9500001,-1)
0^1
"KRN",.84,9500001,0)
9500001^1^^
"KRN",.84,9500001,2,0)
^^1^1^2991115
"KRN",.84,9500001,2,1,0)
Expected whitespace
"KRN",.84,9500002,-1)
0^2
"KRN",.84,9500002,0)
9500002^1^^
"KRN",.84,9500002,2,0)
^^1^1^2991115
"KRN",.84,9500002,2,1,0)
Invalid name token
"KRN",.84,9500003,-1)
0^3
"KRN",.84,9500003,0)
9500003^1^^
"KRN",.84,9500003,2,0)
^^1^1^2991115
"KRN",.84,9500003,2,1,0)
Expected token not found
"KRN",.84,9500004,-1)
0^4
"KRN",.84,9500004,0)
9500004^3^^
"KRN",.84,9500004,2,0)
^^1^1^2991115
"KRN",.84,9500004,2,1,0)
Redeclared attribute ignored
"KRN",.84,9500005,-1)
0^5
"KRN",.84,9500005,0)
9500005^1^^
"KRN",.84,9500005,2,0)
^^1^1^2991115
"KRN",.84,9500005,2,1,0)
End element has no corresponding start element
"KRN",.84,9500006,-1)
0^6
"KRN",.84,9500006,0)
9500006^1^^
"KRN",.84,9500006,2,0)
^^1^1^2991115
"KRN",.84,9500006,2,1,0)
Invalid at top level of document
"KRN",.84,9500007,-1)
0^7
"KRN",.84,9500007,0)
9500007^1^^
"KRN",.84,9500007,2,0)
^^1^1^2991115
"KRN",.84,9500007,2,1,0)
Section was not closed
"KRN",.84,9500008,-1)
0^8
"KRN",.84,9500008,0)
9500008^3^^
"KRN",.84,9500008,2,0)
^^1^1^2991115
"KRN",.84,9500008,2,1,0)
Element not closed
"KRN",.84,9500009,-1)
0^9
"KRN",.84,9500009,0)
9500009^1^^
"KRN",.84,9500009,2,0)
^^1^1^2991115
"KRN",.84,9500009,2,1,0)
Reserved word
"KRN",.84,9500010,-1)
0^10
"KRN",.84,9500010,0)
9500010^1^^
"KRN",.84,9500010,2,0)
^^1^1^2991115
"KRN",.84,9500010,2,1,0)
XML version not supported
"KRN",.84,9500011,-1)
0^11
"KRN",.84,9500011,0)
9500011^1^^
"KRN",.84,9500011,2,0)
^^1^1^2991115
"KRN",.84,9500011,2,1,0)
No opening quote
"KRN",.84,9500012,-1)
0^12
"KRN",.84,9500012,0)
9500012^1^^
"KRN",.84,9500012,2,0)
^^1^1^2991115
"KRN",.84,9500012,2,1,0)
No closing quote
"KRN",.84,9500013,-1)
0^13
"KRN",.84,9500013,0)
9500013^1^^
"KRN",.84,9500013,2,0)
^^1^1^2991115
"KRN",.84,9500013,2,1,0)
Character not allowed in literal
"KRN",.84,9500014,-1)
0^14
"KRN",.84,9500014,0)
9500014^1^^
"KRN",.84,9500014,2,0)
^^1^1^2991115
"KRN",.84,9500014,2,1,0)
Unknown entity reference
"KRN",.84,9500015,-1)
0^15
"KRN",.84,9500015,0)
9500015^2^^
"KRN",.84,9500015,2,0)
^^1^1^2991115
"KRN",.84,9500015,2,1,0)
Top level element is not root element
"KRN",.84,9500016,-1)
0^16
"KRN",.84,9500016,0)
9500016^1^^
"KRN",.84,9500016,2,0)
^^1^1^2991115
"KRN",.84,9500016,2,1,0)
Unrecognized DTD tag
"KRN",.84,9500017,-1)
0^17
"KRN",.84,9500017,0)
9500017^1^^
"KRN",.84,9500017,2,0)
^^1^1^2991115
"KRN",.84,9500017,2,1,0)
Unexpected end of document
"KRN",.84,9500018,-1)
0^18
"KRN",.84,9500018,0)
9500018^3^^
"KRN",.84,9500018,2,0)
^^1^1^2991115
"KRN",.84,9500018,2,1,0)
Redeclared entity ignored
"KRN",.84,9500019,-1)
0^19
"KRN",.84,9500019,0)
9500019^1^^
"KRN",.84,9500019,2,0)
^^1^1^2991115
"KRN",.84,9500019,2,1,0)
Invalid character reference
"KRN",.84,9500020,-1)
0^20
"KRN",.84,9500020,0)
9500020^1^^
"KRN",.84,9500020,2,0)
^^1^1^2991115
"KRN",.84,9500020,2,1,0)
Duplicate element declaration
"KRN",.84,9500021,-1)
0^21
"KRN",.84,9500021,0)
9500021^1^^
"KRN",.84,9500021,2,0)
^^1^1^2991115
"KRN",.84,9500021,2,1,0)
Unbalanced parentheses
"KRN",.84,9500022,-1)
0^22
"KRN",.84,9500022,0)
9500022^1^^
"KRN",.84,9500022,2,0)
^^1^1^2991115
"KRN",.84,9500022,2,1,0)
Inconsistent operators
"KRN",.84,9500023,-1)
0^23
"KRN",.84,9500023,0)
9500023^1^^
"KRN",.84,9500023,2,0)
^^1^1^2991115
"KRN",.84,9500023,2,1,0)
Element name referenced more than once
"KRN",.84,9500024,-1)
0^24
"KRN",.84,9500024,0)
9500024^2^^
"KRN",.84,9500024,2,0)
^^1^1^2991115
"KRN",.84,9500024,2,1,0)
Element not allowed by DTD
"KRN",.84,9500025,-1)
0^25
"KRN",.84,9500025,0)
9500025^2^^
"KRN",.84,9500025,2,0)
^^1^1^2991115
"KRN",.84,9500025,2,1,0)
Required element is missing
"KRN",.84,9500026,-1)
0^26
"KRN",.84,9500026,0)
9500026^2^^
"KRN",.84,9500026,2,0)
^^1^1^2991115
"KRN",.84,9500026,2,1,0)
Element declaration is missing
"KRN",.84,9500027,-1)
0^27
"KRN",.84,9500027,0)
9500027^2^^
"KRN",.84,9500027,2,0)
^^1^1^2991115
"KRN",.84,9500027,2,1,0)
PCDATA not allowed by DTD
"KRN",.84,9500028,-1)
0^28
"KRN",.84,9500028,0)
9500028^2^^
"KRN",.84,9500028,2,0)
^^1^1^2991115
"KRN",.84,9500028,2,1,0)
Duplicate ID reference not allowed
"KRN",.84,9500029,-1)
0^29
"KRN",.84,9500029,0)
9500029^2^^
"KRN",.84,9500029,2,0)
^^1^1^2991115
"KRN",.84,9500029,2,1,0)
Attribute not recognized
"KRN",.84,9500030,-1)
0^30
"KRN",.84,9500030,0)
9500030^1^^
"KRN",.84,9500030,2,0)
^^1^1^2991115
"KRN",.84,9500030,2,1,0)
Could not locate external entity
"KRN",.84,9500031,-1)
0^31
"KRN",.84,9500031,0)
9500031^3^^
"KRN",.84,9500031,2,0)
^^1^1^2991115
"KRN",.84,9500031,2,1,0)
Document does not begin with ?xml
"KRN",.84,9500032,-1)
0^32
"KRN",.84,9500032,0)
9500032^3^^
"KRN",.84,9500032,2,0)
^^1^1^2991115
"KRN",.84,9500032,2,1,0)
Document does not contain DOCTYPE declaration
"KRN",.84,9500033,-1)
0^33
"KRN",.84,9500033,0)
9500033^1^^
"KRN",.84,9500033,2,0)
^^1^1^2991115
"KRN",.84,9500033,2,1,0)
Expected attribute type keyword
"KRN",.84,9500034,-1)
0^34
"KRN",.84,9500034,0)
9500034^1^^
"KRN",.84,9500034,2,0)
^^1^1^2991115
"KRN",.84,9500034,2,1,0)
Only IMPLIED or REQUIRED allowed for ID attribute type
"KRN",.84,9500035,-1)
0^35
"KRN",.84,9500035,0)
9500035^2^^
"KRN",.84,9500035,2,0)
^^1^1^2991115
"KRN",.84,9500035,2,1,0)
Only one attribute per element can have ID type
"KRN",.84,9500036,-1)
0^36
"KRN",.84,9500036,0)
9500036^2^^
"KRN",.84,9500036,2,0)
^^1^1^2991115
"KRN",.84,9500036,2,1,0)
Required attribute is missing
"KRN",.84,9500037,-1)
0^37
"KRN",.84,9500037,0)
9500037^2^^
"KRN",.84,9500037,2,0)
^^1^1^2991115
"KRN",.84,9500037,2,1,0)
Attribute value does not match fixed value
"KRN",.84,9500038,-1)
0^38
"KRN",.84,9500038,0)
9500038^2^^
"KRN",.84,9500038,2,0)
^^1^1^2991115
"KRN",.84,9500038,2,1,0)
Invalid attribute value
"KRN",.84,9500039,-1)
0^39
"KRN",.84,9500039,0)
9500039^1^^
"KRN",.84,9500039,2,0)
^^1^1^2991115
"KRN",.84,9500039,2,1,0)
Expected SYSTEM or PUBLIC identifier
"KRN",.84,9500040,-1)
0^40
"KRN",.84,9500040,0)
9500040^1^^
"KRN",.84,9500040,2,0)
^^1^1^2991115
"KRN",.84,9500040,2,1,0)
Illegal reference to unparsed external entity
"KRN",.84,9500041,-1)
0^41
"KRN",.84,9500041,0)
9500041^1^^
"KRN",.84,9500041,2,0)
^^1^1^2991115
"KRN",.84,9500041,2,1,0)
Expected INCLUDE or IGNORE
"KRN",.84,9500042,-1)
0^42
"KRN",.84,9500042,0)
9500042^1^^
"KRN",.84,9500042,2,0)
^^1^1^2991115
"KRN",.84,9500042,2,1,0)
Closing delimiter missing for conditional section
"KRN",.84,9500043,-1)
0^43
"KRN",.84,9500043,0)
9500043^1^^
"KRN",.84,9500043,2,0)
^^1^1^2991115
"KRN",.84,9500043,2,1,0)
Cyclic entity reference
"KRN",.84,9500044,-1)
0^44
"KRN",.84,9500044,0)
9500044^1^^
"KRN",.84,9500044,2,0)
^^1^1^2991115
"KRN",.84,9500044,2,1,0)
Conditional section not allowed in internal subset
"KRN",.84,9500045,-1)
0^45
"KRN",.84,9500045,0)
9500045^1^^
"KRN",.84,9500045,2,0)
^^1^1^2991115
"KRN",.84,9500045,2,1,0)
Root element can occur only once
"KRN",.84,9500046,-1)
0^46
"KRN",.84,9500046,0)
9500046^1^^
"KRN",.84,9500046,2,0)
^^1^1^2991115
"KRN",.84,9500046,2,1,0)
Notation not declared
"KRN",.84,9500047,-1)
0^47
"KRN",.84,9500047,0)
9500047^2^^
"KRN",.84,9500047,2,0)
^^1^1^2991115
"KRN",.84,9500047,2,1,0)
ID reference not found
"KRN",.84,9500048,-1)
0^48
"KRN",.84,9500048,0)
9500048^2^^
"KRN",.84,9500048,2,0)
^^1^1^2991115
"KRN",.84,9500048,2,1,0)
Redeclared notation ignored
"KRN",.84,9500049,-1)
0^49
"KRN",.84,9500049,0)
9500049^2^^
"KRN",.84,9500049,2,0)
^^1^1^2991115^
"KRN",.84,9500049,2,1,0)
Not an unparsed entity reference
"MBREQ")
0
"ORD",9,.84)
.84;9;;;EDEOUT^DIFROMSO(.84,DA,"",XPDA);FPRE^DIFROMSI(.84,"",XPDA);EPRE^DIFROMSI(.84,DA,"",XPDA,"",OLDA);;EPOST^DIFROMSI(.84,DA,"",XPDA);DEL^DIFROMSK(.84,"",%)
"ORD",9,.84,0)
DIALOG
"PKG",221,-1)
1^1
"PKG",221,0)
XML PROCESSING UTILITIES^MXML^Utilities to handle XML processing in VISTA.
"PKG",221,20,0)
^9.402P^^
"PKG",221,22,0)
^9.49I^1^1
"PKG",221,22,1,0)
2.1^3131127
"PKG",221,22,1,1,0)
^^13^13^3131127
"PKG",221,22,1,1,1,0)
Created by Sam Habiel of the VISTA Expertise Network.
"PKG",221,22,1,1,2,0)
 
"PKG",221,22,1,1,3,0)
This package updates the VISTA XML Parser. It includes all the 
"PKG",221,22,1,1,4,0)
functionality of the old version.
"PKG",221,22,1,1,5,0)
 
"PKG",221,22,1,1,6,0)
NB: Moved into it's own package file entry.
"PKG",221,22,1,1,7,0)
 
"PKG",221,22,1,1,8,0)
See accompanying documentation.
"PKG",221,22,1,1,9,0)
 
"PKG",221,22,1,1,10,0)
Previous release notes:
"PKG",221,22,1,1,11,0)
This package releases a XML parser that was commissioned by the VA
"PKG",221,22,1,1,12,0)
architects. Developer documentation can be found on the VistA
"PKG",221,22,1,1,13,0)
Documentation Library under Infrastructure in the Kernel ToolKit session.
"PKG",221,"VERSION")
2.1
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
13
"RTN","MXMLBLD")
0^6^B69820515
"RTN","MXMLBLD",1,0)
MXMLBLD ; RWF/RWF - Recursive XML Writer ;2013-07-30  3:37 PM
"RTN","MXMLBLD",2,0)
 ;;2.1;XML PROCESSING UTILITIES;;Nov 27, 2013;Build 9
"RTN","MXMLBLD",3,0)
 QUIT
"RTN","MXMLBLD",4,0)
 ;
"RTN","MXMLBLD",5,0)
 ; Sam sez: Wally Fort wrote this!
"RTN","MXMLBLD",6,0)
 ; How to use:
"RTN","MXMLBLD",7,0)
 ; - Call START to start the doucment. Pass G so that the output would be
"RTN","MXMLBLD",8,0)
 ;   stored for later use; otherwise, it prints to the screen.
"RTN","MXMLBLD",9,0)
 ; - Call ITEM for a tag with no children
"RTN","MXMLBLD",10,0)
 ; - Call MULTI for a tag with children, passing the routine that will
"RTN","MXMLBLD",11,0)
 ;   create the children for DOITEM
"RTN","MXMLBLD",12,0)
 ; - Call END to close the XML document
"RTN","MXMLBLD",13,0)
 ; - Grab the document from ^TMP("MXMLBLD",$J)
"RTN","MXMLBLD",14,0)
 ; - Kill that global.
"RTN","MXMLBLD",15,0)
 ;
"RTN","MXMLBLD",16,0)
 ;
"RTN","MXMLBLD",17,0)
 ;DOC - The top level tag
"RTN","MXMLBLD",18,0)
 ;DOCTYPE - Want to include a DOCTYPE node
"RTN","MXMLBLD",19,0)
 ;FLAG - Set to 'G' to store the output in the global ^TMP("MXMLBLD",$J,
"RTN","MXMLBLD",20,0)
 ;NO1ST - Not first; don't generate the XML header if this is true
"RTN","MXMLBLD",21,0)
 ;ATT - Attribute list for the first element
"RTN","MXMLBLD",22,0)
START(DOC,DOCTYPE,FLAG,NO1ST,ATT) ;Call this once at the begining.
"RTN","MXMLBLD",23,0)
 K ^TMP("MXMLBLD",$J)
"RTN","MXMLBLD",24,0)
 S ^TMP("MXMLBLD",$J,"DOC")=DOC,^TMP("MXMLBLD",$J,"STK")=0
"RTN","MXMLBLD",25,0)
 I $G(FLAG)["G" S ^TMP("MXMLBLD",$J,"CNT")=1
"RTN","MXMLBLD",26,0)
 I $G(NO1ST)'=1 D OUTPUT($$XMLHDR)
"RTN","MXMLBLD",27,0)
 D:$L($G(DOCTYPE)) OUTPUT("<!DOCTYPE "_DOCTYPE_">") D OUTPUT("<"_DOC_$$ATT(.ATT)_">")
"RTN","MXMLBLD",28,0)
 Q
"RTN","MXMLBLD",29,0)
 ;
"RTN","MXMLBLD",30,0)
END ;Call this once to close out the document
"RTN","MXMLBLD",31,0)
 D OUTPUT("</"_$G(^TMP("MXMLBLD",$J,"DOC"))_">")
"RTN","MXMLBLD",32,0)
 I '$G(^TMP("MXMLBLD",$J,"CNT")) K ^TMP("MXMLBLD",$J)
"RTN","MXMLBLD",33,0)
 K ^TMP("MXMLBLD",$J,"DOC"),^("CNT"),^("STK")
"RTN","MXMLBLD",34,0)
 Q
"RTN","MXMLBLD",35,0)
 ;
"RTN","MXMLBLD",36,0)
ITEM(INDENT,TAG,ATT,VALUE) ;Output a Item
"RTN","MXMLBLD",37,0)
 N I,X
"RTN","MXMLBLD",38,0)
 S ATT=$G(ATT)
"RTN","MXMLBLD",39,0)
 I '$D(VALUE) D OUTPUT($$BLS($G(INDENT))_"<"_TAG_$$ATT(.ATT)_" />") Q
"RTN","MXMLBLD",40,0)
 D OUTPUT($$BLS($G(INDENT))_"<"_TAG_$$ATT(.ATT)_">"_$$CHARCHK(VALUE)_"</"_TAG_">")
"RTN","MXMLBLD",41,0)
 Q
"RTN","MXMLBLD",42,0)
 ;DOITEM is a callback to output the lower level.
"RTN","MXMLBLD",43,0)
MULTI(INDENT,TAG,ATT,DOITEM) ;Output a Multipule
"RTN","MXMLBLD",44,0)
 N I,X,S
"RTN","MXMLBLD",45,0)
 S ATT=$G(ATT)
"RTN","MXMLBLD",46,0)
 D PUSH($G(INDENT),TAG,.ATT)
"RTN","MXMLBLD",47,0)
 D @DOITEM
"RTN","MXMLBLD",48,0)
 D POP
"RTN","MXMLBLD",49,0)
 Q
"RTN","MXMLBLD",50,0)
 ;
"RTN","MXMLBLD",51,0)
ATT(ATT) ;Output a string of attributes
"RTN","MXMLBLD",52,0)
 I $D(ATT)<9 Q ""
"RTN","MXMLBLD",53,0)
 N I,S,V
"RTN","MXMLBLD",54,0)
 S S="",I=""
"RTN","MXMLBLD",55,0)
 F  S I=$O(ATT(I)) Q:I=""  S S=S_" "_I_"="_$$Q(ATT(I))
"RTN","MXMLBLD",56,0)
 Q S
"RTN","MXMLBLD",57,0)
 ;
"RTN","MXMLBLD",58,0)
Q(X) ;Add Quotes
"RTN","MXMLBLD",59,0)
 I X'[$C(34) Q $C(34)_X_$C(34)
"RTN","MXMLBLD",60,0)
 ;I X'[$C(39) Q $C(39)_X_$C(39)
"RTN","MXMLBLD",61,0)
 N Q,Y,I,Z S Q=$C(34),(Y,Z)=""
"RTN","MXMLBLD",62,0)
 ;N Q,Y,I,Z S Q=$C(39),(Y,Z)=""
"RTN","MXMLBLD",63,0)
 F I=1:1:$L(X,Q)-1 S Y=Y_$P(X,Q,I)_Q_Q
"RTN","MXMLBLD",64,0)
 S Y=Y_$P(X,Q,$L(X,Q))
"RTN","MXMLBLD",65,0)
 Q $C(34)_Y_$C(34)
"RTN","MXMLBLD",66,0)
 ;Q $C(39)_Y_$C(39)
"RTN","MXMLBLD",67,0)
 ;
"RTN","MXMLBLD",68,0)
XMLHDR() ; -- provides current XML standard header
"RTN","MXMLBLD",69,0)
 Q "<?xml version=""1.0"" encoding=""utf-8"" ?>"
"RTN","MXMLBLD",70,0)
 ;
"RTN","MXMLBLD",71,0)
OUTPUT(S) ;Output
"RTN","MXMLBLD",72,0)
 N C S C=$G(^TMP("MXMLBLD",$J,"CNT"))
"RTN","MXMLBLD",73,0)
 I C S ^TMP("MXMLBLD",$J,C)=S,^TMP("MXMLBLD",$J,"CNT")=C+1 Q
"RTN","MXMLBLD",74,0)
 W S,!
"RTN","MXMLBLD",75,0)
 Q
"RTN","MXMLBLD",76,0)
 ;
"RTN","MXMLBLD",77,0)
CHARCHK(STR) ; -- replace xml character limits with entities
"RTN","MXMLBLD",78,0)
 N A,I,X,Y,Z,NEWSTR
"RTN","MXMLBLD",79,0)
 S (Y,Z)=""
"RTN","MXMLBLD",80,0)
 ;IF STR["&" SET NEWSTR=STR DO  SET STR=Y_Z
"RTN","MXMLBLD",81,0)
 ;. FOR X=1:1  SET Y=Y_$PIECE(NEWSTR,"&",X)_"&amp;",Z=$PIECE(STR,"&",X+1,999) QUIT:Z'["&"
"RTN","MXMLBLD",82,0)
 I STR["&" F I=1:1:$L(STR,"&")-1 S STR=$P(STR,"&",1,I)_"&amp;"_$P(STR,"&",I+1,999)
"RTN","MXMLBLD",83,0)
 I STR["<" F  S STR=$PIECE(STR,"<",1)_"&lt;"_$PIECE(STR,"<",2,99) Q:STR'["<"
"RTN","MXMLBLD",84,0)
 I STR[">" F  S STR=$PIECE(STR,">",1)_"&gt;"_$PIECE(STR,">",2,99) Q:STR'[">"
"RTN","MXMLBLD",85,0)
 I STR["'" F  S STR=$PIECE(STR,"'",1)_"&apos;"_$PIECE(STR,"'",2,99) Q:STR'["'"
"RTN","MXMLBLD",86,0)
 I STR["""" F  S STR=$PIECE(STR,"""",1)_"&quot;"_$PIECE(STR,"""",2,99) Q:STR'[""""
"RTN","MXMLBLD",87,0)
 ;
"RTN","MXMLBLD",88,0)
 S STR=$TR(STR,$C(0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31))
"RTN","MXMLBLD",89,0)
 QUIT STR
"RTN","MXMLBLD",90,0)
 ;
"RTN","MXMLBLD",91,0)
COMMENT(VAL) ;Add Comments
"RTN","MXMLBLD",92,0)
 N I,L
"RTN","MXMLBLD",93,0)
 ;I $D($G(VAL))=1 D OUTPUT("<!-- "_ATT_" -->") Q
"RTN","MXMLBLD",94,0)
 I $D(VAL)#2 D OUTPUT("<!-- "_VAL_" -->") Q  ;CHANGED BY GPL FOR GTM
"RTN","MXMLBLD",95,0)
 S I="",L="<!--"
"RTN","MXMLBLD",96,0)
 F  S I=$O(VAL(I)) Q:I=""  D OUTPUT(L_VAL(I)) S L=""
"RTN","MXMLBLD",97,0)
 D OUTPUT("-->")
"RTN","MXMLBLD",98,0)
 Q
"RTN","MXMLBLD",99,0)
 ;
"RTN","MXMLBLD",100,0)
PUSH(INDENT,TAG,ATT) ;Write a TAG and save.
"RTN","MXMLBLD",101,0)
 N CNT
"RTN","MXMLBLD",102,0)
 S ATT=$G(ATT)
"RTN","MXMLBLD",103,0)
 D OUTPUT($$BLS($G(INDENT))_"<"_TAG_$$ATT(.ATT)_">")
"RTN","MXMLBLD",104,0)
 S CNT=$G(^TMP("MXMLBLD",$J,"STK"))+1,^TMP("MXMLBLD",$J,"STK")=CNT,^TMP("MXMLBLD",$J,"STK",CNT)=INDENT_"^"_TAG
"RTN","MXMLBLD",105,0)
 Q
"RTN","MXMLBLD",106,0)
 ;
"RTN","MXMLBLD",107,0)
POP ;Write last pushed tag and pop
"RTN","MXMLBLD",108,0)
 N CNT,TAG,INDENT,X
"RTN","MXMLBLD",109,0)
 S CNT=$G(^TMP("MXMLBLD",$J,"STK")),X=^TMP("MXMLBLD",$J,"STK",CNT),^TMP("MXMLBLD",$J,"STK")=CNT-1
"RTN","MXMLBLD",110,0)
 S INDENT=+X,TAG=$P(X,"^",2)
"RTN","MXMLBLD",111,0)
 D OUTPUT($$BLS(INDENT)_"</"_TAG_">")
"RTN","MXMLBLD",112,0)
 Q
"RTN","MXMLBLD",113,0)
 ;
"RTN","MXMLBLD",114,0)
BLS(I) ;Return INDENT string
"RTN","MXMLBLD",115,0)
 N S
"RTN","MXMLBLD",116,0)
 S S="",I=$G(I) S:I>0 $P(S," ",I)=" "
"RTN","MXMLBLD",117,0)
 Q S
"RTN","MXMLBLD",118,0)
 ;
"RTN","MXMLBLD",119,0)
INDENT() ;Renturn indent level
"RTN","MXMLBLD",120,0)
 Q +$G(^TMP("MXMLBLD",$J,"STK"))
"RTN","MXMLBLD",121,0)
 ;
"RTN","MXMLBLD",122,0)
 ;
"RTN","MXMLBLD",123,0)
 ;
"RTN","MXMLBLD",124,0)
 ;
"RTN","MXMLBLD",125,0)
 ;
"RTN","MXMLBLD",126,0)
 ;
"RTN","MXMLBLD",127,0)
 ;
"RTN","MXMLBLD",128,0)
 ;
"RTN","MXMLBLD",129,0)
 ;
"RTN","MXMLBLD",130,0)
 ; Alternate way to write XML, mostly written by VEN/SMH.
"RTN","MXMLBLD",131,0)
 ;
"RTN","MXMLBLD",132,0)
 ;
"RTN","MXMLBLD",133,0)
ATRIBUTE(NAME,VALUE) ; VEN/SMH - Stolen from Pharmacy Code
"RTN","MXMLBLD",134,0)
 ; @DESC Builds a valid encoded attribute from the name/value pair passed in
"RTN","MXMLBLD",135,0)
 ;
"RTN","MXMLBLD",136,0)
 ; @NAME The left side of the "name=value" relationship
"RTN","MXMLBLD",137,0)
 ; @VALUE The right side of the "name=value" relationship
"RTN","MXMLBLD",138,0)
 ;
"RTN","MXMLBLD",139,0)
 ; @RETURNS A valid/encoded name value pair
"RTN","MXMLBLD",140,0)
 NEW PSS,QT
"RTN","MXMLBLD",141,0)
 SET QT=""""
"RTN","MXMLBLD",142,0)
 SET PSS("attribute")=NAME_"="_QT_$$SYMENC^MXMLUTL($GET(VALUE))_QT
"RTN","MXMLBLD",143,0)
 QUIT PSS("attribute")
"RTN","MXMLBLD",144,0)
 ;
"RTN","MXMLBLD",145,0)
MKTAG(NAME,ATTRS,TEXT,CLOSE) ; $$ PEP - Make an XML Tag
"RTN","MXMLBLD",146,0)
 ; Input:
"RTN","MXMLBLD",147,0)
 ; - NAME: XML Tag Name (Value)
"RTN","MXMLBLD",148,0)
 ; - ATTRS: Name Value pair of attributes (By Reference)
"RTN","MXMLBLD",149,0)
 ; - TEXT: Text to include in the node (Value)
"RTN","MXMLBLD",150,0)
 ; - CLOSE: Boolean: Are we closing the tag? (Value)
"RTN","MXMLBLD",151,0)
 ; Output: XML as in <name culture="jp">Toyoda Kiichiro</name>
"RTN","MXMLBLD",152,0)
 ;
"RTN","MXMLBLD",153,0)
 ; Process optional value inputs
"RTN","MXMLBLD",154,0)
 S CLOSE=$GET(CLOSE,1) ; Default - Yes
"RTN","MXMLBLD",155,0)
 S TEXT=$$SYMENC^MXMLUTL($GET(TEXT)) ; Default - ""; and encode
"RTN","MXMLBLD",156,0)
 S NAME=$$SYMENC^MXMLUTL(NAME) ; encode
"RTN","MXMLBLD",157,0)
 ;
"RTN","MXMLBLD",158,0)
 ; Define constants we use
"RTN","MXMLBLD",159,0)
 N LB S LB="<" ; Left Bracket
"RTN","MXMLBLD",160,0)
 N RB S RB=">" ; Right Bracket
"RTN","MXMLBLD",161,0)
 N SL S SL="/" ; Slant/Slash
"RTN","MXMLBLD",162,0)
 N SP S SP=" " ; Space
"RTN","MXMLBLD",163,0)
 ;
"RTN","MXMLBLD",164,0)
 ; If the name is a closing tag (like /name), just send that out as </name>
"RTN","MXMLBLD",165,0)
 I $E(NAME)=SL Q LB_NAME_RB
"RTN","MXMLBLD",166,0)
 ;
"RTN","MXMLBLD",167,0)
 ; Otherwise we have an open or complete tag to take care of.
"RTN","MXMLBLD",168,0)
 ;
"RTN","MXMLBLD",169,0)
 ; Process Attributes
"RTN","MXMLBLD",170,0)
 N ATTRSTR S ATTRSTR="" ; Where attributes will all go...
"RTN","MXMLBLD",171,0)
 N ITER S ITER="" ; Iterator
"RTN","MXMLBLD",172,0)
 F  S ITER=$O(ATTRS(ITER)) Q:ITER=""  S ATTRSTR=ATTRSTR_$$ATRIBUTE(ITER,ATTRS(ITER))_SP ; concat together w/spaces in between
"RTN","MXMLBLD",173,0)
 S ATTRSTR=$E(ATTRSTR,1,$L(ATTRSTR)-1) ; Remove trailing space
"RTN","MXMLBLD",174,0)
 ;
"RTN","MXMLBLD",175,0)
 N STR ; Build string
"RTN","MXMLBLD",176,0)
 ;
"RTN","MXMLBLD",177,0)
 ; Process beginning part ----> <name attributes
"RTN","MXMLBLD",178,0)
 I $L(ATTRSTR) S STR=LB_NAME_SP_ATTRSTR
"RTN","MXMLBLD",179,0)
 E  S STR=LB_NAME
"RTN","MXMLBLD",180,0)
 ;
"RTN","MXMLBLD",181,0)
 I '$L(TEXT) D  QUIT STR
"RTN","MXMLBLD",182,0)
 . I CLOSE S STR=STR_SP_SL_RB ; Add  />
"RTN","MXMLBLD",183,0)
 . E  S STR=STR_RB ; Add >
"RTN","MXMLBLD",184,0)
 ;
"RTN","MXMLBLD",185,0)
 I $L(TEXT),CLOSE S STR=STR_RB_TEXT_LB_SL_NAME_RB Q STR ; Add >text</name>
"RTN","MXMLBLD",186,0)
 E  S $EC=",U-INVALID-CALL,"
"RTN","MXMLBLD",187,0)
 S $EC=",U-INVALID-CALL,"
"RTN","MXMLBLD",188,0)
 QUIT
"RTN","MXMLBLD",189,0)
 ;
"RTN","MXMLBLD",190,0)
PUT(RETURN,STRING) ; PEP Proc/$$ - Put an XML Line into the RETURN Array
"RTN","MXMLBLD",191,0)
 ; Output in RETURN. Adds a line in the next available numeric subscript. ByRef
"RTN","MXMLBLD",192,0)
 ; STRING: Value to put in return array. Pass by Value.
"RTN","MXMLBLD",193,0)
 ; If called as an extrinsic, the last used subscript is returned.
"RTN","MXMLBLD",194,0)
 ;
"RTN","MXMLBLD",195,0)
 N CNT S CNT=$O(RETURN(" "),-1) ; Last numberic sub; or zero if none
"RTN","MXMLBLD",196,0)
 S CNT=CNT+1 ; next line
"RTN","MXMLBLD",197,0)
 S RETURN(CNT)=STRING
"RTN","MXMLBLD",198,0)
 QUIT:$QUIT CNT QUIT
"RTN","MXMLBLD",199,0)
 ;
"RTN","MXMLBLD",200,0)
TEST D:$L($T(EN^XTMUNIT)) EN^XTMUNIT($T(+0),1) QUIT
"RTN","MXMLBLD",201,0)
 ;
"RTN","MXMLBLD",202,0)
TESTPUT ; @TEST - Test PUT
"RTN","MXMLBLD",203,0)
 N RTN
"RTN","MXMLBLD",204,0)
 D PUT(.RTN,$$XMLHDR())
"RTN","MXMLBLD",205,0)
 D PUT(.RTN,$$MKTAG("Book",,"Pride and Prejudice"))
"RTN","MXMLBLD",206,0)
 D CHKEQ^XTMUNIT(RTN(1),"<?xml version=""1.0"" encoding=""utf-8"" ?>")
"RTN","MXMLBLD",207,0)
 D CHKEQ^XTMUNIT(RTN(2),"<Book>Pride and Prejudice</Book>")
"RTN","MXMLBLD",208,0)
 QUIT
"RTN","MXMLBLD",209,0)
 ;
"RTN","MXMLBLD",210,0)
TESTMK ; @TEST - Test MKTAG
"RTN","MXMLBLD",211,0)
 N %1
"RTN","MXMLBLD",212,0)
 S %1("type")="japaense"
"RTN","MXMLBLD",213,0)
 S %1("origin")="japan"
"RTN","MXMLBLD",214,0)
 D CHKEQ^XTMUNIT($$MKTAG("name",.%1,"Toyoda",1),"<name origin=""japan"" type=""japaense"">Toyoda</name>")
"RTN","MXMLBLD",215,0)
 D CHKEQ^XTMUNIT($$MKTAG("name",.%1,"Toyoda"),"<name origin=""japan"" type=""japaense"">Toyoda</name>")
"RTN","MXMLBLD",216,0)
 D CHKEQ^XTMUNIT($$MKTAG("name",,"Toyoda"),"<name>Toyoda</name>")
"RTN","MXMLBLD",217,0)
 D CHKEQ^XTMUNIT($$MKTAG("name",.%1),"<name origin=""japan"" type=""japaense"" />")
"RTN","MXMLBLD",218,0)
 D CHKEQ^XTMUNIT($$MKTAG("name",.%1,,0),"<name origin=""japan"" type=""japaense"">")
"RTN","MXMLBLD",219,0)
 D CHKEQ^XTMUNIT($$MKTAG("/name"),"</name>")
"RTN","MXMLBLD",220,0)
 QUIT
"RTN","MXMLBLD",221,0)
 ;
"RTN","MXMLBLD",222,0)
TESTBLD ; @TEST - Test Wally's XML Builder
"RTN","MXMLBLD",223,0)
 N %1 S %1("version")="2.5"
"RTN","MXMLBLD",224,0)
 D START("Books",,"G",,.%1)
"RTN","MXMLBLD",225,0)
 D CHKEQ^XTMUNIT(^TMP("MXMLBLD",$J,1),"<?xml version=""1.0"" encoding=""utf-8"" ?>")
"RTN","MXMLBLD",226,0)
 D CHKEQ^XTMUNIT(^TMP("MXMLBLD",$J,2),"<Books version=""2.5"">")
"RTN","MXMLBLD",227,0)
 N %1 S %1("type")="date"
"RTN","MXMLBLD",228,0)
 D ITEM(,"LastUpdated",.%1,"3-15-99")
"RTN","MXMLBLD",229,0)
 D CHKEQ^XTMUNIT(^TMP("MXMLBLD",$J,3),"<LastUpdated type=""date"">3-15-99</LastUpdated>")
"RTN","MXMLBLD",230,0)
 D MULTI(,"Book",,"BOOKEAC1")
"RTN","MXMLBLD",231,0)
 D MULTI(,"Book",,"BOOKEAC2")
"RTN","MXMLBLD",232,0)
 D CHKEQ^XTMUNIT(^TMP("MXMLBLD",$J,11),"<Title>Sorrows of Young Werther</Title>")
"RTN","MXMLBLD",233,0)
 D END
"RTN","MXMLBLD",234,0)
 D CHKEQ^XTMUNIT(^TMP("MXMLBLD",$J,14),"</Books>")
"RTN","MXMLBLD",235,0)
 ; ZWRITE ^TMP("MXMLBLD",$J,*)
"RTN","MXMLBLD",236,0)
 QUIT
"RTN","MXMLBLD",237,0)
 ;
"RTN","MXMLBLD",238,0)
TESTBLD1 ; Test Wally's XML Builder
"RTN","MXMLBLD",239,0)
 N %1 S %1("version")="2.5"
"RTN","MXMLBLD",240,0)
 D START^MXMLBLD("Books",,"G",,.%1)
"RTN","MXMLBLD",241,0)
 N %1 S %1("type")="date"
"RTN","MXMLBLD",242,0)
 D ITEM^MXMLBLD(,"LastUpdated",.%1,"3-15-99")
"RTN","MXMLBLD",243,0)
 D MULTI^MXMLBLD(,"Book",,"BOOKEAC1")
"RTN","MXMLBLD",244,0)
 D MULTI^MXMLBLD(,"Book",,"BOOKEAC2")
"RTN","MXMLBLD",245,0)
 D END^MXMLBLD
"RTN","MXMLBLD",246,0)
 ZWRITE ^TMP("MXMLBLD",$J,*)
"RTN","MXMLBLD",247,0)
 QUIT
"RTN","MXMLBLD",248,0)
BOOKEAC1 ; Book 1
"RTN","MXMLBLD",249,0)
 D ITEM^MXMLBLD(,"Author",,"AUSTEN,JANE")
"RTN","MXMLBLD",250,0)
 D ITEM^MXMLBLD(,"Title",,"PRIDE AND PREJUDICE")
"RTN","MXMLBLD",251,0)
 D ITEM^MXMLBLD(,"Description",,"A romantic novel revealing how pride can cloud our better judgement.")
"RTN","MXMLBLD",252,0)
 Q
"RTN","MXMLBLD",253,0)
BOOKEAC2 ; Book 2
"RTN","MXMLBLD",254,0)
 D ITEM^MXMLBLD(,"Author",,"Johann Wolfgang von Goethe")
"RTN","MXMLBLD",255,0)
 D ITEM^MXMLBLD(,"Title",,"Sorrows of Young Werther")
"RTN","MXMLBLD",256,0)
 D ITEM^MXMLBLD(,"Description",,"A tale of unrequited love leading to the demise of the protagonist.")
"RTN","MXMLBLD",257,0)
 Q
"RTN","MXMLDOM")
0^5^B8352721
"RTN","MXMLDOM",1,0)
MXMLDOM ;SAIC/DKM - XML Parser - DOM model ;02/27/2002  13:24
"RTN","MXMLDOM",2,0)
 ;;2.1;XML PROCESSING UTILITIES;;Nov 27, 2013;Build 9
"RTN","MXMLDOM",3,0)
 ;=================================================================
"RTN","MXMLDOM",4,0)
 ; This acts as an intermediate client between the event-based XML
"RTN","MXMLDOM",5,0)
 ; parser and a client requiring an in-memory document model.
"RTN","MXMLDOM",6,0)
EN(DOC,OPTION) ;
"RTN","MXMLDOM",7,0)
 N CBK,SUCCESS,LEVEL,NODE,HANDLE
"RTN","MXMLDOM",8,0)
 K ^TMP("MXMLERR",$J)
"RTN","MXMLDOM",9,0)
 L +^TMP("MXMLDOM",$J):5
"RTN","MXMLDOM",10,0)
 E  Q 0
"RTN","MXMLDOM",11,0)
 S HANDLE=$O(^TMP("MXMLDOM",$J,""),-1)+1,^(HANDLE)=""
"RTN","MXMLDOM",12,0)
 L -^TMP("MXMLDOM",$J)
"RTN","MXMLDOM",13,0)
 S CBK("STARTELEMENT")="STARTELE^MXMLDOM"
"RTN","MXMLDOM",14,0)
 S CBK("ENDELEMENT")="ENDELE^MXMLDOM"
"RTN","MXMLDOM",15,0)
 S CBK("COMMENT")="COMMENT^MXMLDOM"
"RTN","MXMLDOM",16,0)
 S CBK("CHARACTERS")="CHAR^MXMLDOM"
"RTN","MXMLDOM",17,0)
 S CBK("ENDDOCUMENT")="ENDDOC^MXMLDOM"
"RTN","MXMLDOM",18,0)
 S CBK("ERROR")="ERROR^MXMLDOM"
"RTN","MXMLDOM",19,0)
 S (SUCCESS,LEVEL,LEVEL(0),NODE)=0,OPTION=$G(OPTION,"V1")
"RTN","MXMLDOM",20,0)
 D EN^MXMLPRSE(DOC,.CBK,OPTION)
"RTN","MXMLDOM",21,0)
 D:'SUCCESS DELETE(HANDLE)
"RTN","MXMLDOM",22,0)
 Q $S(SUCCESS:HANDLE,1:0)
"RTN","MXMLDOM",23,0)
 ; Start element
"RTN","MXMLDOM",24,0)
 ; Create new child node and push info on stack
"RTN","MXMLDOM",25,0)
STARTELE(ELE,ATTR) ;
"RTN","MXMLDOM",26,0)
 N PARENT
"RTN","MXMLDOM",27,0)
 S PARENT=LEVEL(LEVEL),NODE=NODE+1
"RTN","MXMLDOM",28,0)
 S:PARENT ^TMP("MXMLDOM",$J,HANDLE,PARENT,"C",NODE)=ELE
"RTN","MXMLDOM",29,0)
 S LEVEL=LEVEL+1,LEVEL(LEVEL)=NODE,LEVEL(LEVEL,0)=ELE
"RTN","MXMLDOM",30,0)
 S ^TMP("MXMLDOM",$J,HANDLE,NODE)=ELE,^(NODE,"P")=PARENT
"RTN","MXMLDOM",31,0)
 M ^("A")=ATTR
"RTN","MXMLDOM",32,0)
 Q
"RTN","MXMLDOM",33,0)
 ; End element
"RTN","MXMLDOM",34,0)
 ; Pops element stack
"RTN","MXMLDOM",35,0)
ENDELE(ELE) ;
"RTN","MXMLDOM",36,0)
 K LEVEL(LEVEL)
"RTN","MXMLDOM",37,0)
 S LEVEL=LEVEL-1
"RTN","MXMLDOM",38,0)
 Q
"RTN","MXMLDOM",39,0)
 ; Comment data
"RTN","MXMLDOM",40,0)
COMMENT(TXT) ;
"RTN","MXMLDOM",41,0)
 D TXT("X")
"RTN","MXMLDOM",42,0)
 Q
"RTN","MXMLDOM",43,0)
 ; Character data
"RTN","MXMLDOM",44,0)
CHAR(TXT) ;
"RTN","MXMLDOM",45,0)
 D TXT("T")
"RTN","MXMLDOM",46,0)
 Q
"RTN","MXMLDOM",47,0)
 ; Store comment or character data
"RTN","MXMLDOM",48,0)
TXT(SUB) N X,Y,Z
"RTN","MXMLDOM",49,0)
 S Y=$O(^TMP("MXMLDOM",$J,HANDLE,LEVEL(LEVEL),SUB,""),-1)
"RTN","MXMLDOM",50,0)
 I Y>0,($L($G(^(Y)))+$L(TXT)>200)!($G(BGN)["CDATA") S Y=Y+1 ;*rwf
"RTN","MXMLDOM",51,0)
 S:'Y Y=1
"RTN","MXMLDOM",52,0)
 F Z=$L(TXT,$C(10)):-1:1 Q:TXT=""  D
"RTN","MXMLDOM",53,0)
 .S X=$P(TXT,$C(10)),TXT=$P(TXT,$C(10),2,9999)
"RTN","MXMLDOM",54,0)
 .S ^(Y)=$G(^(Y))_X
"RTN","MXMLDOM",55,0)
 .S:Z>1 Y=Y+1 ;*rwf old .S:Z>1 Y=Y+1,^(Y)=""
"RTN","MXMLDOM",56,0)
 Q
"RTN","MXMLDOM",57,0)
 ; End of document
"RTN","MXMLDOM",58,0)
ENDDOC S SUCCESS=1
"RTN","MXMLDOM",59,0)
 Q
"RTN","MXMLDOM",60,0)
 ;Error reporting
"RTN","MXMLDOM",61,0)
ERROR(ERR) ;
"RTN","MXMLDOM",62,0)
 N CNT
"RTN","MXMLDOM",63,0)
 S CNT=1+$G(^TMP("MXMLERR",$J)),^($J)=CNT
"RTN","MXMLDOM",64,0)
 M ^TMP("MXMLERR",$J,CNT)=ERR
"RTN","MXMLDOM",65,0)
 Q
"RTN","MXMLDOM",66,0)
 ;
"RTN","MXMLDOM",67,0)
 ; Below are the external API calls for the interface
"RTN","MXMLDOM",68,0)
 ;
"RTN","MXMLDOM",69,0)
 ; Delete document instance
"RTN","MXMLDOM",70,0)
DELETE(HANDLE) ;
"RTN","MXMLDOM",71,0)
 K ^TMP("MXMLDOM",$J,HANDLE)
"RTN","MXMLDOM",72,0)
 Q
"RTN","MXMLDOM",73,0)
 ; Name of element at node
"RTN","MXMLDOM",74,0)
NAME(HANDLE,NODE) ;
"RTN","MXMLDOM",75,0)
 Q $G(^TMP("MXMLDOM",$J,HANDLE,NODE))
"RTN","MXMLDOM",76,0)
 ; Node of next child
"RTN","MXMLDOM",77,0)
CHILD(HANDLE,PARENT,CHILD) ;
"RTN","MXMLDOM",78,0)
 Q +$O(^TMP("MXMLDOM",$J,HANDLE,PARENT,"C",+$G(CHILD)))
"RTN","MXMLDOM",79,0)
 ; Node of next sibling
"RTN","MXMLDOM",80,0)
SIBLING(HANDLE,NODE) ;
"RTN","MXMLDOM",81,0)
 Q +$O(^TMP("MXMLDOM",$J,HANDLE,$$PARENT(HANDLE,NODE),"C",NODE))
"RTN","MXMLDOM",82,0)
 ; Parent of node
"RTN","MXMLDOM",83,0)
PARENT(HANDLE,NODE) ;
"RTN","MXMLDOM",84,0)
 Q +$G(^TMP("MXMLDOM",$J,HANDLE,NODE,"P"))
"RTN","MXMLDOM",85,0)
 ; Text associated with node
"RTN","MXMLDOM",86,0)
TEXT(HANDLE,NODE,RTN) ;
"RTN","MXMLDOM",87,0)
 D GETTXT("T")
"RTN","MXMLDOM",88,0)
 Q:$Q $D(@RTN)>1
"RTN","MXMLDOM",89,0)
 Q
"RTN","MXMLDOM",90,0)
 ; Comment associate with node
"RTN","MXMLDOM",91,0)
CMNT(HANDLE,NODE,RTN) ;
"RTN","MXMLDOM",92,0)
 D GETTXT("X")
"RTN","MXMLDOM",93,0)
 Q:$Q $D(@RTN)>1
"RTN","MXMLDOM",94,0)
 Q
"RTN","MXMLDOM",95,0)
 ; Retrieve text or comment
"RTN","MXMLDOM",96,0)
GETTXT(SUB) ;
"RTN","MXMLDOM",97,0)
 K @RTN
"RTN","MXMLDOM",98,0)
 M @RTN=^TMP("MXMLDOM",$J,HANDLE,NODE,SUB)
"RTN","MXMLDOM",99,0)
 Q
"RTN","MXMLDOM",100,0)
 ; Retrieve next attribute
"RTN","MXMLDOM",101,0)
ATTRIB(HANDLE,NODE,ATTR) ;
"RTN","MXMLDOM",102,0)
 Q $O(^TMP("MXMLDOM",$J,HANDLE,NODE,"A",$G(ATTR)))
"RTN","MXMLDOM",103,0)
 ; Retrieve attribute value
"RTN","MXMLDOM",104,0)
VALUE(HANDLE,NODE,ATTR) ;
"RTN","MXMLDOM",105,0)
 Q $G(^TMP("MXMLDOM",$J,HANDLE,NODE,"A",ATTR))
"RTN","MXMLDOMT")
0^13^B26822164
"RTN","MXMLDOMT",1,0)
MXMLDOMT ; VEN/SMH - Unit Tests for DOM Parser;2013-11-27  2:15 PM
"RTN","MXMLDOMT",2,0)
 ;;2.1;XML PROCESSING UTILITIES;;Nov 27, 2013;Build 9
"RTN","MXMLDOMT",3,0)
 ;;
"RTN","MXMLDOMT",4,0)
 ;
"RTN","MXMLDOMT",5,0)
 S IO=$P
"RTN","MXMLDOMT",6,0)
 N DIQUIET S DIQUIET=1
"RTN","MXMLDOMT",7,0)
 D EN^XTMUNIT($T(+0),1)
"RTN","MXMLDOMT",8,0)
 QUIT
"RTN","MXMLDOMT",9,0)
 ;
"RTN","MXMLDOMT",10,0)
XML1 ; @TEST - Parse a regular XML Document--sanity test
"RTN","MXMLDOMT",11,0)
 D READ("XML1D")
"RTN","MXMLDOMT",12,0)
 N D S D=$$EN^MXMLDOM($NA(^TMP($J)),"WD")
"RTN","MXMLDOMT",13,0)
 D CHKTF^XTMUNIT(D,"XML not parsed")
"RTN","MXMLDOMT",14,0)
 D DELETE^MXMLDOM(D)
"RTN","MXMLDOMT",15,0)
 QUIT
"RTN","MXMLDOMT",16,0)
XML2 ; @TEST - Parse an XML doc on one line
"RTN","MXMLDOMT",17,0)
 D READ("XML2D")
"RTN","MXMLDOMT",18,0)
 N D S D=$$EN^MXMLDOM($NA(^TMP($J)),"WD")
"RTN","MXMLDOMT",19,0)
 D CHKTF^XTMUNIT(D,"XML not parsed")
"RTN","MXMLDOMT",20,0)
 D DELETE^MXMLDOM(D)
"RTN","MXMLDOMT",21,0)
 QUIT
"RTN","MXMLDOMT",22,0)
XML3 ; @TEST - Parse an XML doc broken on several lines
"RTN","MXMLDOMT",23,0)
 D READ("XML3D")
"RTN","MXMLDOMT",24,0)
 N D S D=$$EN^MXMLDOM($NA(^TMP($J)),"WD")
"RTN","MXMLDOMT",25,0)
 D CHKTF^XTMUNIT(D,"XML not parsed")
"RTN","MXMLDOMT",26,0)
 D DELETE^MXMLDOM(D)
"RTN","MXMLDOMT",27,0)
 QUIT
"RTN","MXMLDOMT",28,0)
XML4 ; @TEST - Parse an XML doc with Character ref attr
"RTN","MXMLDOMT",29,0)
 D READ("XML4D")
"RTN","MXMLDOMT",30,0)
 N D S D=$$EN^MXMLDOM($NA(^TMP($J)),"WD")
"RTN","MXMLDOMT",31,0)
 D CHKTF^XTMUNIT(D,"XML not parsed")
"RTN","MXMLDOMT",32,0)
 D DELETE^MXMLDOM(D)
"RTN","MXMLDOMT",33,0)
 QUIT
"RTN","MXMLDOMT",34,0)
XML5 ; @TEST - Parse an XML doc with Chracter ref attr broken over 2 lines (Sergey's bug)
"RTN","MXMLDOMT",35,0)
 D READ("XML5D")
"RTN","MXMLDOMT",36,0)
 N D S D=$$EN^MXMLDOM($NA(^TMP($J)),"WD")
"RTN","MXMLDOMT",37,0)
 D CHKTF^XTMUNIT(D,"XML not parsed")
"RTN","MXMLDOMT",38,0)
 D DELETE^MXMLDOM(D)
"RTN","MXMLDOMT",39,0)
 QUIT
"RTN","MXMLDOMT",40,0)
XML6 ; @TEST - Parse an XML doc with Chracter ref text broken over 2 lines (George's bug)
"RTN","MXMLDOMT",41,0)
 D READ("XML6D")
"RTN","MXMLDOMT",42,0)
 N D S D=$$EN^MXMLDOM($NA(^TMP($J)),"WD")
"RTN","MXMLDOMT",43,0)
 D CHKTF^XTMUNIT(D,"XML not parsed")
"RTN","MXMLDOMT",44,0)
 D DELETE^MXMLDOM(D)
"RTN","MXMLDOMT",45,0)
 QUIT
"RTN","MXMLDOMT",46,0)
XMLFILE ; @TEST - Parse an XML document loacated on the File system (Sam's bug)
"RTN","MXMLDOMT",47,0)
 D READ("XML1D")
"RTN","MXMLDOMT",48,0)
 ;
"RTN","MXMLDOMT",49,0)
 ; Write file
"RTN","MXMLDOMT",50,0)
 N % S %=$$GTF^%ZISH($NA(^TMP($J,1)),2,$$DEFDIR^%ZISH(),"mxmldomt.xml")
"RTN","MXMLDOMT",51,0)
 I '% S $EC=",U-FILE-WRITE-FAIL,"
"RTN","MXMLDOMT",52,0)
 ;
"RTN","MXMLDOMT",53,0)
 ; Check 1: No path supplied. System supposed to use default directory
"RTN","MXMLDOMT",54,0)
 N D S D=$$EN^MXMLDOM("mxmldomt.xml","WD")
"RTN","MXMLDOMT",55,0)
 D CHKTF^XTMUNIT(D,"XML not parsed")
"RTN","MXMLDOMT",56,0)
 D DELETE^MXMLDOM(D)
"RTN","MXMLDOMT",57,0)
 ;
"RTN","MXMLDOMT",58,0)
 ; Check 2; Supply path explicitly
"RTN","MXMLDOMT",59,0)
 N D S D=$$EN^MXMLDOM($$DEFDIR^%ZISH()_"mxmldomt.xml","WD")
"RTN","MXMLDOMT",60,0)
 D CHKTF^XTMUNIT(D,"XML not parsed")
"RTN","MXMLDOMT",61,0)
 D DELETE^MXMLDOM(D)
"RTN","MXMLDOMT",62,0)
 ;
"RTN","MXMLDOMT",63,0)
 ; Delete file
"RTN","MXMLDOMT",64,0)
 N %1 S %1("mxmldomt.xml")=""
"RTN","MXMLDOMT",65,0)
 S %=$$DEL^%ZISH($$DEFDIR^%ZISH(),$NA(%1))
"RTN","MXMLDOMT",66,0)
 QUIT
"RTN","MXMLDOMT",67,0)
READ(TAGNAME) ; Read XML from tag
"RTN","MXMLDOMT",68,0)
 K ^TMP($J)
"RTN","MXMLDOMT",69,0)
 N LN
"RTN","MXMLDOMT",70,0)
 N I F I=1:1 S LN=$P($T(@TAGNAME+I),";;",2) Q:'$L(LN)  S ^TMP($J,I)=LN
"RTN","MXMLDOMT",71,0)
 QUIT
"RTN","MXMLDOMT",72,0)
 ;
"RTN","MXMLDOMT",73,0)
XML1D ;; @DATA for Test 1
"RTN","MXMLDOMT",74,0)
 ;;<?xml version="1.0" encoding="utf-8"?>
"RTN","MXMLDOMT",75,0)
 ;;<!-- Edited by XMLSpy -->
"RTN","MXMLDOMT",76,0)
 ;;<note>
"RTN","MXMLDOMT",77,0)
 ;;<to>Tove</to>
"RTN","MXMLDOMT",78,0)
 ;;<from>Jani</from>
"RTN","MXMLDOMT",79,0)
 ;;<heading>Reminder</heading>
"RTN","MXMLDOMT",80,0)
 ;;<body>Don't forget me this weekend!</body>
"RTN","MXMLDOMT",81,0)
 ;;</note>
"RTN","MXMLDOMT",82,0)
 ;;
"RTN","MXMLDOMT",83,0)
XML2D ;; @DATA for Test 2
"RTN","MXMLDOMT",84,0)
 ;;<?xml version="1.0" encoding="utf-8"?><!-- Edited by XMLSpy --><note><to>Tove</to><from>Jani</from><heading>Reminder</heading><body>Don't forget me this weekend!</body></note>
"RTN","MXMLDOMT",85,0)
 ;;
"RTN","MXMLDOMT",86,0)
XML3D ;; @DATA for Test 3
"RTN","MXMLDOMT",87,0)
 ;;<?xml version="1.0" 
"RTN","MXMLDOMT",88,0)
 ;;encoding="utf-8"?>
"RTN","MXMLDOMT",89,0)
 ;;<!-- Edited b
"RTN","MXMLDOMT",90,0)
 ;;y XMLSpy -->
"RTN","MXMLDOMT",91,0)
 ;;<not
"RTN","MXMLDOMT",92,0)
 ;;e>
"RTN","MXMLDOMT",93,0)
 ;;<to>Tove<
"RTN","MXMLDOMT",94,0)
 ;;/to>
"RTN","MXMLDOMT",95,0)
 ;;<from>Jani</from>
"RTN","MXMLDOMT",96,0)
 ;;<heading>Reminder</heading>
"RTN","MXMLDOMT",97,0)
 ;;<body>Don't forget me this weekend!</
"RTN","MXMLDOMT",98,0)
 ;;body>
"RTN","MXMLDOMT",99,0)
 ;;</note>
"RTN","MXMLDOMT",100,0)
 ;;
"RTN","MXMLDOMT",101,0)
XML4D ;; @DATA for Test 4
"RTN","MXMLDOMT",102,0)
 ;;<?xml version="1.0" encoding="utf-8"?>
"RTN","MXMLDOMT",103,0)
 ;;<!-- Edited by XMLSpy -->
"RTN","MXMLDOMT",104,0)
 ;;<note>
"RTN","MXMLDOMT",105,0)
 ;;<to lastname="M&#xfc;ller">Tove</to>
"RTN","MXMLDOMT",106,0)
 ;;<from>Jani</from>
"RTN","MXMLDOMT",107,0)
 ;;<heading>Reminder</heading>
"RTN","MXMLDOMT",108,0)
 ;;<body>Don't forget me this weekend!</body>
"RTN","MXMLDOMT",109,0)
 ;;</note>
"RTN","MXMLDOMT",110,0)
 ;;
"RTN","MXMLDOMT",111,0)
XML5D ;; @DATA for Test 5 (Sergey's bug!)
"RTN","MXMLDOMT",112,0)
 ;;<?xml version="1.0" encoding="utf-8"?>
"RTN","MXMLDOMT",113,0)
 ;;<!-- Edited by XMLSpy -->
"RTN","MXMLDOMT",114,0)
 ;;<note>
"RTN","MXMLDOMT",115,0)
 ;;<!-- Overflow the main buffer -->
"RTN","MXMLDOMT",116,0)
 ;;<subject>AAAAAAAAAAAAAAAAAAAAAAAAAAAA</subject><to lastnameAAAAAAAAAAAAAAAAA="M&#
"RTN","MXMLDOMT",117,0)
 ;;xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#x
"RTN","MXMLDOMT",118,0)
 ;;fc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#
"RTN","MXMLDOMT",119,0)
 ;;xfc;ller">Tove</to>
"RTN","MXMLDOMT",120,0)
 ;;<from>Jani</from>
"RTN","MXMLDOMT",121,0)
 ;;<heading>Reminder</heading>
"RTN","MXMLDOMT",122,0)
 ;;<body>Don't forget me this weekend!</body>
"RTN","MXMLDOMT",123,0)
 ;;</note>
"RTN","MXMLDOMT",124,0)
 ;;
"RTN","MXMLDOMT",125,0)
XML6D ;; @DATA for Test 6 (George's bug!)
"RTN","MXMLDOMT",126,0)
 ;;<?xml version="1.0" encoding="utf-8"?>
"RTN","MXMLDOMT",127,0)
 ;;<!-- Edited by XMLSpy -->
"RTN","MXMLDOMT",128,0)
 ;;<note>
"RTN","MXMLDOMT",129,0)
 ;;<!-- Overflow the main buffer -->
"RTN","MXMLDOMT",130,0)
 ;;<subject>AAAAAAAAAAAAAAAAAAAAAAAAAAAA</subject>
"RTN","MXMLDOMT",131,0)
 ;;<to>Tove&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#
"RTN","MXMLDOMT",132,0)
 ;;xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&
"RTN","MXMLDOMT",133,0)
 ;;#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xf
"RTN","MXMLDOMT",134,0)
 ;;c;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;&#xfc;</to>
"RTN","MXMLDOMT",135,0)
 ;;<from>Jani</from>
"RTN","MXMLDOMT",136,0)
 ;;<heading>Reminder</heading>
"RTN","MXMLDOMT",137,0)
 ;;<body>Don't forget me this weekend!</body>
"RTN","MXMLDOMT",138,0)
 ;;</note>
"RTN","MXMLDOMT",139,0)
 ;;
"RTN","MXMLPATH")
0^7^B97531332
"RTN","MXMLPATH",1,0)
MXMLPATH ; VEN/SMH - XPATH Extensions to MXML Package ;2013-07-26  8:22 PM
"RTN","MXMLPATH",2,0)
 ;;2.1;XML PROCESSING UTILITIES;;Nov 27, 2013;Build 9
"RTN","MXMLPATH",3,0)
 ;
"RTN","MXMLPATH",4,0)
 ; Public Entry Point: [$$]XPATH. The rest is private.
"RTN","MXMLPATH",5,0)
 ;
"RTN","MXMLPATH",6,0)
 ; TODO:
"RTN","MXMLPATH",7,0)
 ; - Handle /a/*
"RTN","MXMLPATH",8,0)
 ; - Handle /a/[]
"RTN","MXMLPATH",9,0)
 ; - Handle /a//b
"RTN","MXMLPATH",10,0)
 ; - Handle . and ..
"RTN","MXMLPATH",11,0)
 ;
"RTN","MXMLPATH",12,0)
XPATH(RETURN,DOCHAND,XPATH) ; Public Entry Point - XPATH Processor
"RTN","MXMLPATH",13,0)
 ; Input:
"RTN","MXMLPATH",14,0)
 ; - .RETURN - Return array. Returns nodes where the XPATH found data. (Reference)
"RTN","MXMLPATH",15,0)
 ; ---> E.g. RETURN(8)=""
"RTN","MXMLPATH",16,0)
 ; --->      RETURN(15)=""
"RTN","MXMLPATH",17,0)
 ; - DOCHAND - The MXMLDOM Document Handle (Value)
"RTN","MXMLPATH",18,0)
 ; - XPATH - XPATH Expression (Value)
"RTN","MXMLPATH",19,0)
 ;
"RTN","MXMLPATH",20,0)
 ; If $$, return first found node; or first attribute value if attribute requested.
"RTN","MXMLPATH",21,0)
 ;
"RTN","MXMLPATH",22,0)
 KILL RETURN
"RTN","MXMLPATH",23,0)
 ;
"RTN","MXMLPATH",24,0)
 ; Handle / all by itself. Return 1.
"RTN","MXMLPATH",25,0)
 IF XPATH="/" DO  QUIT:$QUIT $$QUITVAL(.RETURN) QUIT
"RTN","MXMLPATH",26,0)
 . SET RETURN(1)=""
"RTN","MXMLPATH",27,0)
 . SET ^TMP("MXMLDOM",$JOB,DOCHAND,"CURRENT-NODE")=1
"RTN","MXMLPATH",28,0)
 ;
"RTN","MXMLPATH",29,0)
 ; Handle //a/b/c/d ; find a/b/c/d anywhere in the document.
"RTN","MXMLPATH",30,0)
 IF $EXTRACT(XPATH,1,2)="//" DO  QUIT:$QUIT $$QUITVAL(.RETURN) QUIT  ; find element anywhere in the document
"RTN","MXMLPATH",31,0)
 . SET XPATH=$EXTRACT(XPATH,3,999) ; Strip off the //
"RTN","MXMLPATH",32,0)
 . IF XPATH="" SET $ECODE=",U-INVALID-XPATH," ; // by itself is invalid
"RTN","MXMLPATH",33,0)
 . DO SS(.RETURN,DOCHAND,XPATH) ; find all nodes with the rest of the path (no parents; i.e. look anywhere)
"RTN","MXMLPATH",34,0)
 . SET ^TMP("MXMLDOM",$JOB,DOCHAND,"CURRENT-NODE")=$ORDER(RETURN(""),-1)
"RTN","MXMLPATH",35,0)
 ;
"RTN","MXMLPATH",36,0)
 ;
"RTN","MXMLPATH",37,0)
 ; Handle /a/b/c/d ; find /a/b/c/d starting from the root.
"RTN","MXMLPATH",38,0)
 IF $EXTRACT(XPATH)="/" DO  QUIT:$QUIT $$QUITVAL(.RETURN) QUIT
"RTN","MXMLPATH",39,0)
 . ;
"RTN","MXMLPATH",40,0)
 . ; Make sure that the document root is "a"
"RTN","MXMLPATH",41,0)
 . SET XPATH=$EXTRACT(XPATH,2,999)
"RTN","MXMLPATH",42,0)
 . NEW H SET H=$PIECE(XPATH,"/")
"RTN","MXMLPATH",43,0)
 . IF ^TMP("MXMLDOM",$JOB,DOCHAND,1)'=H QUIT
"RTN","MXMLPATH",44,0)
 . SET XPATH=$PIECE(XPATH,"/",2,99) ; we change this now to a relative path from the root node.
"RTN","MXMLPATH",45,0)
 . ;
"RTN","MXMLPATH",46,0)
 . ; Pass in the root node as the parent
"RTN","MXMLPATH",47,0)
 . NEW PARENTS SET PARENTS(1)=""
"RTN","MXMLPATH",48,0)
 . DO SS(.RETURN,DOCHAND,XPATH,.PARENTS)
"RTN","MXMLPATH",49,0)
 . SET ^TMP("MXMLDOM",$JOB,DOCHAND,"CURRENT-NODE")=$ORDER(RETURN(""),-1)
"RTN","MXMLPATH",50,0)
 ;
"RTN","MXMLPATH",51,0)
 ; We have a relative path
"RTN","MXMLPATH",52,0)
 DO  QUIT:$QUIT $$QUITVAL(.RETURN) QUIT
"RTN","MXMLPATH",53,0)
 . NEW CURRNODE SET CURRNODE=$GET(^TMP("MXMLDOM",$JOB,DOCHAND,"CURRENT-NODE"),1)
"RTN","MXMLPATH",54,0)
 . NEW PARENTS SET PARENTS(CURRNODE)=""
"RTN","MXMLPATH",55,0)
 . DO SS(.RETURN,DOCHAND,XPATH,.PARENTS)
"RTN","MXMLPATH",56,0)
 . SET ^TMP("MXMLDOM",$JOB,DOCHAND,"CURRENT-NODE")=$ORDER(RETURN(""),-1)
"RTN","MXMLPATH",57,0)
 ;
"RTN","MXMLPATH",58,0)
 ; IF NEITHER OF THESE FORMATS, FAIL WITH NOT-IMPLEMENTED EXCEPTION.
"RTN","MXMLPATH",59,0)
 SET $ECODE=",UUNIMPLEMENTED,"
"RTN","MXMLPATH",60,0)
 ;
"RTN","MXMLPATH",61,0)
 QUIT:$QUIT "" QUIT  ; We won't hit this; but for future use
"RTN","MXMLPATH",62,0)
 ;
"RTN","MXMLPATH",63,0)
QUITVAL(RETURN) ; $$/Private - What is the quit value? ; Input .RETURN.
"RTN","MXMLPATH",64,0)
 NEW N1 SET N1=$ORDER(RETURN("")) ;first node
"RTN","MXMLPATH",65,0)
 IF N1="" QUIT "" ; No results found.
"RTN","MXMLPATH",66,0)
 IF $DATA(RETURN(N1))=10 NEW N2 SET N2=$ORDER(RETURN(N1,"")) QUIT RETURN(N1,N2) ; VALUE of first found attribute
"RTN","MXMLPATH",67,0)
 ELSE  QUIT N1 ; first found node
"RTN","MXMLPATH",68,0)
 ;
"RTN","MXMLPATH",69,0)
SS(RETURN,DOCHAND,XPATH,PARENTS) ; Private; Main search code
"RTN","MXMLPATH",70,0)
 ; .RETURN -> Return array to be populated
"RTN","MXMLPATH",71,0)
 ; DOCHAND -> MXMLDOM Handle
"RTN","MXMLPATH",72,0)
 ; XPATH -> XPATH to search
"RTN","MXMLPATH",73,0)
 ; .PARENTS -> XML Parent nodes already identified
"RTN","MXMLPATH",74,0)
 ;             Don't pass if you want to search anywhere in the document.
"RTN","MXMLPATH",75,0)
 ;             Pass PARENTS(NODEID)="" if you want to limit searching to below
"RTN","MXMLPATH",76,0)
 ;             ...these node(s).
"RTN","MXMLPATH",77,0)
 ;
"RTN","MXMLPATH",78,0)
 NEW SURPARENTS MERGE SURPARENTS=PARENTS ; Surviving parents
"RTN","MXMLPATH",79,0)
 ;
"RTN","MXMLPATH",80,0)
 ; Now, recurse over the rest of the XPATH expression
"RTN","MXMLPATH",81,0)
 NEW XPATHL SET XPATHL=$LENGTH(XPATH,"/") ; # of pieces
"RTN","MXMLPATH",82,0)
 NEW QUITFLAG SET QUITFLAG=0
"RTN","MXMLPATH",83,0)
 NEW I FOR I=1:1:XPATHL DO  QUIT:'$DATA(SURPARENTS)  QUIT:QUITFLAG
"RTN","MXMLPATH",84,0)
 . NEW CHILD SET CHILD=$PIECE(XPATH,"/",I)  ; XPATH piece
"RTN","MXMLPATH",85,0)
 . ;
"RTN","MXMLPATH",86,0)
 . ; make sure that each piece is at least 1 character long
"RTN","MXMLPATH",87,0)
 . IF CHILD="",I=XPATHL SET $ECODE=",U-INVALID-XPATH," ; error if  the user give us something with a trailing slash. (a/b/c/)
"RTN","MXMLPATH",88,0)
 . ELSE  ; this is the abc//def case. TODO.
"RTN","MXMLPATH",89,0)
 . ;
"RTN","MXMLPATH",90,0)
 . IF $EXTRACT(CHILD)="@" DO  SET QUITFLAG=1 QUIT  ; Attribute requested...
"RTN","MXMLPATH",91,0)
 . . ; SURPARENTS will only be empty if we have the special case of //@attribute
"RTN","MXMLPATH",92,0)
 . . IF '$DATA(SURPARENTS) DO ALLNODES(.SURPARENTS,DOCHAND) ; This is really confusing!!!!
"RTN","MXMLPATH",93,0)
 . . DO ATTRIB(DOCHAND,CHILD,.SURPARENTS)
"RTN","MXMLPATH",94,0)
 . ;
"RTN","MXMLPATH",95,0)
 . NEW FILTER SET FILTER=""
"RTN","MXMLPATH",96,0)
 . IF $EXTRACT(CHILD,$LENGTH(CHILD))="]" DO  ; The child has a condition on it.
"RTN","MXMLPATH",97,0)
 . . SET FILTER=$PIECE(CHILD,"[",2),FILTER=$PIECE(FILTER,"]") ; get contents of [...]
"RTN","MXMLPATH",98,0)
 . . SET CHILD=$PIECE(CHILD,"[") ; strip [...]
"RTN","MXMLPATH",99,0)
 . ;
"RTN","MXMLPATH",100,0)
 . ; Handle . and ..
"RTN","MXMLPATH",101,0)
 . ; IF $E(CHILD)="." D
"RTN","MXMLPATH",102,0)
 . ; . I CHILD="." S:$O(SURPARENTS("")) CNODES($O(SURPARENTS(""),-1))="" ; Set to the last found parent
"RTN","MXMLPATH",103,0)
 . ; . I CHILD=".." S CNODES(PARENT^MXMLDOM(DOCHAND,SURPARENTS)) ; TODO: Loop through parents and move up.
"RTN","MXMLPATH",104,0)
 . ;
"RTN","MXMLPATH",105,0)
 . NEW CNODES DO SEARCHNO(.CNODES,DOCHAND,CHILD)  ; Grab child nodes from XML doc.
"RTN","MXMLPATH",106,0)
 . IF '$DATA(CNODES) KILL SURPARENTS QUIT  ; XPATH expr yielded no results.
"RTN","MXMLPATH",107,0)
 . ;
"RTN","MXMLPATH",108,0)
 . ; Now make sure that the children nodes are indeed children of the parents.
"RTN","MXMLPATH",109,0)
 . N SURCHILDREN ; Surviving Children
"RTN","MXMLPATH",110,0)
 . DO WEEDOUT(.SURCHILDREN,.SURPARENTS,.CNODES,DOCHAND) ; only run if we have parents (not first node in //)
"RTN","MXMLPATH",111,0)
 .
"RTN","MXMLPATH",112,0)
 . ; Any children left?
"RTN","MXMLPATH",113,0)
 . IF '$DATA(SURCHILDREN) KILL SURPARENTS QUIT  ; XPATH expr yielded no results.
"RTN","MXMLPATH",114,0)
 . ;
"RTN","MXMLPATH",115,0)
 . DO:$LENGTH(FILTER) FILTER(DOCHAND,.SURCHILDREN,FILTER) ; Apply filter expression
"RTN","MXMLPATH",116,0)
 . ;
"RTN","MXMLPATH",117,0)
 . ; DO DEBUG(.SURCHILDREN,DOCHAND)
"RTN","MXMLPATH",118,0)
 . ;
"RTN","MXMLPATH",119,0)
 . ; Any children left?
"RTN","MXMLPATH",120,0)
 . IF '$DATA(SURCHILDREN) KILL SURPARENTS QUIT  ; XPATH expr yielded no results.
"RTN","MXMLPATH",121,0)
 . ;
"RTN","MXMLPATH",122,0)
 . ; The children are now the new parents
"RTN","MXMLPATH",123,0)
 . KILL SURPARENTS MERGE SURPARENTS=SURCHILDREN
"RTN","MXMLPATH",124,0)
 ;
"RTN","MXMLPATH",125,0)
 MERGE RETURN=SURPARENTS ; The surviving parents are the return value
"RTN","MXMLPATH",126,0)
 QUIT
"RTN","MXMLPATH",127,0)
 ;
"RTN","MXMLPATH",128,0)
WEEDOUT(SURVIVORS,PARENTS,CHILDREN,DOCHAND) ; Remove bastard child nodes
"RTN","MXMLPATH",129,0)
 ; Input: .PARENTS AND .CHILDREN - node subscripted arrays
"RTN","MXMLPATH",130,0)
 ; Output: .SURVIVORS
"RTN","MXMLPATH",131,0)
 ; DOCHAND ditto
"RTN","MXMLPATH",132,0)
 ;
"RTN","MXMLPATH",133,0)
 ; No parents? Children are survivors
"RTN","MXMLPATH",134,0)
 I '$D(PARENTS) M SURVIVORS=CHILDREN QUIT
"RTN","MXMLPATH",135,0)
 ;
"RTN","MXMLPATH",136,0)
 NEW P SET P=0 FOR  SET P=$ORDER(PARENTS(P)) QUIT:'P  D
"RTN","MXMLPATH",137,0)
 . ;NEW C SET C=0 FOR  SET C=$ORDER(CHILDREN(C)) QUIT:'C  D
"RTN","MXMLPATH",138,0)
 . NEW C SET C=0 FOR  SET C=$ORDER(^TMP("MXMLDOM",$JOB,DOCHAND,P,"C",C)) QUIT:'C  D
"RTN","MXMLPATH",139,0)
 . . I $D(CHILDREN(C)) S SURVIVORS(C)=""
"RTN","MXMLPATH",140,0)
 QUIT
"RTN","MXMLPATH",141,0)
 ;
"RTN","MXMLPATH",142,0)
SEARCHNO(RETURN,DOCHAND,NODENAME) ; Simple linear search of nodes on MXML document
"RTN","MXMLPATH",143,0)
 ; Find nodes in document called NODENAME and return in RETURN.
"RTN","MXMLPATH",144,0)
 ; .RETURN,DOCHAND - ditto; NODENAME - string name of element node.
"RTN","MXMLPATH",145,0)
 NEW I SET I=0
"RTN","MXMLPATH",146,0)
 FOR  SET I=$ORDER(^TMP("MXMLDOM",$JOB,DOCHAND,I)) QUIT:'I  SET:^(I)=NODENAME RETURN(I)=""
"RTN","MXMLPATH",147,0)
 QUIT
"RTN","MXMLPATH",148,0)
 ;
"RTN","MXMLPATH",149,0)
ALLNODES(RETURN,DOCHAND) ; Return all XML element nodes in DOM.
"RTN","MXMLPATH",150,0)
 NEW I SET I=0 FOR  SET I=$ORDER(^TMP("MXMLDOM",$JOB,DOCHAND,I)) QUIT:'I  SET RETURN(I)=""
"RTN","MXMLPATH",151,0)
 QUIT
"RTN","MXMLPATH",152,0)
 ;
"RTN","MXMLPATH",153,0)
ISCHILD(PARENT,CHILD,DOCHAND) ; Is node CHILD (int) a child of node PARENT (int)?
"RTN","MXMLPATH",154,0)
 QUIT $DATA(^TMP("MXMLDOM",$JOB,DOCHAND,PARENT,"C",CHILD))
"RTN","MXMLPATH",155,0)
 ;
"RTN","MXMLPATH",156,0)
TEXTFIL(DOCHAND,NODES,TEXT) ; Text filter though the nodes
"RTN","MXMLPATH",157,0)
 ; Search the .NODES in MXMLDOM document DOCHAND for TEXT.
"RTN","MXMLPATH",158,0)
 NEW I SET I=0 FOR  SET I=$ORDER(NODES(I)) QUIT:'I  DO
"RTN","MXMLPATH",159,0)
 . IF ^TMP("MXMLDOM",$JOB,DOCHAND,I,"T",1)'=TEXT KILL NODES(I)
"RTN","MXMLPATH",160,0)
 QUIT
"RTN","MXMLPATH",161,0)
 ;
"RTN","MXMLPATH",162,0)
ATTRIB(DOCHAND,ATTRIB,NODES) ; Get ATTRIB attribute from each of the NODES
"RTN","MXMLPATH",163,0)
 ; Change NODES(n) array to NODES(n,ATTNAME)=VALUE array
"RTN","MXMLPATH",164,0)
 ; DOCHAND, ditto; ATTRIB - attribute string; NODES - subscripted array of
"RTN","MXMLPATH",165,0)
 ;   MXMLDOM nodes
"RTN","MXMLPATH",166,0)
 SET ATTRIB=$PIECE(ATTRIB,"@",2,99) ; Strip the @.
"RTN","MXMLPATH",167,0)
 NEW I SET I="" FOR  SET I=$ORDER(NODES(I)) QUIT:'I  DO
"RTN","MXMLPATH",168,0)
 . NEW V SET V=$$VALUE^MXMLDOM(DOCHAND,I,ATTRIB)
"RTN","MXMLPATH",169,0)
 . IF V="" KILL NODES(I)
"RTN","MXMLPATH",170,0)
 . ELSE  KILL NODES(I) SET NODES(I,ATTRIB)=V
"RTN","MXMLPATH",171,0)
 QUIT
"RTN","MXMLPATH",172,0)
 ;
"RTN","MXMLPATH",173,0)
FILTER(DOCHAND,NODES,FILTER) ; process [...] filter on xpath results
"RTN","MXMLPATH",174,0)
 ; INPUT:
"RTN","MXMLPATH",175,0)
 ; - DOCHAND, NODES: ditto
"RTN","MXMLPATH",176,0)
 ; - NODES is both INPUT and OUTPUT, as it is the array being filtered.
"RTN","MXMLPATH",177,0)
 ; - FILTER: filter string without the [].
"RTN","MXMLPATH",178,0)
 ;
"RTN","MXMLPATH",179,0)
 ; supports only the following filter expressions right now:
"RTN","MXMLPATH",180,0)
 ; - position(n)
"RTN","MXMLPATH",181,0)
 ; - n
"RTN","MXMLPATH",182,0)
 ; - last()
"RTN","MXMLPATH",183,0)
 ; - @att
"RTN","MXMLPATH",184,0)
 ; - @att="foo"
"RTN","MXMLPATH",185,0)
 ; - node
"RTN","MXMLPATH",186,0)
 ; - node="foo"
"RTN","MXMLPATH",187,0)
 ;
"RTN","MXMLPATH",188,0)
 QUIT:'$DATA(NODES)
"RTN","MXMLPATH",189,0)
 ;
"RTN","MXMLPATH",190,0)
 ; position(n)? convert to number.
"RTN","MXMLPATH",191,0)
 IF FILTER["position(" SET FILTER=$PIECE(FILTER,"position(",2),FILTER=$PIECE(FILTER,")")
"RTN","MXMLPATH",192,0)
 ;
"RTN","MXMLPATH",193,0)
 ; Number? Kill all nodes not in that ordinal position and done.
"RTN","MXMLPATH",194,0)
 IF +FILTER=FILTER DO  QUIT
"RTN","MXMLPATH",195,0)
 . NEW CNT SET CNT=0
"RTN","MXMLPATH",196,0)
 . NEW I SET I=0 FOR  SET I=$ORDER(NODES(I)) QUIT:'I  DO
"RTN","MXMLPATH",197,0)
 . . SET CNT=CNT+1
"RTN","MXMLPATH",198,0)
 . . IF CNT'=FILTER KILL NODES(I)
"RTN","MXMLPATH",199,0)
 ;
"RTN","MXMLPATH",200,0)
 ; last()? Grab that and done.
"RTN","MXMLPATH",201,0)
 IF FILTER="last()" DO  QUIT
"RTN","MXMLPATH",202,0)
 . NEW LAST SET LAST=$ORDER(NODES(""),-1)
"RTN","MXMLPATH",203,0)
 . NEW VAL SET VAL=NODES(LAST)
"RTN","MXMLPATH",204,0)
 . KILL NODES
"RTN","MXMLPATH",205,0)
 . SET NODES(LAST)=VAL
"RTN","MXMLPATH",206,0)
 ;
"RTN","MXMLPATH",207,0)
 ;
"RTN","MXMLPATH",208,0)
 ; No = sign. Either @attribute or node
"RTN","MXMLPATH",209,0)
 IF $LENGTH(FILTER,"=")=1 DO  QUIT
"RTN","MXMLPATH",210,0)
 . IF $EXTRACT(FILTER)="@" DO  QUIT  ; attribute
"RTN","MXMLPATH",211,0)
 . . NEW ATTRIB SET ATTRIB=FILTER
"RTN","MXMLPATH",212,0)
 . . DO ATTRIB(DOCHAND,ATTRIB,.NODES) ; filter by attribute
"RTN","MXMLPATH",213,0)
 . . ; Re-align the nodes as we don't care about attrib contents.
"RTN","MXMLPATH",214,0)
 . . ; (i.e. discard the return value of ATTRIB call and return nodes back
"RTN","MXMLPATH",215,0)
 . . ; (to original NODES(n) form).
"RTN","MXMLPATH",216,0)
 . . NEW I SET I=0 FOR  SET I=$ORDER(NODES(I)) QUIT:'I  SET NODES(I)="" KILL NODES(I,$PIECE(ATTRIB,"@",2))
"RTN","MXMLPATH",217,0)
 . ;
"RTN","MXMLPATH",218,0)
 . ELSE  DO  QUIT  ; node
"RTN","MXMLPATH",219,0)
 . . NEW CHILDNAME SET CHILDNAME=FILTER ; node name is same as FILTER
"RTN","MXMLPATH",220,0)
 . . ;
"RTN","MXMLPATH",221,0)
 . . ; Get all nodes with that filter name
"RTN","MXMLPATH",222,0)
 . . NEW CHILDREN DO SEARCHNO(.CHILDREN,DOCHAND,CHILDNAME)
"RTN","MXMLPATH",223,0)
 . . IF '$DATA(CHILDREN) KILL NODES QUIT  ; no children
"RTN","MXMLPATH",224,0)
 . . ;
"RTN","MXMLPATH",225,0)
 . . ; Remove all the filter nodes who are not directly under us
"RTN","MXMLPATH",226,0)
 . . ; Store result in PARENTS(n)=""
"RTN","MXMLPATH",227,0)
 . . NEW PARENTS
"RTN","MXMLPATH",228,0)
 . . NEW I SET I=0 FOR  SET I=$ORDER(NODES(I)) QUIT:'I  NEW J SET J=0 FOR  SET J=$ORDER(CHILDREN(J)) QUIT:'J  DO
"RTN","MXMLPATH",229,0)
 . . . IF $$ISCHILD(I,J,DOCHAND) SET PARENTS(I)=""
"RTN","MXMLPATH",230,0)
 . . ;
"RTN","MXMLPATH",231,0)
 . . ; Kill the original return array and recreate it from PARENTS
"RTN","MXMLPATH",232,0)
 . . KILL NODES
"RTN","MXMLPATH",233,0)
 . . MERGE NODES=PARENTS
"RTN","MXMLPATH",234,0)
 . . KILL PARENTS
"RTN","MXMLPATH",235,0)
 ;
"RTN","MXMLPATH",236,0)
 ; attribute @attribute="value"
"RTN","MXMLPATH",237,0)
 IF $EXTRACT(FILTER)="@" DO  QUIT
"RTN","MXMLPATH",238,0)
 . NEW ATTRIB SET ATTRIB=$PIECE(FILTER,"=")
"RTN","MXMLPATH",239,0)
 . DO ATTRIB(DOCHAND,ATTRIB,.NODES) ; Grab nodes that have this attribute
"RTN","MXMLPATH",240,0)
 . NEW V SET V=$PIECE(FILTER,"=",2),V=$PIECE(V,"""",2),V=$PIECE(V,"""") ; get value, rm quotes
"RTN","MXMLPATH",241,0)
 . ;
"RTN","MXMLPATH",242,0)
 . ; Filter out nodes whose attribute value doesn't match.
"RTN","MXMLPATH",243,0)
 . NEW I SET I=0 FOR  SET I=$ORDER(NODES(I)) QUIT:'I  DO
"RTN","MXMLPATH",244,0)
 . . IF NODES(I,$PIECE(ATTRIB,"@",2))'=V KILL NODES(I)
"RTN","MXMLPATH",245,0)
 . . ELSE  SET NODES(I)="" KILL NODES(I,$PIECE(ATTRIB,"@",2))
"RTN","MXMLPATH",246,0)
 ;
"RTN","MXMLPATH",247,0)
 ; NODE node="value"
"RTN","MXMLPATH",248,0)
 ELSE  DO  QUIT
"RTN","MXMLPATH",249,0)
 . NEW CHILDNAME SET CHILDNAME=$PIECE(FILTER,"=")
"RTN","MXMLPATH",250,0)
 . NEW CHILDREN DO SEARCHNO(.CHILDREN,DOCHAND,CHILDNAME) ; Grab nodes with this value
"RTN","MXMLPATH",251,0)
 . NEW V SET V=$PIECE(FILTER,"=",2),V=$PIECE(V,"""",2),V=$PIECE(V,"""") ; get value, rm quotes
"RTN","MXMLPATH",252,0)
 . ;
"RTN","MXMLPATH",253,0)
 . ; Remote nodes whose text contents are not the filter value.
"RTN","MXMLPATH",254,0)
 . DO TEXTFIL(DOCHAND,.CHILDREN,V)
"RTN","MXMLPATH",255,0)
 . IF '$DATA(CHILDREN) KILL NODES QUIT
"RTN","MXMLPATH",256,0)
 . ;
"RTN","MXMLPATH",257,0)
 . ; Remove all filter nodes not directly under us.
"RTN","MXMLPATH",258,0)
 . ; Store result in PARENTS(n)=""
"RTN","MXMLPATH",259,0)
 . NEW PARENTS
"RTN","MXMLPATH",260,0)
 . NEW I SET I=0 FOR  SET I=$ORDER(NODES(I)) QUIT:'I  NEW J SET J=0 FOR  SET J=$ORDER(CHILDREN(J)) QUIT:'J  DO
"RTN","MXMLPATH",261,0)
 . . IF $$ISCHILD(I,J,DOCHAND) SET PARENTS(I)=""
"RTN","MXMLPATH",262,0)
 . ;
"RTN","MXMLPATH",263,0)
 . ; Kill return value and replace it with PARENTS.
"RTN","MXMLPATH",264,0)
 . KILL NODES
"RTN","MXMLPATH",265,0)
 . MERGE NODES=PARENTS
"RTN","MXMLPATH",266,0)
 . KILL PARENTS
"RTN","MXMLPATH",267,0)
 ;
"RTN","MXMLPATH",268,0)
 QUIT
"RTN","MXMLPATH",269,0)
DEBUG(NODES,DOCHAND) ; Debug print; Just used internally for debugging.
"RTN","MXMLPATH",270,0)
 N C S C=0
"RTN","MXMLPATH",271,0)
 N N S N=0 F  S N=$O(NODES(N)) Q:'N  W N_": "_^TMP("MXMLDOM",$J,DOCHAND,N),! S C=C+1
"RTN","MXMLPATH",272,0)
 W "Count: "_C,!
"RTN","MXMLPATH",273,0)
 QUIT
"RTN","MXMLPATT")
0^8^B212307526
"RTN","MXMLPATT",1,0)
MXMLPATT ; VEN/SMH - MXML XPath Processor Unit Tests;2013-08-06  10:35 AM
"RTN","MXMLPATT",2,0)
 ;;2.1;XML PROCESSING UTILITIES;;Nov 27, 2013;Build 9
"RTN","MXMLPATT",3,0)
TEST ; M-Unit Entry point for Unit Testing
"RTN","MXMLPATT",4,0)
 SET IO=$PRINCIPAL
"RTN","MXMLPATT",5,0)
 NEW DIQUIET SET DIQUIET=1
"RTN","MXMLPATT",6,0)
 DO DT^DICRW
"RTN","MXMLPATT",7,0)
 DO:$LENGTH($TEXT(EN^XTMUNIT)) EN^XTMUNIT($TEXT(+0),1)
"RTN","MXMLPATT",8,0)
 QUIT
"RTN","MXMLPATT",9,0)
 ;
"RTN","MXMLPATT",10,0)
STARTUP ; M-Unit start-up; Load XML Document
"RTN","MXMLPATT",11,0)
 KILL ^TMP($JOB) ; array where we will store it
"RTN","MXMLPATT",12,0)
 NEW L ; Line text
"RTN","MXMLPATT",13,0)
 ;
"RTN","MXMLPATT",14,0)
 ; Load document
"RTN","MXMLPATT",15,0)
 NEW I FOR I=1:1 SET L=$TEXT(TESTDATA+I) SET L=$PIECE(L,";;",2) QUIT:L="<<END>>"  QUIT:L=""  SET ^TMP($JOB,I)=L
"RTN","MXMLPATT",16,0)
 ;
"RTN","MXMLPATT",17,0)
 ; Parse document
"RTN","MXMLPATT",18,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",19,0)
 SET DOCHAND=$$EN^MXMLDOM($NAME(^TMP($JOB)),"W")
"RTN","MXMLPATT",20,0)
 ;
"RTN","MXMLPATT",21,0)
 IF 'DOCHAND DO FAIL^XTMUNIT("Could not parse XML")
"RTN","MXMLPATT",22,0)
 ;
"RTN","MXMLPATT",23,0)
 KILL ^TMP($JOB)
"RTN","MXMLPATT",24,0)
 QUIT
"RTN","MXMLPATT",25,0)
SHUTDOWN ; M-Unit Shutdown ; Delete parsed XML document from memory
"RTN","MXMLPATT",26,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",27,0)
 DO DELETE^MXMLDOM(DOCHAND)
"RTN","MXMLPATT",28,0)
 KILL DOCHAND
"RTN","MXMLPATT",29,0)
 QUIT
"RTN","MXMLPATT",30,0)
 ;
"RTN","MXMLPATT",31,0)
TESTS1 ; @TEST - Test /PEPSResponse/Body/drugCheck/drugDrugChecks/drugDrugCheck/source [extant]
"RTN","MXMLPATT",32,0)
 NEW XPATH SET XPATH="/PEPSResponse/Body/drugCheck/drugDrugChecks/drugDrugCheck/source"
"RTN","MXMLPATT",33,0)
 ;
"RTN","MXMLPATT",34,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",35,0)
 NEW RTN
"RTN","MXMLPATT",36,0)
 DO XPATH^MXMLPATH(.RTN,DOCHAND,XPATH)
"RTN","MXMLPATT",37,0)
 NEW TEXT
"RTN","MXMLPATT",38,0)
 DO TEXT^MXMLDOM(DOCHAND,$ORDER(RTN("")),$NAME(TEXT))
"RTN","MXMLPATT",39,0)
 DO CHKEQ^XTMUNIT(TEXT(1),"FDB",XPATH_" expression failed")
"RTN","MXMLPATT",40,0)
 QUIT
"RTN","MXMLPATT",41,0)
 ;
"RTN","MXMLPATT",42,0)
TESTS2 ; @TEST - Test /PEPSResponse/drugCheck/drugDrugChecks/drugDrugCheck/source [n/a]
"RTN","MXMLPATT",43,0)
 NEW XPATH SET XPATH="/PEPSResponse/drugCheck/drugDrugChecks/drugDrugCheck/source"
"RTN","MXMLPATT",44,0)
 ;
"RTN","MXMLPATT",45,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",46,0)
 NEW RTN
"RTN","MXMLPATT",47,0)
 DO XPATH^MXMLPATH(.RTN,DOCHAND,XPATH)
"RTN","MXMLPATT",48,0)
 NEW NODE SET NODE=$ORDER(RTN(""))
"RTN","MXMLPATT",49,0)
 DO CHKEQ^XTMUNIT(NODE,"",XPATH_" shouldn't be found")
"RTN","MXMLPATT",50,0)
 QUIT
"RTN","MXMLPATT",51,0)
 ;
"RTN","MXMLPATT",52,0)
TESTS3 ; @TEST - Test a multiple /PEPSResponse/.../reference [extant]
"RTN","MXMLPATT",53,0)
 NEW XPATH SET XPATH="/PEPSResponse/Body/drugCheck/drugDrugChecks/drugDrugCheck/professionalMonograph/references/reference"
"RTN","MXMLPATT",54,0)
 ;
"RTN","MXMLPATT",55,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",56,0)
 NEW RTN
"RTN","MXMLPATT",57,0)
 DO XPATH^MXMLPATH(.RTN,DOCHAND,XPATH)
"RTN","MXMLPATT",58,0)
 ;
"RTN","MXMLPATT",59,0)
 ;
"RTN","MXMLPATT",60,0)
 ; Count returned nodes
"RTN","MXMLPATT",61,0)
 NEW C SET C=0
"RTN","MXMLPATT",62,0)
 NEW N SET N=0 FOR  SET N=$ORDER(RTN(N)) QUIT:'N  SET C=C+1
"RTN","MXMLPATT",63,0)
 ;
"RTN","MXMLPATT",64,0)
 DO CHKEQ^XTMUNIT(C,5,"5 reference tags should exist")
"RTN","MXMLPATT",65,0)
 QUIT
"RTN","MXMLPATT",66,0)
 ;
"RTN","MXMLPATT",67,0)
TESTSS1 ; @TEST - Test //reference [extant]
"RTN","MXMLPATT",68,0)
 NEW XPATH SET XPATH="//reference"
"RTN","MXMLPATT",69,0)
 ;
"RTN","MXMLPATT",70,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",71,0)
 NEW RTN
"RTN","MXMLPATT",72,0)
 DO XPATH^MXMLPATH(.RTN,DOCHAND,XPATH)
"RTN","MXMLPATT",73,0)
 ;
"RTN","MXMLPATT",74,0)
 ; Count returned nodes
"RTN","MXMLPATT",75,0)
 NEW C SET C=0
"RTN","MXMLPATT",76,0)
 NEW N SET N=0 FOR  SET N=$ORDER(RTN(N)) QUIT:'N  SET C=C+1
"RTN","MXMLPATT",77,0)
 ;
"RTN","MXMLPATT",78,0)
 DO CHKEQ^XTMUNIT(C,5,"5 reference tags should exist")
"RTN","MXMLPATT",79,0)
 QUIT
"RTN","MXMLPATT",80,0)
 ;
"RTN","MXMLPATT",81,0)
TESTSS2 ; @TEST - Test //referenceblah [n/a]
"RTN","MXMLPATT",82,0)
 NEW XPATH SET XPATH="//referenceblah"
"RTN","MXMLPATT",83,0)
 ;
"RTN","MXMLPATT",84,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",85,0)
 NEW RTN
"RTN","MXMLPATT",86,0)
 DO XPATH^MXMLPATH(.RTN,DOCHAND,XPATH)
"RTN","MXMLPATT",87,0)
 ;
"RTN","MXMLPATT",88,0)
 ; Count returned nodes
"RTN","MXMLPATT",89,0)
 NEW C SET C=0
"RTN","MXMLPATT",90,0)
 NEW N SET N=0 FOR  SET N=$ORDER(RTN(N)) QUIT:'N  SET C=C+1
"RTN","MXMLPATT",91,0)
 ;
"RTN","MXMLPATT",92,0)
 DO CHKEQ^XTMUNIT(C,0,"0 referenceblah tags should exist")
"RTN","MXMLPATT",93,0)
 QUIT
"RTN","MXMLPATT",94,0)
 ;
"RTN","MXMLPATT",95,0)
TESTSS3 ; @TEST - Test //interactedDrugList/drug [extant]
"RTN","MXMLPATT",96,0)
 NEW XPATH SET XPATH="//interactedDrugList/drug"
"RTN","MXMLPATT",97,0)
 ;
"RTN","MXMLPATT",98,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",99,0)
 NEW RTN
"RTN","MXMLPATT",100,0)
 DO XPATH^MXMLPATH(.RTN,DOCHAND,XPATH)
"RTN","MXMLPATT",101,0)
 ;
"RTN","MXMLPATT",102,0)
 ; Count returned nodes
"RTN","MXMLPATT",103,0)
 NEW C SET C=0
"RTN","MXMLPATT",104,0)
 NEW N SET N=0 FOR  SET N=$ORDER(RTN(N)) QUIT:'N  SET C=C+1
"RTN","MXMLPATT",105,0)
 ;
"RTN","MXMLPATT",106,0)
 DO CHKEQ^XTMUNIT(C,2,"2 "_XPATH_" tags should exist")
"RTN","MXMLPATT",107,0)
 QUIT
"RTN","MXMLPATT",108,0)
 ;
"RTN","MXMLPATT",109,0)
TESTSS4 ; @TEST - Test //interactedDrugList/drum [n/a]
"RTN","MXMLPATT",110,0)
 NEW XPATH SET XPATH="//interactedDrugList/drum"
"RTN","MXMLPATT",111,0)
 ;
"RTN","MXMLPATT",112,0)
 ;
"RTN","MXMLPATT",113,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",114,0)
 NEW RTN
"RTN","MXMLPATT",115,0)
 DO XPATH^MXMLPATH(.RTN,DOCHAND,XPATH)
"RTN","MXMLPATT",116,0)
 ;
"RTN","MXMLPATT",117,0)
 ; Count returned nodes
"RTN","MXMLPATT",118,0)
 NEW C SET C=0
"RTN","MXMLPATT",119,0)
 NEW N SET N=0 FOR  SET N=$ORDER(RTN(N)) QUIT:'N  SET C=C+1
"RTN","MXMLPATT",120,0)
 ;
"RTN","MXMLPATT",121,0)
 DO CHKEQ^XTMUNIT(C,0,"0 "_XPATH_" tags should exist")
"RTN","MXMLPATT",122,0)
 QUIT
"RTN","MXMLPATT",123,0)
 ;
"RTN","MXMLPATT",124,0)
TESTREL1 ; @TEST - Test Relative paths (//Header, then MUser) [extant]
"RTN","MXMLPATT",125,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",126,0)
 NEW RTN
"RTN","MXMLPATT",127,0)
 DO XPATH^MXMLPATH(.RTN,DOCHAND,"//Header")
"RTN","MXMLPATT",128,0)
 NEW % SET %=$$XPATH^MXMLPATH(.RTN,DOCHAND,"MUser")
"RTN","MXMLPATT",129,0)
 DO CHKEQ^XTMUNIT($$VALUE^MXMLDOM(DOCHAND,%,"duz"),88660079,"Wrong tag retrieved")
"RTN","MXMLPATT",130,0)
 QUIT
"RTN","MXMLPATT",131,0)
 ;
"RTN","MXMLPATT",132,0)
TESTREL2 ; @TEST - Test Relative paths (//Header, then interactedDrugList/drug) [n/a]
"RTN","MXMLPATT",133,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",134,0)
 NEW RTN
"RTN","MXMLPATT",135,0)
 DO XPATH^MXMLPATH(.RTN,DOCHAND,"//Header")
"RTN","MXMLPATT",136,0)
 NEW % SET %=$$XPATH^MXMLPATH(.RTN,DOCHAND,"interactedDrugList/drug")
"RTN","MXMLPATT",137,0)
 DO CHKEQ^XTMUNIT($ORDER(RTN("")),"","No results should be found.")
"RTN","MXMLPATT",138,0)
 QUIT
"RTN","MXMLPATT",139,0)
 ;
"RTN","MXMLPATT",140,0)
TESTATT1 ; @TEST - Test Attribute //@orderNumber [extant]
"RTN","MXMLPATT",141,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",142,0)
 NEW RTN
"RTN","MXMLPATT",143,0)
 DO XPATH^MXMLPATH(.RTN,DOCHAND,"//@orderNumber")
"RTN","MXMLPATT",144,0)
 NEW X,Y,Z SET X=$ORDER(RTN("")),Y=$ORDER(RTN(X,"")),Z=RTN(X,Y)
"RTN","MXMLPATT",145,0)
 DO CHKEQ^XTMUNIT(Z,"Z;2;Prospect","Attribute not retrieved properly")
"RTN","MXMLPATT",146,0)
 QUIT
"RTN","MXMLPATT",147,0)
 ;
"RTN","MXMLPATT",148,0)
TESTATT2 ; @TEST - Test Attribute //drug/@vuid [extant]
"RTN","MXMLPATT",149,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",150,0)
 DO CHKEQ^XTMUNIT($$XPATH^MXMLPATH(,DOCHAND,"//drug/@vuid"),778899,"Attribute not retrieved properly")
"RTN","MXMLPATT",151,0)
 QUIT
"RTN","MXMLPATT",152,0)
 ;
"RTN","MXMLPATT",153,0)
TESTATT3 ; @TEST - Test Attribute //drug/dada [n/a]
"RTN","MXMLPATT",154,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",155,0)
 DO CHKEQ^XTMUNIT($$XPATH^MXMLPATH(,DOCHAND,"//drug/@dada"),"","non-existent Attribute")
"RTN","MXMLPATT",156,0)
 QUIT
"RTN","MXMLPATT",157,0)
 ;
"RTN","MXMLPATT",158,0)
TESTATT4 ; @TEST - Test relative attribute //Header, MServer, @stationNumber [extant]
"RTN","MXMLPATT",159,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",160,0)
 NEW %1 SET %1=$$XPATH^MXMLPATH(,DOCHAND,"//Header")
"RTN","MXMLPATT",161,0)
 NEW %2 SET %2=$$XPATH^MXMLPATH(,DOCHAND,"MServer")
"RTN","MXMLPATT",162,0)
 NEW %3 SET %3=$$XPATH^MXMLPATH(,DOCHAND,"@stationNumber")
"RTN","MXMLPATT",163,0)
 DO CHKEQ^XTMUNIT(%3,45,"Attribute not retrieved properly")
"RTN","MXMLPATT",164,0)
 QUIT
"RTN","MXMLPATT",165,0)
 ;
"RTN","MXMLPATT",166,0)
TESTFIL1 ; @TEST - Test ordinal filter expressions //references/reference[3] [extant]
"RTN","MXMLPATT",167,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",168,0)
 NEW XPATH SET XPATH="//references/reference[3]"
"RTN","MXMLPATT",169,0)
 NEW RTN DO XPATH^MXMLPATH(.RTN,DOCHAND,XPATH)
"RTN","MXMLPATT",170,0)
 NEW TXT SET TXT=^TMP("MXMLDOM",$JOB,DOCHAND,$ORDER(RTN("")),"T",1)
"RTN","MXMLPATT",171,0)
 DO CHKTF^XTMUNIT(TXT["nelfinavir","Incorrect node retrieved")
"RTN","MXMLPATT",172,0)
 QUIT
"RTN","MXMLPATT",173,0)
 ;
"RTN","MXMLPATT",174,0)
TESTFIL2 ; @TEST - Test ordinal filter expressions //references/reference[11] [n/a]
"RTN","MXMLPATT",175,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",176,0)
 NEW XPATH SET XPATH="//references/reference[11]"
"RTN","MXMLPATT",177,0)
 NEW % SET %=$$XPATH^MXMLPATH(,DOCHAND,XPATH)
"RTN","MXMLPATT",178,0)
 DO CHKEQ^XTMUNIT(%,"","reference[11] shouldn't exist")
"RTN","MXMLPATT",179,0)
 QUIT
"RTN","MXMLPATT",180,0)
 ;
"RTN","MXMLPATT",181,0)
TESTFIL3 ; @TEST - Test ordinal filter expression //reference[position(3)] [extant]
"RTN","MXMLPATT",182,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",183,0)
 NEW XPATH SET XPATH="//references/reference[position(3)]"
"RTN","MXMLPATT",184,0)
 NEW RTN DO XPATH^MXMLPATH(.RTN,DOCHAND,XPATH)
"RTN","MXMLPATT",185,0)
 NEW TXT SET TXT=^TMP("MXMLDOM",$JOB,DOCHAND,$ORDER(RTN("")),"T",1)
"RTN","MXMLPATT",186,0)
 DO CHKTF^XTMUNIT(TXT["nelfinavir","Incorrect node retrieved")
"RTN","MXMLPATT",187,0)
 QUIT
"RTN","MXMLPATT",188,0)
 ;
"RTN","MXMLPATT",189,0)
TESTFIL4 ; @TEST - Test last() filter expression //reference[last()] [extant]
"RTN","MXMLPATT",190,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",191,0)
 NEW XPATH SET XPATH="//reference[last()]"
"RTN","MXMLPATT",192,0)
 NEW % SET %=$$XPATH^MXMLPATH(,DOCHAND,XPATH)
"RTN","MXMLPATT",193,0)
 NEW TXT SET TXT=^TMP("MXMLDOM",$JOB,DOCHAND,%,"T",1)
"RTN","MXMLPATT",194,0)
 DO CHKTF^XTMUNIT(TXT["tipranavir","Incorrect node retrieved")
"RTN","MXMLPATT",195,0)
 QUIT
"RTN","MXMLPATT",196,0)
 ;
"RTN","MXMLPATT",197,0)
TESTFIL5 ; @TEST - Test @attribute as //drug[@vuid] [extant]
"RTN","MXMLPATT",198,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",199,0)
 NEW XPATH SET XPATH="//drug[@vuid]"
"RTN","MXMLPATT",200,0)
 NEW % SET %=$$XPATH^MXMLPATH(,DOCHAND,XPATH)
"RTN","MXMLPATT",201,0)
 DO CHKEQ^XTMUNIT($$VALUE^MXMLDOM(DOCHAND,%,"ien"),113,"Incorrect node retrieved")
"RTN","MXMLPATT",202,0)
 QUIT
"RTN","MXMLPATT",203,0)
 ;
"RTN","MXMLPATT",204,0)
TESTFIL6 ; @TEST - Test @attribute as //drug[@vuib] [n/a]
"RTN","MXMLPATT",205,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",206,0)
 NEW XPATH SET XPATH="//drug[@vuib]"
"RTN","MXMLPATT",207,0)
 NEW % SET %=$$XPATH^MXMLPATH(,DOCHAND,XPATH)
"RTN","MXMLPATT",208,0)
 DO CHKEQ^XTMUNIT(%,"","Incorrect node retrieved")
"RTN","MXMLPATT",209,0)
 QUIT
"RTN","MXMLPATT",210,0)
 ;
"RTN","MXMLPATT",211,0)
TESTFIL7 ; @TEST - Test node as //professionalMonograph[monographTitle] [extant]
"RTN","MXMLPATT",212,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",213,0)
 NEW XPATH SET XPATH="//professionalMonograph[monographTitle]"
"RTN","MXMLPATT",214,0)
 NEW % SET %=$$XPATH^MXMLPATH(,DOCHAND,XPATH)
"RTN","MXMLPATT",215,0)
 DO CHKEQ^XTMUNIT(^TMP("MXMLDOM",$JOB,DOCHAND,%),"professionalMonograph","Incorrect node retrieved")
"RTN","MXMLPATT",216,0)
 QUIT
"RTN","MXMLPATT",217,0)
 ;
"RTN","MXMLPATT",218,0)
TESTFIL8 ; @TEST - Test node as //professionalMonograph[monographTible] [n/a]
"RTN","MXMLPATT",219,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",220,0)
 NEW XPATH SET XPATH="//professionalMonograph[monographTible]"
"RTN","MXMLPATT",221,0)
 NEW % SET %=$$XPATH^MXMLPATH(,DOCHAND,XPATH)
"RTN","MXMLPATT",222,0)
 DO CHKEQ^XTMUNIT(%,"","monographTible does not exist")
"RTN","MXMLPATT",223,0)
 QUIT
"RTN","MXMLPATT",224,0)
 ;
"RTN","MXMLPATT",225,0)
TESTFIL9 ; @TEST - Test attribute="value" as //drug[@ien="113"] [extant]
"RTN","MXMLPATT",226,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",227,0)
 NEW XPATH SET XPATH="//drug[@ien=""113""]"
"RTN","MXMLPATT",228,0)
 NEW % SET %=$$XPATH^MXMLPATH(,DOCHAND,XPATH)
"RTN","MXMLPATT",229,0)
 DO CHKEQ^XTMUNIT($$VALUE^MXMLDOM(DOCHAND,%,"gcnSeqNo"),266,"Incorrect node retrieved")
"RTN","MXMLPATT",230,0)
 QUIT
"RTN","MXMLPATT",231,0)
 ;
"RTN","MXMLPATT",232,0)
TESTFI10 ; @TEST - Test attribute="value" as //drug[@ien="999"] [n/a]
"RTN","MXMLPATT",233,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",234,0)
 NEW XPATH SET XPATH="//drug[@ien=""999""]"
"RTN","MXMLPATT",235,0)
 NEW % SET %=$$XPATH^MXMLPATH(,DOCHAND,XPATH)
"RTN","MXMLPATT",236,0)
 DO CHKEQ^XTMUNIT(%,"","drug of IEN 999 doesn't exist")
"RTN","MXMLPATT",237,0)
 QUIT
"RTN","MXMLPATT",238,0)
 ;
"RTN","MXMLPATT",239,0)
TESTFI11 ; @TEST - Test node="value" as //drugDrugCheck[id="283"] [extant]
"RTN","MXMLPATT",240,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",241,0)
 NEW XPATH SET XPATH="//drugDrugCheck[id=""283""]"
"RTN","MXMLPATT",242,0)
 NEW % SET %=$$XPATH^MXMLPATH(,DOCHAND,XPATH)
"RTN","MXMLPATT",243,0)
 DO CHKEQ^XTMUNIT(^TMP("MXMLDOM",$JOB,DOCHAND,%),"drugDrugCheck","Incorrect node retrieved")
"RTN","MXMLPATT",244,0)
 QUIT
"RTN","MXMLPATT",245,0)
 ;
"RTN","MXMLPATT",246,0)
TESTFI12 ; @TEST - Test node="value" as //drugDrugCheck[id="999"] [n/a]
"RTN","MXMLPATT",247,0)
 ; ZEXCEPT: DOCHAND
"RTN","MXMLPATT",248,0)
 NEW XPATH SET XPATH="//drugDrugCheck[id=""999""]"
"RTN","MXMLPATT",249,0)
 NEW % SET %=$$XPATH^MXMLPATH(,DOCHAND,XPATH)
"RTN","MXMLPATT",250,0)
 DO CHKEQ^XTMUNIT(%,"","drugDrugCheck of id 999 doesn't exist")
"RTN","MXMLPATT",251,0)
 QUIT
"RTN","MXMLPATT",252,0)
 ;
"RTN","MXMLPATT",253,0)
TESTDATA ; from https://github.com/OSEHRA-Sandbox/MOCHA/tree/master/etc/xml/test/messages
"RTN","MXMLPATT",254,0)
 ;;<?xml version="1.0" encoding="UTF-8"?>
"RTN","MXMLPATT",255,0)
 ;;<PEPSResponse
"RTN","MXMLPATT",256,0)
 ;;    xsi:schemaLocation="gov/va/med/pharmacy/peps/external/common/preencapsulation/vo/drug/check/response drugCheckSchemaOutput.xsd"
"RTN","MXMLPATT",257,0)
 ;;    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="gov/va/med/pharmacy/peps/external/common/preencapsulation/vo/drug/check/response">
"RTN","MXMLPATT",258,0)
 ;;    <Header>
"RTN","MXMLPATT",259,0)
 ;;        <Time value="0845"/>
"RTN","MXMLPATT",260,0)
 ;;        <MServer namespace="VISTA" uci="text" ip="127.0.000.1"
"RTN","MXMLPATT",261,0)
 ;;            serverName="Server Name" stationNumber="45"/>
"RTN","MXMLPATT",262,0)
 ;;        <MUser userName="user" duz="88660079" jobNumber="1001"/>
"RTN","MXMLPATT",263,0)
 ;;        <PEPSVersion difIssueDate="20091002" difBuildVersion="6" difDbVersion="3.2"/>
"RTN","MXMLPATT",264,0)
 ;;    </Header>
"RTN","MXMLPATT",265,0)
 ;;    <Body>
"RTN","MXMLPATT",266,0)
 ;;        <drugCheck>
"RTN","MXMLPATT",267,0)
 ;;            <drugDrugChecks>
"RTN","MXMLPATT",268,0)
 ;;                <drugDrugCheck>
"RTN","MXMLPATT",269,0)
 ;;                    <id>283</id>
"RTN","MXMLPATT",270,0)
 ;;                    <source>FDB</source>
"RTN","MXMLPATT",271,0)
 ;;                    <interactedDrugList>
"RTN","MXMLPATT",272,0)
 ;;                        <drug orderNumber="Z;2;Prospect" ien="455" gcnSeqNo="25485"/>
"RTN","MXMLPATT",273,0)
 ;;                        <drug orderNumber="Z;1;Prospect" ien="113"
"RTN","MXMLPATT",274,0)
 ;;                            vuid="778899" gcnSeqNo="266"/>
"RTN","MXMLPATT",275,0)
 ;;                    </interactedDrugList>
"RTN","MXMLPATT",276,0)
 ;;                    <severity>Contraindicated Drug Combination</severity>
"RTN","MXMLPATT",277,0)
 ;;                    <interaction>SELECTED PROTEASE INHIBITORS/AMIODARONE</interaction>
"RTN","MXMLPATT",278,0)
 ;;                    <shortText>INDINAVIR SULFATE ORAL CAPSULE 400 MG and AMIODARONE HCL ORAL TABLET 200 MG may interact based on the potential interaction between SELECTED PROTEASE INHIBITORS and AMIODARONE.</shortText>
"RTN","MXMLPATT",279,0)
 ;;                    <professionalMonograph>
"RTN","MXMLPATT",280,0)
 ;;                        <monographSource>FDB</monographSource>
"RTN","MXMLPATT",281,0)
 ;;                        <disclaimer>This information is generalized and not intended as specific medical advice. Consult your healthcare professional before taking or discontinuing any drug or commencing any course of treatment.</disclaimer>
"RTN","MXMLPATT",282,0)
 ;;                        <monographTitle>MONOGRAPH TITLE:  Selected Protease Inhibitors/Amiodarone</monographTitle>
"RTN","MXMLPATT",283,0)
 ;;                        <severityLevel>SEVERITY LEVEL:  1-Contraindicated Drug Combination: This drug combination is contraindicated and generally should not be dispensed or administered to the same patient.</severityLevel>
"RTN","MXMLPATT",284,0)
 ;;                        <mechanismOfAction>MECHANISM OF ACTION:  Indinavir,(1) nelfinavir,(2) ritonavir,(3) and tipranavir coadministered with ritonavir(4) may inhibit the metabolism of amiodarone at CYP P-450-3A4.</mechanismOfAction>
"RTN","MXMLPATT",285,0)
 ;;                        <clinicalEffects>CLINICAL EFFECTS:  The concurrent administration of amiodarone with indinavir,(1) nelfinavir,(2) ritonavir,(3) or tipranavir coadministered with ritonavir(4)
"RTN","MXMLPATT",286,0)
 ;;may result in increased levels, clinical effects, and toxicity of amiodarone.</clinicalEffects>
"RTN","MXMLPATT",287,0)
 ;;                        <predisposingFactors>PREDISPOSING FACTORS:  None determined.</predisposingFactors>
"RTN","MXMLPATT",288,0)
 ;;                        <patientManagement>PATIENT MANAGEMENT:  The concurrent administration of amiodarone with indinavir,(1) nelfinavir(2), ritonavir,(3) or tipranavir coadministered with ritonavir(4)
"RTN","MXMLPATT",289,0)
 ;;is contraindicated by the manufacturers of indinavir,(1) nelfinavir(2), ritonavir,(3) and tipranavir coadministered with ritonavir. (4)</patientManagement>
"RTN","MXMLPATT",290,0)
 ;;                        <discussion>DISCUSSION:  Indinavir has been shown to inhibit CYP P-450-3A4.  Therefore, the manufacturer of indinavir states that the concurrent administration of indinavir with amiodarone,
"RTN","MXMLPATT",291,0)
 ;;which is metabolized by CYP P-450-3A4, is contraindicated.(1)Nelfinavir has been shown to inhibit CYP P-450-3A4.
"RTN","MXMLPATT",292,0)
 ;;Therefore, the manufacturer of nelfinavir states that the concurrent administration of
"RTN","MXMLPATT",293,0)
 ;;nelfinavir with amiodarone, which is metabolized by CYP P-450-3A4, is contraindicated.(2)
"RTN","MXMLPATT",294,0)
 ;;Ritonavir has also been shown to inhibit CYP P-450-3A4. Therefore, the manufacturer of ritonavir state that the concurrent administration of ritonavir with amiodarone is contraindicated.(3)</discussion>
"RTN","MXMLPATT",295,0)
 ;;                        <references>
"RTN","MXMLPATT",296,0)
 ;;                            <reference><![CDATA[REFERENCES:]]></reference>
"RTN","MXMLPATT",297,0)
 ;;                            <reference><![CDATA[1.Crixivan (indinavir sulfate) US prescribing information. Merck & Co., Inc. December, 2008.]]></reference>
"RTN","MXMLPATT",298,0)
 ;;                            <reference><![CDATA[2.Viracept (nelfinavir mesylate) US prescribing information. Agouron Pharmaceuticals, Inc. July, 2007.]]></reference>
"RTN","MXMLPATT",299,0)
 ;;                            <reference><![CDATA[3.Norvir (ritonavir) US prescribing information. Abbott Laboratories September 30, 2008.]]></reference>
"RTN","MXMLPATT",300,0)
 ;;                            <reference><![CDATA[4.Aptivus (tipranavir) US prescribing information. Boehringer Ingelheim Pharmaceuticals, Inc. June, 2009.]]></reference>
"RTN","MXMLPATT",301,0)
 ;;                        </references>
"RTN","MXMLPATT",302,0)
 ;;                        <!-- THIS IS A COMMENT -->
"RTN","MXMLPATT",303,0)
 ;;                    </professionalMonograph>
"RTN","MXMLPATT",304,0)
 ;;                </drugDrugCheck>
"RTN","MXMLPATT",305,0)
 ;;            </drugDrugChecks>
"RTN","MXMLPATT",306,0)
 ;;        </drugCheck>
"RTN","MXMLPATT",307,0)
 ;;    </Body>
"RTN","MXMLPATT",308,0)
 ;;</PEPSResponse>
"RTN","MXMLPATT",309,0)
 ;;<<END>>
"RTN","MXMLPRS0")
0^1^B72264453
"RTN","MXMLPRS0",1,0)
MXMLPRS0 ;SAIC/DKM - XML Parser ;03/09/2005  12:57
"RTN","MXMLPRS0",2,0)
 ;;2.1;XML PROCESSING UTILITIES;;Nov 27, 2013;Build 9
"RTN","MXMLPRS0",3,0)
 ;=================================================================
"RTN","MXMLPRS0",4,0)
 ; State 0: Prolog
"RTN","MXMLPRS0",5,0)
0 N ATTR
"RTN","MXMLPRS0",6,0)
 S ST=1
"RTN","MXMLPRS0",7,0)
 D WS()
"RTN","MXMLPRS0",8,0)
 I '$$NEXT("<?xml") D ERROR(31) Q
"RTN","MXMLPRS0",9,0)
 D WS(1),ATTRIBS("?xml",.ATTR),WS()
"RTN","MXMLPRS0",10,0)
 I $$NEXT("?>",3)
"RTN","MXMLPRS0",11,0)
 D:$G(ATTR("version"))'="1.0" ERROR(10,$G(ATTR("version")))
"RTN","MXMLPRS0",12,0)
 Q
"RTN","MXMLPRS0",13,0)
 ; State 1: Document type declaration
"RTN","MXMLPRS0",14,0)
1 N PUB,SYS
"RTN","MXMLPRS0",15,0)
 D WS()
"RTN","MXMLPRS0",16,0)
 Q:$$COMMENT
"RTN","MXMLPRS0",17,0)
 S ST=2
"RTN","MXMLPRS0",18,0)
 I '$$NEXT("<!DOCTYPE") D ERROR(32) Q
"RTN","MXMLPRS0",19,0)
 D WS(1)
"RTN","MXMLPRS0",20,0)
 S LVL(0)=$$NAME(2),DTD=""
"RTN","MXMLPRS0",21,0)
 D WS(),SYSPUB(.SYS,.PUB)
"RTN","MXMLPRS0",22,0)
 I OPTION["V",$L(SYS)!$L(PUB) D
"RTN","MXMLPRS0",23,0)
 .S DTD=$$EXTRNL(SYS,PUB)
"RTN","MXMLPRS0",24,0)
 D WS(),CBK("DOCTYPE",LVL(0),PUB,SYS)
"RTN","MXMLPRS0",25,0)
 I $$NEXT("[") S ST=5
"RTN","MXMLPRS0",26,0)
 E  S:$$NEXT(">",3) ST=6
"RTN","MXMLPRS0",27,0)
 Q
"RTN","MXMLPRS0",28,0)
 ; State 2: Non-markup text
"RTN","MXMLPRS0",29,0)
2 N TXT,CHR
"RTN","MXMLPRS0",30,0)
 D:'LVL WS()
"RTN","MXMLPRS0",31,0)
 S TXT=""
"RTN","MXMLPRS0",32,0)
 F  S CHR=$E(XML,CPOS) Q:"<"[CHR!EOD  D
"RTN","MXMLPRS0",33,0)
 .I $$NEXT("&") S TXT=TXT_$$ENTITY
"RTN","MXMLPRS0",34,0)
 .E  S TXT=TXT_CHR,CPOS=CPOS+1
"RTN","MXMLPRS0",35,0)
 S:CHR="<" ST=3
"RTN","MXMLPRS0",36,0)
 I $L(TXT) D
"RTN","MXMLPRS0",37,0)
 .I 'LVL D ERROR(6) Q
"RTN","MXMLPRS0",38,0)
 .I '$$ISCHILD(LVL(LVL),"#PCDATA",1) D:$L($TR(TXT,WS)) ERROR(27) Q
"RTN","MXMLPRS0",39,0)
 .D CBK("CHARACTERS",TXT)
"RTN","MXMLPRS0",40,0)
 Q
"RTN","MXMLPRS0",41,0)
 ; State 3: Markup text
"RTN","MXMLPRS0",42,0)
3 N END,ENAME,ATTR
"RTN","MXMLPRS0",43,0)
 S ST=2
"RTN","MXMLPRS0",44,0)
 Q:$$COMMENT
"RTN","MXMLPRS0",45,0)
 Q:$$CDATA
"RTN","MXMLPRS0",46,0)
 Q:$$PI
"RTN","MXMLPRS0",47,0)
 Q:'$$NEXT("<",3)
"RTN","MXMLPRS0",48,0)
 S END=$$NEXT("/"),ENAME=$$NAME(2)
"RTN","MXMLPRS0",49,0)
 Q:'$L(ENAME)
"RTN","MXMLPRS0",50,0)
 I 'END D
"RTN","MXMLPRS0",51,0)
 .S:LVL LVL(LVL,"N")=$$ISCHILD(LVL(LVL),ENAME,LVL(LVL,"N"))
"RTN","MXMLPRS0",52,0)
 .D:'LVL(LVL,"N") ERROR(24,ENAME)
"RTN","MXMLPRS0",53,0)
 .D ATTRIBS(ENAME,.ATTR),CBK("STARTELEMENT",ENAME,.ATTR),WS()
"RTN","MXMLPRS0",54,0)
 .D READ ;*89 Check for more data
"RTN","MXMLPRS0",55,0)
 .S END=$$NEXT("/"),LVL=LVL+1
"RTN","MXMLPRS0",56,0)
 .M LVL(LVL)=ERR
"RTN","MXMLPRS0",57,0)
 .S LVL(LVL)=ENAME,LVL(LVL,"N")=1
"RTN","MXMLPRS0",58,0)
 .I LVL=1 D
"RTN","MXMLPRS0",59,0)
 ..I $D(LVL(0))#2,LVL(0)'=ENAME D ERROR(15,ENAME) Q
"RTN","MXMLPRS0",60,0)
 ..I '$D(LVL(-1)) S LVL(-1)=""
"RTN","MXMLPRS0",61,0)
 ..E  D ERROR(45,ENAME)
"RTN","MXMLPRS0",62,0)
 I END D
"RTN","MXMLPRS0",63,0)
 .I LVL>0,$G(LVL(LVL))=ENAME D
"RTN","MXMLPRS0",64,0)
 ..D:'$$ISCHILD(ENAME,"*",LVL(LVL,"N")) ERROR(25)
"RTN","MXMLPRS0",65,0)
 ..D CBK("ENDELEMENT",ENAME)
"RTN","MXMLPRS0",66,0)
 ..K LVL(LVL)
"RTN","MXMLPRS0",67,0)
 ..S LVL=LVL-1
"RTN","MXMLPRS0",68,0)
 .E  D ERROR(5,ENAME)
"RTN","MXMLPRS0",69,0)
 I $$NEXT(">",3)
"RTN","MXMLPRS0",70,0)
 Q
"RTN","MXMLPRS0",71,0)
 ; State 5: Internal or external DTD
"RTN","MXMLPRS0",72,0)
5 N X,Y
"RTN","MXMLPRS0",73,0)
 D DOPARAM
"RTN","MXMLPRS0",74,0)
 Q:$$COMMENT
"RTN","MXMLPRS0",75,0)
 I CS,$$NEXT("]]>") S CS=CS-1 Q
"RTN","MXMLPRS0",76,0)
 I $$NEXT("]") D  Q
"RTN","MXMLPRS0",77,0)
 .S ST=6
"RTN","MXMLPRS0",78,0)
 .D WS()
"RTN","MXMLPRS0",79,0)
 .I $$NEXT(">",3)
"RTN","MXMLPRS0",80,0)
 Q:'$$NEXT("<!",3)
"RTN","MXMLPRS0",81,0)
 S X=$S($$NEXT("["):"[",1:$$NAME(2))
"RTN","MXMLPRS0",82,0)
 Q:'$L(X)
"RTN","MXMLPRS0",83,0)
 I $G(DTD(X)) S ST=$$WS(X'="["),ST=DTD(X)
"RTN","MXMLPRS0",84,0)
 E  D ERROR(16,X)
"RTN","MXMLPRS0",85,0)
 Q
"RTN","MXMLPRS0",86,0)
 ; State 6: Check for external DTD
"RTN","MXMLPRS0",87,0)
6 S ST=2
"RTN","MXMLPRS0",88,0)
 Q:OPTION'["V"
"RTN","MXMLPRS0",89,0)
 I $G(DTD)'="" D  Q
"RTN","MXMLPRS0",90,0)
 .D OPNDOC(DTD,,"]>"),0
"RTN","MXMLPRS0",91,0)
 .S ST=5,DTD=""
"RTN","MXMLPRS0",92,0)
 D:CS ERROR(42)
"RTN","MXMLPRS0",93,0)
 Q
"RTN","MXMLPRS0",94,0)
 ; State 8: End of DTD declaration
"RTN","MXMLPRS0",95,0)
8 D WS()
"RTN","MXMLPRS0",96,0)
 I $$NEXT(">",3)
"RTN","MXMLPRS0",97,0)
 S ST=5
"RTN","MXMLPRS0",98,0)
 Q
"RTN","MXMLPRS0",99,0)
 ; State 20: DTD ENTITY declaration
"RTN","MXMLPRS0",100,0)
20 N SYS,PUB,ENAME,TYP,DUP,Z
"RTN","MXMLPRS0",101,0)
 I $$NEXT("%"),$$WS(1) S TYP=2
"RTN","MXMLPRS0",102,0)
 E  S TYP=1
"RTN","MXMLPRS0",103,0)
 S ENAME=$$NAME(2)
"RTN","MXMLPRS0",104,0)
 Q:'$L(ENAME)
"RTN","MXMLPRS0",105,0)
 S ST=8,ENAME=$S(TYP=2:"%",1:"")_ENAME,DUP=$D(^TMP(ID,$J,"ENT",ENAME))
"RTN","MXMLPRS0",106,0)
 D NOFWD("UNP",ENAME),ERROR(18,ENAME):DUP,WS(1)
"RTN","MXMLPRS0",107,0)
 I $$SYSPUB(.SYS,.PUB) D
"RTN","MXMLPRS0",108,0)
 .D WS()
"RTN","MXMLPRS0",109,0)
 .I TYP=1,$$NEXT("NDATA") D
"RTN","MXMLPRS0",110,0)
 ..D WS(1)
"RTN","MXMLPRS0",111,0)
 ..S Z=$$NAME(2)
"RTN","MXMLPRS0",112,0)
 ..Q:'$L(Z)
"RTN","MXMLPRS0",113,0)
 ..D FWD("NOT",Z)
"RTN","MXMLPRS0",114,0)
 ..S:'DUP ^TMP(ID,$J,"ENT",ENAME)="",^TMP(ID,$J,"UNP",ENAME)=Z
"RTN","MXMLPRS0",115,0)
 .E  D:'DUP
"RTN","MXMLPRS0",116,0)
 ..S Z=$$EXTRNL(SYS,PUB)
"RTN","MXMLPRS0",117,0)
 ..S:$L(Z) ^TMP(ID,$J,"ENT",ENAME)=Z
"RTN","MXMLPRS0",118,0)
 E  D
"RTN","MXMLPRS0",119,0)
 .S Z=$$VALUE(1,TYP)
"RTN","MXMLPRS0",120,0)
 .D:'DUP SETENT(ENAME,Z)
"RTN","MXMLPRS0",121,0)
 Q
"RTN","MXMLPRS0",122,0)
 ; State 30: DTD ELEMENT declaration
"RTN","MXMLPRS0",123,0)
 ; Builds a parse tree for child elements
"RTN","MXMLPRS0",124,0)
30 N STK,ELEMENT,CHILD,START,END,MIXED,X,Z
"RTN","MXMLPRS0",125,0)
 D DOPARAM
"RTN","MXMLPRS0",126,0)
 S ELEMENT=$$NAME(2),ST=8
"RTN","MXMLPRS0",127,0)
 Q:'$L(ELEMENT)
"RTN","MXMLPRS0",128,0)
 Q:'$$WS(1)
"RTN","MXMLPRS0",129,0)
 I $D(^TMP(ID,$J,"ELE",ELEMENT)) D ERROR(20,ELEMENT) Q
"RTN","MXMLPRS0",130,0)
 D NOFWD("ELE",ELEMENT)
"RTN","MXMLPRS0",131,0)
 S Z=$S($$NEXT("EMPTY"):1,$$NEXT("ANY"):2,1:0),^TMP(ID,$J,"ELE",ELEMENT)=Z
"RTN","MXMLPRS0",132,0)
 Q:Z
"RTN","MXMLPRS0",133,0)
 S STK=0,MIXED=0,START=1,END=2
"RTN","MXMLPRS0",134,0)
 ; Check for opening parenthesis
"RTN","MXMLPRS0",135,0)
LPAREN D DOPARAM
"RTN","MXMLPRS0",136,0)
 I MIXED<2 D
"RTN","MXMLPRS0",137,0)
 .F  D WS() Q:'$$NEXT("(",$S(STK:0,1:3))  S STK(STK)=START,STK=STK+1
"RTN","MXMLPRS0",138,0)
 ; Element name, parameter entity, or #PCDATA
"RTN","MXMLPRS0",139,0)
 D DOPARAM
"RTN","MXMLPRS0",140,0)
 I 'MIXED,$$NEXT("#PCDATA") S CHILD="#PCDATA",MIXED=2
"RTN","MXMLPRS0",141,0)
 E  S CHILD=$$NAME(2),MIXED=$S('MIXED:1,MIXED=2:3,1:MIXED) Q:'$L(CHILD)  D FWD("ELE",CHILD)
"RTN","MXMLPRS0",142,0)
 I $D(STK(-1,CHILD)) D ERROR(23,CHILD) Q
"RTN","MXMLPRS0",143,0)
 S STK(-1,CHILD)="",^TMP(ID,$J,"ELE",ELEMENT,START,CHILD)=END
"RTN","MXMLPRS0",144,0)
 S:CHILD="#PCDATA" ^(END)=""
"RTN","MXMLPRS0",145,0)
 G:MIXED>1 SEQOPR
"RTN","MXMLPRS0",146,0)
 ; Check for repetition modifier
"RTN","MXMLPRS0",147,0)
REPMOD S X=$S($$NEXT("*",$S(MIXED=3:3,1:0)):2,MIXED>1:0,$$NEXT("+"):1,$$NEXT("?"):3,1:0)
"RTN","MXMLPRS0",148,0)
 S:X=1 ^TMP(ID,$J,"ELE",ELEMENT,END,START)=""
"RTN","MXMLPRS0",149,0)
 S:X=2 ^TMP(ID,$J,"ELE",ELEMENT,END,START)="",^TMP(ID,$J,"ELE",ELEMENT,START,END)=""
"RTN","MXMLPRS0",150,0)
 S:X=3 ^TMP(ID,$J,"ELE",ELEMENT,START,END)=""
"RTN","MXMLPRS0",151,0)
 ; Check for sequence operator
"RTN","MXMLPRS0",152,0)
SEQOPR D WS()
"RTN","MXMLPRS0",153,0)
 S X=$S($$NEXT("|"):2,MIXED=2:0,$$NEXT(","):1,1:0)
"RTN","MXMLPRS0",154,0)
 I X D  G LPAREN
"RTN","MXMLPRS0",155,0)
 .S:'$D(STK(STK,0)) STK(STK,0)=X
"RTN","MXMLPRS0",156,0)
 .D:STK(STK,0)'=X ERROR(22,$E(",|",X))
"RTN","MXMLPRS0",157,0)
 .S:X=1 START=END,END=END+1
"RTN","MXMLPRS0",158,0)
 D WS()
"RTN","MXMLPRS0",159,0)
 I '$$NEXT(")",$S(STK:3,1:0)) D  Q
"RTN","MXMLPRS0",160,0)
 .S ^TMP(ID,$J,"ELE",ELEMENT,END,"*")=-1
"RTN","MXMLPRS0",161,0)
 I 'STK D ERROR(21) Q
"RTN","MXMLPRS0",162,0)
 K STK(STK)
"RTN","MXMLPRS0",163,0)
 S STK=STK-1,START=STK(STK)
"RTN","MXMLPRS0",164,0)
 G REPMOD
"RTN","MXMLPRS0",165,0)
 ; State 40: DTD ATTLIST declaration
"RTN","MXMLPRS0",166,0)
40 N ELEMENT,ATTRIB,TYPE,DFLT,DUP,X,Y
"RTN","MXMLPRS0",167,0)
 D DOPARAM
"RTN","MXMLPRS0",168,0)
 S ELEMENT=$$NAME(2)
"RTN","MXMLPRS0",169,0)
 Q:'$L(ELEMENT)
"RTN","MXMLPRS0",170,0)
 Q:'$$WS(1)
"RTN","MXMLPRS0",171,0)
 D FWD("ELE",ELEMENT)
"RTN","MXMLPRS0",172,0)
 ; Attribute name
"RTN","MXMLPRS0",173,0)
ATTNAME D DOPARAM
"RTN","MXMLPRS0",174,0)
 S ATTRIB=$$NAME(2)
"RTN","MXMLPRS0",175,0)
 Q:'$L(ATTRIB)
"RTN","MXMLPRS0",176,0)
 S DUP=$D(^TMP(ID,$J,"ATT",ELEMENT,ATTRIB))
"RTN","MXMLPRS0",177,0)
 D ERROR(4,ATTRIB):DUP,WS(1)
"RTN","MXMLPRS0",178,0)
 ; Attribute type
"RTN","MXMLPRS0",179,0)
 S TYPE=$$FNDTKN("TYP")
"RTN","MXMLPRS0",180,0)
 I 'TYPE D ERROR(33) Q
"RTN","MXMLPRS0",181,0)
 S:'DUP ^TMP(ID,$J,"ATT",ELEMENT,ATTRIB)=TYPE
"RTN","MXMLPRS0",182,0)
 D WS(TYPE'=1),NOTN:TYPE=8,ENUM:TYPE=1,WS()
"RTN","MXMLPRS0",183,0)
 ; Default modifier
"RTN","MXMLPRS0",184,0)
 S DFLT=$$FNDTKN("MOD")
"RTN","MXMLPRS0",185,0)
 S:'DUP $P(^TMP(ID,$J,"ATT",ELEMENT,ATTRIB),"^",2)=DFLT,Y=$G(^("#ID"))
"RTN","MXMLPRS0",186,0)
 I TYPE=5 D                                                            ; If ID type
"RTN","MXMLPRS0",187,0)
 .D:DFLT=3 ERROR(34)
"RTN","MXMLPRS0",188,0)
 .I '$L(Y) S:'DUP ^TMP(ID,$J,"ATT",ELEMENT,"#ID")=ATTRIB
"RTN","MXMLPRS0",189,0)
 .E  D ERROR(35,Y)
"RTN","MXMLPRS0",190,0)
 ; Default value
"RTN","MXMLPRS0",191,0)
 I DFLT=3!'DFLT D
"RTN","MXMLPRS0",192,0)
 .D:DFLT WS(1)
"RTN","MXMLPRS0",193,0)
 .S X=$$VALUE(1)
"RTN","MXMLPRS0",194,0)
 .Q:DUP
"RTN","MXMLPRS0",195,0)
 .S $P(^TMP(ID,$J,"ATT",ELEMENT,ATTRIB),"^",3)=X
"RTN","MXMLPRS0",196,0)
 .D CHKVAL(ELEMENT,ATTRIB,X)
"RTN","MXMLPRS0",197,0)
 ; Next attribute or end of declaration
"RTN","MXMLPRS0",198,0)
 D WS()
"RTN","MXMLPRS0",199,0)
 G:'$$NEXT(">") ATTNAME
"RTN","MXMLPRS0",200,0)
 S ST=5
"RTN","MXMLPRS0",201,0)
 Q
"RTN","MXMLPRS0",202,0)
 ; Search for a token of the specified group
"RTN","MXMLPRS0",203,0)
 ; GRP=Group id
"RTN","MXMLPRS0",204,0)
 ; Returns token id within group or 0 if none found
"RTN","MXMLPRS0",205,0)
FNDTKN(GRP) ;
"RTN","MXMLPRS0",206,0)
 N TKN
"RTN","MXMLPRS0",207,0)
 S TKN=""
"RTN","MXMLPRS0",208,0)
 F  S TKN=$O(^TMP(ID,$J,GRP,TKN),-1) Q:$$NEXT(TKN)
"RTN","MXMLPRS0",209,0)
 Q $S($L(TKN):^TMP(ID,$J,GRP,TKN),1:0)
"RTN","MXMLPRS0",210,0)
 ; Enumerated attribute type
"RTN","MXMLPRS0",211,0)
ENUM F  D WS() S X=$$NAMETKN(3) Q:'$L(X)  D  Q:'$$NEXT("|")
"RTN","MXMLPRS0",212,0)
 .D:TYPE=8 FWD("NOT",X)
"RTN","MXMLPRS0",213,0)
 .S ^TMP(ID,$J,"ATT",ELEMENT,ATTRIB,X)=""
"RTN","MXMLPRS0",214,0)
 .D WS()
"RTN","MXMLPRS0",215,0)
 I $$NEXT(")",3)
"RTN","MXMLPRS0",216,0)
 Q
"RTN","MXMLPRS0",217,0)
 ; NOTATION attribute type
"RTN","MXMLPRS0",218,0)
NOTN D ENUM:$$NEXT("(",3)
"RTN","MXMLPRS0",219,0)
 Q
"RTN","MXMLPRS0",220,0)
 ; State 50: DTD NOTATION declaration
"RTN","MXMLPRS0",221,0)
50 N NAME,SYS,PUB,DUP
"RTN","MXMLPRS0",222,0)
 S NAME=$$NAME(3),ST=8
"RTN","MXMLPRS0",223,0)
 Q:'$L(NAME)
"RTN","MXMLPRS0",224,0)
 Q:'$$WS(1)
"RTN","MXMLPRS0",225,0)
 S DUP=$D(^TMP(ID,$J,"NOT",NAME))
"RTN","MXMLPRS0",226,0)
 D NOFWD("NOT",NAME),ERROR(48,NAME):DUP
"RTN","MXMLPRS0",227,0)
 I '$$SYSPUB(.SYS,.PUB,1) D ERROR(39) Q
"RTN","MXMLPRS0",228,0)
 Q:DUP
"RTN","MXMLPRS0",229,0)
 S ^TMP(ID,$J,"NOT",NAME,1)=SYS,^(2)=PUB
"RTN","MXMLPRS0",230,0)
 D CBK("NOTATION",NAME,SYS,PUB)
"RTN","MXMLPRS0",231,0)
 Q
"RTN","MXMLPRS0",232,0)
 ; State 60: Conditional sections
"RTN","MXMLPRS0",233,0)
60 N CSTYPE,CSCNT,DLM
"RTN","MXMLPRS0",234,0)
 D DOPARAM
"RTN","MXMLPRS0",235,0)
 S CSTYPE=$S($$NEXT("INCLUDE"):1,$$NEXT("IGNORE"):2,1:0),ST=5
"RTN","MXMLPRS0",236,0)
 I 'CSTYPE D ERROR(41) Q
"RTN","MXMLPRS0",237,0)
 I DOCSTK=1 D ERROR(44) Q
"RTN","MXMLPRS0",238,0)
 D WS()
"RTN","MXMLPRS0",239,0)
 Q:'$$NEXT("[",3)
"RTN","MXMLPRS0",240,0)
 I CSTYPE=1 S CS=CS+1 Q
"RTN","MXMLPRS0",241,0)
 S CSCNT=1,DLM=""
"RTN","MXMLPRS0",242,0)
 F  D  Q:'CSCNT!EOD
"RTN","MXMLPRS0",243,0)
 .I $L(DLM),$$NEXT(DLM) S DLM=""
"RTN","MXMLPRS0",244,0)
 .E  I $L(DLM) S CPOS=CPOS+1
"RTN","MXMLPRS0",245,0)
 .E  I $$NEXT(QT) S DLM=QT
"RTN","MXMLPRS0",246,0)
 .E  I $$NEXT("'") S DLM="'"
"RTN","MXMLPRS0",247,0)
 .E  I $$NEXT("<![") S CSCNT=CSCNT+1
"RTN","MXMLPRS0",248,0)
 .E  I $$NEXT("]]>") S CSCNT=CSCNT-1
"RTN","MXMLPRS0",249,0)
 .E  S CPOS=CPOS+1
"RTN","MXMLPRS0",250,0)
 .D:CPOS>LLEN READ
"RTN","MXMLPRS0",251,0)
 D:CSCNT ERROR(42)
"RTN","MXMLPRS0",252,0)
 Q
"RTN","MXMLPRS0",253,0)
 ;Local Functions moved from MXMLPRSE
"RTN","MXMLPRS0",254,0)
 ; Execute event callback (if defined)
"RTN","MXMLPRS0",255,0)
 ; EVT=Event name
"RTN","MXMLPRS0",256,0)
 ; Pn=Parameters
"RTN","MXMLPRS0",257,0)
CBK(EVT,P1,P2,P3,P4) ;
"RTN","MXMLPRS0",258,0)
 Q:EOD<0
"RTN","MXMLPRS0",259,0)
 N EN,PNUM
"RTN","MXMLPRS0",260,0)
 S EN=$G(CBK(EVT))
"RTN","MXMLPRS0",261,0)
 Q:EN=""
"RTN","MXMLPRS0",262,0)
 S PNUM=^TMP(ID,$J,"CBK",EVT)
"RTN","MXMLPRS0",263,0)
 D @(EN_$P("(.P1,.P2,.P3,.P4",",",1,PNUM)_$S('PNUM:"",1:")"))
"RTN","MXMLPRS0",264,0)
 Q
"RTN","MXMLPRS0",265,0)
 ; Save current document location for error reporting
"RTN","MXMLPRS0",266,0)
 ; See EPOS^MXMLPRSE
"RTN","MXMLPRS0",267,0)
EPOS S ERR("XML")=XML,ERR("POS")=CPOS,ERR("LIN")=LPOS
"RTN","MXMLPRS0",268,0)
 Q
"RTN","MXMLPRS0",269,0)
 ; Check next characters
"RTN","MXMLPRS0",270,0)
 ; SEQ=character sequence
"RTN","MXMLPRS0",271,0)
 ; ERN=Error to signal if not found (optional)
"RTN","MXMLPRS0",272,0)
NEXT(SEQ,ERN) ;
"RTN","MXMLPRS0",273,0)
 I SEQ=$E(XML,CPOS,CPOS+$L(SEQ)-1) S CPOS=CPOS+$L(SEQ) Q 1
"RTN","MXMLPRS0",274,0)
 D:$G(ERN) EPOS^MXMLPRSE,ERROR(ERN,SEQ)
"RTN","MXMLPRS0",275,0)
 Q 0
"RTN","MXMLPRS0",276,0)
 ; Skip whitespace
"RTN","MXMLPRS0",277,0)
 ; ERN=Error to signal if not found (optional)
"RTN","MXMLPRS0",278,0)
 ; Optional return value =1 if whitespace found, 0 if not.
"RTN","MXMLPRS0",279,0)
WS(ERN) N CHR,FND
"RTN","MXMLPRS0",280,0)
 D EPOS^MXMLPRSE
"RTN","MXMLPRS0",281,0)
 S FND=0
"RTN","MXMLPRS0",282,0)
 F  D:CPOS>LLEN READ S CHR=$E(XML,CPOS) Q:WS'[CHR!EOD  D
"RTN","MXMLPRS0",283,0)
 .S ERN=0,CPOS=CPOS+1,FND=1
"RTN","MXMLPRS0",284,0)
 D:$G(ERN) ERROR(ERN)
"RTN","MXMLPRS0",285,0)
 Q:$Q FND
"RTN","MXMLPRS0",286,0)
 Q
"RTN","MXMLPRS0",287,0)
 ; Shortcuts to functions/procedures defined elsewhere
"RTN","MXMLPRS0",288,0)
ATTRIBS(X,Y) D ATTRIBS^MXMLPRSE(.X,.Y) Q
"RTN","MXMLPRS0",289,0)
CDATA() Q $$CDATA^MXMLPRSE
"RTN","MXMLPRS0",290,0)
CHKVAL(X,Y,Z) D CHKVAL^MXMLPRS1(.X,.Y,.Z) Q
"RTN","MXMLPRS0",291,0)
COMMENT() Q $$COMMENT^MXMLPRSE
"RTN","MXMLPRS0",292,0)
DOPARAM G DOPARAM^MXMLPRSE
"RTN","MXMLPRS0",293,0)
ENTITY(X) Q $$ENTITY^MXMLPRSE(.X)
"RTN","MXMLPRS0",294,0)
ERROR(X,Y) D ERROR^MXMLPRSE(.X,.Y) Q
"RTN","MXMLPRS0",295,0)
EXTRNL(X,Y,Z) Q $$EXTRNL^MXMLPRSE(.X,.Y,.Z)
"RTN","MXMLPRS0",296,0)
FWD(X,Y) D FWD^MXMLPRS1(.X,.Y) Q
"RTN","MXMLPRS0",297,0)
ISCHILD(X,Y,Z) Q $$ISCHILD^MXMLPRS1(.X,.Y,.Z)
"RTN","MXMLPRS0",298,0)
NAME(X) Q $$NAME^MXMLPRSE(.X)
"RTN","MXMLPRS0",299,0)
NAMETKN(X) Q $$NAMETKN^MXMLPRSE(.X)
"RTN","MXMLPRS0",300,0)
NOFWD(X,Y) D NOFWD^MXMLPRS1(.X,.Y) Q
"RTN","MXMLPRS0",301,0)
OPNDOC(X,Y,Z) D OPNDOC^MXMLPRSE(.X,.Y,.Z) Q
"RTN","MXMLPRS0",302,0)
PI() Q $$PI^MXMLPRSE
"RTN","MXMLPRS0",303,0)
SETENT(X,Y) D SETENT^MXMLPRSE(.X,.Y) Q
"RTN","MXMLPRS0",304,0)
SYSPUB(X,Y,Z) Q:$Q $$SYSPUB^MXMLPRSE(.X,.Y,.Z)
"RTN","MXMLPRS0",305,0)
 D SYSPUB^MXMLPRSE(.X,.Y) Q
"RTN","MXMLPRS0",306,0)
READ G READ^MXMLPRSE
"RTN","MXMLPRS0",307,0)
VALUE(X,Y) Q $$VALUE^MXMLPRSE(.X,.Y)
"RTN","MXMLPRS1")
0^2^B16288937
"RTN","MXMLPRS1",1,0)
MXMLPRS1 ;SAIC/DKM - XML Parser ;12/04/2002  15:55
"RTN","MXMLPRS1",2,0)
 ;;2.1;XML PROCESSING UTILITIES;;Nov 27, 2013;Build 9
"RTN","MXMLPRS1",3,0)
 ;=================================================================
"RTN","MXMLPRS1",4,0)
 ; Initialize tables
"RTN","MXMLPRS1",5,0)
INIT N X,Y,Z
"RTN","MXMLPRS1",6,0)
 F X=0:1 S Y=$P($T(ENTITIES+X),";;",2,99) Q:'$L(Y)  D
"RTN","MXMLPRS1",7,0)
 .D SETENT^MXMLPRSE($P(Y,";"),$P(Y,";",2,99))
"RTN","MXMLPRS1",8,0)
 F X=0:1 S Y=$P($T(DTDTAG+X),";;",2,99) Q:'$L(Y)  D
"RTN","MXMLPRS1",9,0)
 .S DTD($P(Y,";"))=$P(Y,";",2)
"RTN","MXMLPRS1",10,0)
 F X=0:1 S Y=$P($T(TYPE+X),";;",2,99) Q:'$L(Y)  D
"RTN","MXMLPRS1",11,0)
 .S ^TMP(ID,$J,"TYP",$P(Y,";",2))=+Y
"RTN","MXMLPRS1",12,0)
 F X=0:1 S Y=$P($T(MOD+X),";;",2,99) Q:'$L(Y)  D
"RTN","MXMLPRS1",13,0)
 .S ^TMP(ID,$J,"MOD",$P(Y,";",2))=+Y
"RTN","MXMLPRS1",14,0)
 F X=0:1 S Y=$P($T(REF+X),";;",2,99) Q:'$L(Y)  D
"RTN","MXMLPRS1",15,0)
 .S ^TMP(ID,$J,"REF",$P(Y,";",2))=+Y
"RTN","MXMLPRS1",16,0)
 F X=0:1 S Y=$P($T(CBKARGS+X),";;",2,99) Q:'$L(Y)  D
"RTN","MXMLPRS1",17,0)
 .S ^TMP(ID,$J,"CBK",$P(Y,";",2))=+Y
"RTN","MXMLPRS1",18,0)
 F X=0:1 S Y=$P($T(PROLOG+X),";;",2,99) Q:'$L(Y)  D
"RTN","MXMLPRS1",19,0)
 .S Z=$P(Y,";"),^TMP(ID,$J,"ATT","?xml",Z)="1^"_$S('X:1,1:2)
"RTN","MXMLPRS1",20,0)
 .F  S Y=$P(Y,";",2,99) Q:'$L(Y)  S ^TMP(ID,$J,"ATT","?xml",Z,$P(Y,";"))=""
"RTN","MXMLPRS1",21,0)
 Q
"RTN","MXMLPRS1",22,0)
 ; Search parse tree for child element (CHILD) under parent element
"RTN","MXMLPRS1",23,0)
 ; (ELEMENT) starting at specified node (NODE).
"RTN","MXMLPRS1",24,0)
 ; Returns next node # in parse tree or 0
"RTN","MXMLPRS1",25,0)
 ; If validation is disabled, the function always returns 1.
"RTN","MXMLPRS1",26,0)
 ; If parent element is marked as EMPTY, 0 is returned.
"RTN","MXMLPRS1",27,0)
 ; If parent element is marked as ANY, 1 is returned.
"RTN","MXMLPRS1",28,0)
ISCHILD(ELEMENT,CHILD,NODE) ;
"RTN","MXMLPRS1",29,0)
 N TRN
"RTN","MXMLPRS1",30,0)
 S TRN=+$G(^TMP(ID,$J,"ELE",ELEMENT),2)
"RTN","MXMLPRS1",31,0)
 Q $S(OPTION'["V"!'NODE:1,TRN=1:CHILD="*",TRN=2:1,1:$$IC(NODE))
"RTN","MXMLPRS1",32,0)
IC(NODE) N X,Y
"RTN","MXMLPRS1",33,0)
 S X=+$G(^TMP(ID,$J,"ELE",ELEMENT,NODE,CHILD)),Y=0
"RTN","MXMLPRS1",34,0)
 I 'X D
"RTN","MXMLPRS1",35,0)
 .F  S Y=$O(^TMP(ID,$J,"ELE",ELEMENT,NODE,Y)) Q:'Y  D  Q:X
"RTN","MXMLPRS1",36,0)
 ..S:'$D(TRN(NODE,Y)) TRN(NODE,Y)="",X=$$IC(Y)
"RTN","MXMLPRS1",37,0)
 Q X
"RTN","MXMLPRS1",38,0)
 ; Check attribute value for validity
"RTN","MXMLPRS1",39,0)
CHKVAL(ENAME,ANAME,VALUE) ;
"RTN","MXMLPRS1",40,0)
 N TYPE,X,Y,Z
"RTN","MXMLPRS1",41,0)
 Q:'$L(VALUE)
"RTN","MXMLPRS1",42,0)
 I $D(^TMP(ID,$J,"ATT",ENAME,ANAME))>1 D:'$D(^(ANAME,VALUE)) ERROR(38,VALUE) Q
"RTN","MXMLPRS1",43,0)
 S TYPE=+$G(^TMP(ID,$J,"ATT",ENAME,ANAME))
"RTN","MXMLPRS1",44,0)
 Q:'TYPE
"RTN","MXMLPRS1",45,0)
 I TYPE=5 D  Q                                                         ; ID type
"RTN","MXMLPRS1",46,0)
 .I '$$ISNAME(VALUE) D ERROR(38,VALUE) Q
"RTN","MXMLPRS1",47,0)
 .I '$D(^TMP(ID,$J,"ID",VALUE)) D
"RTN","MXMLPRS1",48,0)
 ..S ^(VALUE)=""
"RTN","MXMLPRS1",49,0)
 ..D NOFWD("ID",VALUE)
"RTN","MXMLPRS1",50,0)
 .E  D ERROR(28,VALUE)
"RTN","MXMLPRS1",51,0)
 I TYPE=9!(TYPE=10) D  Q                                               ; ENTITY/ENTITIES type
"RTN","MXMLPRS1",52,0)
 .S X=$S(TYPE=9:"  ",1:" ")
"RTN","MXMLPRS1",53,0)
 .F Z=1:1:$L(VALUE,X) D FWD("UNP",$P(VALUE,X,Z))
"RTN","MXMLPRS1",54,0)
 I TYPE=3!(TYPE=4) D  Q                                                ; NMTOKEN/NMTOKENS type
"RTN","MXMLPRS1",55,0)
 .S X=$S(TYPE=3:"  ",1:" ")
"RTN","MXMLPRS1",56,0)
 .F Z=1:1:$L(VALUE,X) D
"RTN","MXMLPRS1",57,0)
 ..S Y=$P(VALUE,X,Z)
"RTN","MXMLPRS1",58,0)
 ..D:'$$ISNMTKN(Y) ERROR(38,Y)
"RTN","MXMLPRS1",59,0)
 I TYPE=6!(TYPE=7) D  Q                                                ; IDREF/IDREFS type
"RTN","MXMLPRS1",60,0)
 .S X=$S(TYPE=6:"  ",1:" ")
"RTN","MXMLPRS1",61,0)
 .F Z=1:1:$L(VALUE,X) D
"RTN","MXMLPRS1",62,0)
 ..S Y=$P(VALUE,X,Z)
"RTN","MXMLPRS1",63,0)
 ..I '$$ISNAME(Y) D ERROR(38,Y) Q
"RTN","MXMLPRS1",64,0)
 ..D FWD("ID",Y)
"RTN","MXMLPRS1",65,0)
 Q
"RTN","MXMLPRS1",66,0)
 ; Return true if valid name
"RTN","MXMLPRS1",67,0)
ISNAME(VALUE) ;
"RTN","MXMLPRS1",68,0)
 Q VALUE?1(1A,1"_",1":").(1AN,1".",1"-",1"_",1":")
"RTN","MXMLPRS1",69,0)
 ; Return true if valid name token
"RTN","MXMLPRS1",70,0)
ISNMTKN(VALUE) ;
"RTN","MXMLPRS1",71,0)
 Q VALUE?1.(1AN,1".",1"-",1"_",1":")
"RTN","MXMLPRS1",72,0)
 ; Log a forward reference
"RTN","MXMLPRS1",73,0)
FWD(TYPE,VALUE) ;
"RTN","MXMLPRS1",74,0)
 Q:'$L(VALUE)
"RTN","MXMLPRS1",75,0)
 Q:$D(^TMP(ID,$J,TYPE,VALUE))
"RTN","MXMLPRS1",76,0)
 N Z
"RTN","MXMLPRS1",77,0)
 S Z=$O(^TMP(ID,$J,"REF",TYPE,VALUE,""),-1)+1
"RTN","MXMLPRS1",78,0)
 M ^(Z)=ERR
"RTN","MXMLPRS1",79,0)
 Q
"RTN","MXMLPRS1",80,0)
 ; Resolve forward reference
"RTN","MXMLPRS1",81,0)
NOFWD(TYPE,VALUE) ;
"RTN","MXMLPRS1",82,0)
 K ^TMP(ID,$J,"REF",TYPE,VALUE)
"RTN","MXMLPRS1",83,0)
 Q
"RTN","MXMLPRS1",84,0)
 ; Signal unresolved references
"RTN","MXMLPRS1",85,0)
UNRESLV N X,Y,Z,E
"RTN","MXMLPRS1",86,0)
 F X=1:1:LVL D
"RTN","MXMLPRS1",87,0)
 .K ERR
"RTN","MXMLPRS1",88,0)
 .M ERR=LVL(X)
"RTN","MXMLPRS1",89,0)
 .D ERROR(8,LVL(X))
"RTN","MXMLPRS1",90,0)
 S X=""
"RTN","MXMLPRS1",91,0)
 F  S X=$O(^TMP(ID,$J,"REF",X)),Y="" Q:'$L(X)  D                           ; Look for IDREF w/o corresponding ID value
"RTN","MXMLPRS1",92,0)
 .S E=^(X)
"RTN","MXMLPRS1",93,0)
 .F  S Y=$O(^TMP(ID,$J,"REF",X,Y)),Z=0 Q:'$L(Y)  D
"RTN","MXMLPRS1",94,0)
 ..F  S Z=$O(^TMP(ID,$J,"REF",X,Y,Z)) Q:'Z  D
"RTN","MXMLPRS1",95,0)
 ...K ERR
"RTN","MXMLPRS1",96,0)
 ...M ERR=^(Z)
"RTN","MXMLPRS1",97,0)
 ...D ERROR(E,Y)
"RTN","MXMLPRS1",98,0)
 Q
"RTN","MXMLPRS1",99,0)
 ; Log error
"RTN","MXMLPRS1",100,0)
ERROR(X,Y) D ERROR^MXMLPRSE(.X,.Y) Q
"RTN","MXMLPRS1",101,0)
 ; Predefined general entities
"RTN","MXMLPRS1",102,0)
 ; Format=entity name;entity value
"RTN","MXMLPRS1",103,0)
ENTITIES ;;amp;&#38;
"RTN","MXMLPRS1",104,0)
 ;;lt;&#60;
"RTN","MXMLPRS1",105,0)
 ;;gt;>
"RTN","MXMLPRS1",106,0)
 ;;quot;&#34;
"RTN","MXMLPRS1",107,0)
 ;;apos;'
"RTN","MXMLPRS1",108,0)
 ;;
"RTN","MXMLPRS1",109,0)
 ; Callback events
"RTN","MXMLPRS1",110,0)
 ; Format=#args;event type
"RTN","MXMLPRS1",111,0)
CBKARGS ;;0;STARTDOCUMENT
"RTN","MXMLPRS1",112,0)
 ;;0;ENDDOCUMENT
"RTN","MXMLPRS1",113,0)
 ;;3;DOCTYPE
"RTN","MXMLPRS1",114,0)
 ;;1;CHARACTERS
"RTN","MXMLPRS1",115,0)
 ;;2;STARTELEMENT
"RTN","MXMLPRS1",116,0)
 ;;1;ENDELEMENT
"RTN","MXMLPRS1",117,0)
 ;;3;NOTATION
"RTN","MXMLPRS1",118,0)
 ;;2;PI
"RTN","MXMLPRS1",119,0)
 ;;1;COMMENT
"RTN","MXMLPRS1",120,0)
 ;;3;EXTERNAL
"RTN","MXMLPRS1",121,0)
 ;;1;ERROR
"RTN","MXMLPRS1",122,0)
 ;;
"RTN","MXMLPRS1",123,0)
 ; Prolog attributes
"RTN","MXMLPRS1",124,0)
 ; Format=attribute name;val1;val2;...;valn
"RTN","MXMLPRS1",125,0)
PROLOG ;;version;1.0
"RTN","MXMLPRS1",126,0)
 ;;encoding;UTF-8;utf-8
"RTN","MXMLPRS1",127,0)
 ;;standalone;no;yes
"RTN","MXMLPRS1",128,0)
 ;;
"RTN","MXMLPRS1",129,0)
 ; Recognized DTD tags
"RTN","MXMLPRS1",130,0)
 ; Format=tag name;state
"RTN","MXMLPRS1",131,0)
DTDTAG ;;ENTITY;20
"RTN","MXMLPRS1",132,0)
 ;;ELEMENT;30
"RTN","MXMLPRS1",133,0)
 ;;ATTLIST;40
"RTN","MXMLPRS1",134,0)
 ;;NOTATION;50
"RTN","MXMLPRS1",135,0)
 ;;[;60
"RTN","MXMLPRS1",136,0)
 ;;
"RTN","MXMLPRS1",137,0)
 ; Attribute types
"RTN","MXMLPRS1",138,0)
 ; Format=identifier;type
"RTN","MXMLPRS1",139,0)
TYPE ;;1;(
"RTN","MXMLPRS1",140,0)
 ;;2;CDATA
"RTN","MXMLPRS1",141,0)
 ;;3;NMTOKEN
"RTN","MXMLPRS1",142,0)
 ;;4;NMTOKENS
"RTN","MXMLPRS1",143,0)
 ;;5;ID
"RTN","MXMLPRS1",144,0)
 ;;6;IDREF
"RTN","MXMLPRS1",145,0)
 ;;7;IDREFS
"RTN","MXMLPRS1",146,0)
 ;;8;NOTATION
"RTN","MXMLPRS1",147,0)
 ;;9;ENTITY
"RTN","MXMLPRS1",148,0)
 ;;10;ENTITIES
"RTN","MXMLPRS1",149,0)
 ;;
"RTN","MXMLPRS1",150,0)
 ; Default modifiers
"RTN","MXMLPRS1",151,0)
 ; Format=identifier;modifier
"RTN","MXMLPRS1",152,0)
MOD ;;1;#REQUIRED
"RTN","MXMLPRS1",153,0)
 ;;2;#IMPLIED
"RTN","MXMLPRS1",154,0)
 ;;3;#FIXED
"RTN","MXMLPRS1",155,0)
 ;;
"RTN","MXMLPRS1",156,0)
 ; Forward references
"RTN","MXMLPRS1",157,0)
 ; Format=type;error #;type
"RTN","MXMLPRS1",158,0)
REF ;;49;UNP
"RTN","MXMLPRS1",159,0)
 ;;46;NOT
"RTN","MXMLPRS1",160,0)
 ;;26;ELE
"RTN","MXMLPRS1",161,0)
 ;;47;ID
"RTN","MXMLPRS1",162,0)
 ;;
"RTN","MXMLPRSE")
0^3^B69724072
"RTN","MXMLPRSE",1,0)
MXMLPRSE ;SAIC/DKM - XML Parser ;2013-11-27  2:25 PM
"RTN","MXMLPRSE",2,0)
 ;;2.1;XML PROCESSING UTILITIES;;Nov 27, 2013;Build 9
"RTN","MXMLPRSE",3,0)
 ;=================================================================
"RTN","MXMLPRSE",4,0)
 ; Main entry point.
"RTN","MXMLPRSE",5,0)
 ; DOC = Closed reference to global array containing document
"RTN","MXMLPRSE",6,0)
 ; CBK = Local array containing entry points for callback interface
"RTN","MXMLPRSE",7,0)
 ; OPTION = Option flags; expected values are:
"RTN","MXMLPRSE",8,0)
 ;   D = Debug mode
"RTN","MXMLPRSE",9,0)
 ;   W = Do not report warnings
"RTN","MXMLPRSE",10,0)
 ;   V = Validate (checks only well-formedness by default)
"RTN","MXMLPRSE",11,0)
 ;   0,1 = Terminate on encountering error at specified level
"RTN","MXMLPRSE",12,0)
EN(DOC,CBK,OPTION) ;
"RTN","MXMLPRSE",13,0)
 N WS,ID,QT,EDC,DTD,LVL,CS,DOCSTK,LLEN,LPOS,CPOS,LCUR,ERR,XML,PFX,SFX,EOD,EOG,ST,PATH,OFX
"RTN","MXMLPRSE",14,0)
 S ID=$T(+0),WS=$C(9,10,13,32),QT="""",(DOCSTK,EOG,EOD,LVL,CS,ST,LPOS,LLEN,LCUR)=0,(CPOS,LVL(0,"N"))=1,OPTION=$G(OPTION),(XML,PFX,SFX)="",PATH=$$PATH(DOC)
"RTN","MXMLPRSE",15,0)
 K ^TMP(ID,$J)
"RTN","MXMLPRSE",16,0)
 I $L($T(TOUCH^XUSCLEAN)) D TOUCH^XUSCLEAN ;Set the keepalive node
"RTN","MXMLPRSE",17,0)
 D INIT^MXMLPRS1,EPOS,CBK("STARTDOCUMENT"),OPNDOC(DOC)
"RTN","MXMLPRSE",18,0)
 F  Q:EOD  D READ,EPOS,@ST^MXMLPRS0:'EOD
"RTN","MXMLPRSE",19,0)
 D UNRESLV^MXMLPRS1,ERROR(17):ST'=2,CBK("ENDDOCUMENT")
"RTN","MXMLPRSE",20,0)
 K ^TMP(ID,$J)
"RTN","MXMLPRSE",21,0)
 Q
"RTN","MXMLPRSE",22,0)
 ; Open a document
"RTN","MXMLPRSE",23,0)
 ; Saves state of current document on stack.
"RTN","MXMLPRSE",24,0)
 ; DOCREF=Closed reference to array containing document
"RTN","MXMLPRSE",25,0)
 ; PREFIX=Optional prefix to prepend to document
"RTN","MXMLPRSE",26,0)
 ; SUFFIX=Optional suffix to append to document
"RTN","MXMLPRSE",27,0)
OPNDOC(DOCREF,PREFIX,SUFFIX) ;
"RTN","MXMLPRSE",28,0)
 S:$E(DOCREF)'="^" DOCREF=$$EXTRNL(DOCREF)
"RTN","MXMLPRSE",29,0)
 Q:'$L(DOCREF)
"RTN","MXMLPRSE",30,0)
 D SAVRES(1)
"RTN","MXMLPRSE",31,0)
 S DOC=$NA(@DOCREF)
"RTN","MXMLPRSE",32,0)
 I '$D(^TMP(ID,$J,"DOC",DOC)) S ^(DOC)=""
"RTN","MXMLPRSE",33,0)
 E  D ERROR(43)
"RTN","MXMLPRSE",34,0)
 S (LPOS,LLEN,LCUR)=0,CPOS=1,(OFX,XML)="",PFX=$G(PREFIX),SFX=$G(SUFFIX)
"RTN","MXMLPRSE",35,0)
 S LCUR=DOC,DOC=$E(DOC,1,$L(DOC)-1) ;*rwf
"RTN","MXMLPRSE",36,0)
 Q
"RTN","MXMLPRSE",37,0)
 ; Close current document
"RTN","MXMLPRSE",38,0)
 ; Restores state of previous document from stack.
"RTN","MXMLPRSE",39,0)
CLSDOC K ^TMP(ID,$J,"DOC",DOC_")") ;*rwf
"RTN","MXMLPRSE",40,0)
 D SAVRES(0)
"RTN","MXMLPRSE",41,0)
 Q
"RTN","MXMLPRSE",42,0)
 ; Extract path from filespec
"RTN","MXMLPRSE",43,0)
PATH(DOC) ;
"RTN","MXMLPRSE",44,0)
 N X
"RTN","MXMLPRSE",45,0)
 Q:U[$E(DOC) ""
"RTN","MXMLPRSE",46,0)
 F X="\","/","]",":","" Q:DOC[X
"RTN","MXMLPRSE",47,0)
 Q $P(DOC,X,1,$L(DOC,X)-1)_X
"RTN","MXMLPRSE",48,0)
 ; Save or restore document state
"RTN","MXMLPRSE",49,0)
SAVRES(SAVE) ;
"RTN","MXMLPRSE",50,0)
 N X
"RTN","MXMLPRSE",51,0)
 S:'SAVE DOCSTK=DOCSTK-1,EOD=DOCSTK=0
"RTN","MXMLPRSE",52,0)
 I DOCSTK F X="LLEN","LPOS","CPOS","LCUR","XML","PFX","SFX","OFX","DOC" D
"RTN","MXMLPRSE",53,0)
 .I SAVE S DOCSTK(DOCSTK,X)=@X
"RTN","MXMLPRSE",54,0)
 .E  S @X=DOCSTK(DOCSTK,X)
"RTN","MXMLPRSE",55,0)
 I SAVE S DOCSTK=DOCSTK+1
"RTN","MXMLPRSE",56,0)
 E  K DOCSTK(DOCSTK)
"RTN","MXMLPRSE",57,0)
 Q
"RTN","MXMLPRSE",58,0)
 ; Retrieve text from document
"RTN","MXMLPRSE",59,0)
READ Q:((LLEN-CPOS)>50)!EOD  ;Quit if still have 50 char or EOD
"RTN","MXMLPRSE",60,0)
 I (CPOS'<LLEN)&EOG D CLSDOC S EOG=0 Q  ;At end of text in file
"RTN","MXMLPRSE",61,0)
 N TMP,X
"RTN","MXMLPRSE",62,0)
 D SHIFT Q:$L(XML)>50
"RTN","MXMLPRSE",63,0)
 I EOG!EOD Q  ;Quit at end of document
"RTN","MXMLPRSE",64,0)
 S LPOS=LPOS+1,LCUR=$Q(@LCUR) ;Get next node
"RTN","MXMLPRSE",65,0)
 I LCUR'[DOC S EOG=1 Q  ;At end of global
"RTN","MXMLPRSE",66,0)
 S TMP=@LCUR ;Get next data chunk
"RTN","MXMLPRSE",67,0)
 W:OPTION["D" !,$J(LPOS,3)_":",TMP,!
"RTN","MXMLPRSE",68,0)
 S OFX=OFX_TMP
"RTN","MXMLPRSE",69,0)
 D SHIFT
"RTN","MXMLPRSE",70,0)
 I LLEN<50 G READ
"RTN","MXMLPRSE",71,0)
 Q
"RTN","MXMLPRSE",72,0)
 ;Shift OFX to XML
"RTN","MXMLPRSE",73,0)
SHIFT ;
"RTN","MXMLPRSE",74,0)
 S XML=$E(XML,CPOS,9999),CPOS=1 ;Drop old
"RTN","MXMLPRSE",75,0)
 I $L(PFX) S OFX=XML_OFX,XML=PFX,PFX=""
"RTN","MXMLPRSE",76,0)
 I $L(OFX) S X=511-$L(XML),XML=XML_$E(OFX,1,X),OFX=$E(OFX,X+1,99999)
"RTN","MXMLPRSE",77,0)
 S LLEN=$L(XML)
"RTN","MXMLPRSE",78,0)
 Q
"RTN","MXMLPRSE",79,0)
 ; Parse name
"RTN","MXMLPRSE",80,0)
 ; ERN=Error to signal if invalid (optional)
"RTN","MXMLPRSE",81,0)
NAME(ERN) ;
"RTN","MXMLPRSE",82,0)
 N X
"RTN","MXMLPRSE",83,0)
 D EPOS
"RTN","MXMLPRSE",84,0)
 S X=$E(XML,CPOS)
"RTN","MXMLPRSE",85,0)
 I X'?1A,"_:"'[X D:$G(ERN) ERROR(ERN,X) Q ""
"RTN","MXMLPRSE",86,0)
 Q $$NAMETKN(.ERN)
"RTN","MXMLPRSE",87,0)
 ; Parse name token
"RTN","MXMLPRSE",88,0)
 ; ERN=Error to signal if invalid (optional)
"RTN","MXMLPRSE",89,0)
NAMETKN(ERN) ;
"RTN","MXMLPRSE",90,0)
 N X,Y
"RTN","MXMLPRSE",91,0)
 D EPOS
"RTN","MXMLPRSE",92,0)
 F X=CPOS:1:LLEN+1 S Y=$E(XML,X) I Y'?1AN,".-_:"'[Y Q
"RTN","MXMLPRSE",93,0)
 S Y=$E(XML,CPOS,X-1),CPOS=X
"RTN","MXMLPRSE",94,0)
 I '$L(Y),$G(ERN) D ERROR(ERN,Y)
"RTN","MXMLPRSE",95,0)
 Q Y
"RTN","MXMLPRSE",96,0)
 ; Parse quote-enclosed value
"RTN","MXMLPRSE",97,0)
 ; ERF=If set, signal error if not found
"RTN","MXMLPRSE",98,0)
 ; FLG=Special flag: 0=attribute literal, 1=general entity literal
"RTN","MXMLPRSE",99,0)
 ;     2=parameter entity literal
"RTN","MXMLPRSE",100,0)
 ; Returns value less quotes with normalized whitespace
"RTN","MXMLPRSE",101,0)
VALUE(ERF,FLG) ;
"RTN","MXMLPRSE",102,0)
 N DLM,CHR,RTN,EXC
"RTN","MXMLPRSE",103,0)
 D WS()
"RTN","MXMLPRSE",104,0)
 S DLM=$S($$NEXT(QT):QT,$$NEXT("'"):"'",1:""),RTN="",FLG=+$G(FLG),EXC=$S(FLG=2:"",1:"<")
"RTN","MXMLPRSE",105,0)
 I DLM="" D:$G(ERF) EPOS,ERROR(11) Q RTN
"RTN","MXMLPRSE",106,0)
 F  S CHR=$E(XML,CPOS) Q:DLM=CHR!(EXC[CHR)!EOD  D
"RTN","MXMLPRSE",107,0)
 .I $$NEXT("&#") S RTN=RTN_$$CHENTITY
"RTN","MXMLPRSE",108,0)
 .E  I 'FLG,$$NEXT("&") S RTN=RTN_$$ENTITY
"RTN","MXMLPRSE",109,0)
 .E  S RTN=RTN_CHR,CPOS=CPOS+1
"RTN","MXMLPRSE",110,0)
 .D:((CPOS+10)>LLEN) READ ; VEN/SMH 2.1 - Read ahead for entities!
"RTN","MXMLPRSE",111,0)
 I DLM=CHR S CPOS=CPOS+1
"RTN","MXMLPRSE",112,0)
 E  D EPOS,ERROR($S('$L(CHR):12,EXC[CHR:13,1:12)) Q ""
"RTN","MXMLPRSE",113,0)
 Q $$NMLWS(RTN)
"RTN","MXMLPRSE",114,0)
 ; Normalize whitespace
"RTN","MXMLPRSE",115,0)
 ; Note: used as input transform for Entity Catalog, so can't depend
"RTN","MXMLPRSE",116,0)
 ; on any environment variables.
"RTN","MXMLPRSE",117,0)
 ; TXT=Text to normalize
"RTN","MXMLPRSE",118,0)
 ; Returns text stripped of leading and trailing whitespace and with
"RTN","MXMLPRSE",119,0)
 ; imbedded contiguous whitespace reduced to single space.
"RTN","MXMLPRSE",120,0)
NMLWS(TXT,FG) ;
"RTN","MXMLPRSE",121,0)
 N Z,CRLF
"RTN","MXMLPRSE",122,0)
 S CRLF=$C(13,10)
"RTN","MXMLPRSE",123,0)
 ;Normalize CRLF to one SP first
"RTN","MXMLPRSE",124,0)
 F  S Z=$F(TXT,CRLF) Q:'Z  S TXT=$P(TXT,CRLF,1)_" "_$P(TXT,CRLF,2,999)
"RTN","MXMLPRSE",125,0)
 S TXT=$TR(TXT,$C(9,10,13,32),"    ")
"RTN","MXMLPRSE",126,0)
 ;For CDATA or unk, this is where we should stop
"RTN","MXMLPRSE",127,0)
 Q:'$G(FG) TXT
"RTN","MXMLPRSE",128,0)
 F Z=1:1 Q:$E(TXT,Z)'=" "
"RTN","MXMLPRSE",129,0)
 S TXT=$E(TXT,Z,9999)
"RTN","MXMLPRSE",130,0)
 F Z=$L(TXT):-1 Q:$E(TXT,Z)'=" "
"RTN","MXMLPRSE",131,0)
 S TXT=$E(TXT,1,Z)
"RTN","MXMLPRSE",132,0)
 F Z=1:1:$L(TXT) D:$E(TXT,Z)=" "
"RTN","MXMLPRSE",133,0)
 .F  Q:$E(TXT,Z+1)'=" "  S $E(TXT,Z+1)=""
"RTN","MXMLPRSE",134,0)
 Q TXT
"RTN","MXMLPRSE",135,0)
 ; Process parameter entity if found
"RTN","MXMLPRSE",136,0)
DOPARAM F  D WS() Q:EOD!'$$NEXT("%")  I $$ENTITY(1)
"RTN","MXMLPRSE",137,0)
 Q
"RTN","MXMLPRSE",138,0)
 ; Resolve general/parameter/character entity
"RTN","MXMLPRSE",139,0)
 ; PARAM=1: parameter; PARAM=0: general or character (default)
"RTN","MXMLPRSE",140,0)
ENTITY(PARAM) ;
"RTN","MXMLPRSE",141,0)
 N NAME,APND
"RTN","MXMLPRSE",142,0)
 S PARAM=+$G(PARAM)
"RTN","MXMLPRSE",143,0)
 I CPOS+10>LLEN D READ  ; VEN/SMH v2.1 - Read ahead for Entity if not enough in XML buffer.
"RTN","MXMLPRSE",144,0)
 I 'PARAM,$$NEXT("#") Q $$CHENTITY
"RTN","MXMLPRSE",145,0)
 S NAME=$S(PARAM:"%",1:"")_$$NAME(2)
"RTN","MXMLPRSE",146,0)
 Q:'$$NEXT(";",3) ""
"RTN","MXMLPRSE",147,0)
 ;Handle the common ones inline
"RTN","MXMLPRSE",148,0)
 S APND=$S(NAME="amp":"&",NAME="lt":"<",NAME="gt":">",NAME="quot":$C(34),NAME="apos":"'",1:"")
"RTN","MXMLPRSE",149,0)
 Q:$L(APND) APND
"RTN","MXMLPRSE",150,0)
 I $D(^TMP(ID,$J,"UNP",NAME)) D ERROR(40,NAME) Q ""
"RTN","MXMLPRSE",151,0)
 I '$D(^TMP(ID,$J,"ENT",NAME)) D ERROR(14,NAME) Q ""
"RTN","MXMLPRSE",152,0)
 S APND=$S(PARAM:" ",1:"")
"RTN","MXMLPRSE",153,0)
 D OPNDOC(^TMP(ID,$J,"ENT",NAME),APND,APND)
"RTN","MXMLPRSE",154,0)
 Q ""
"RTN","MXMLPRSE",155,0)
 ; Parse character entity reference
"RTN","MXMLPRSE",156,0)
 ; Returns character equivalent
"RTN","MXMLPRSE",157,0)
CHENTITY() ;
"RTN","MXMLPRSE",158,0)
 N DIGIT,BASE,DIGITS,VAL
"RTN","MXMLPRSE",159,0)
 S BASE=$S($$NEXT("x"):16,1:10),DIGITS="0123456789"_$S(BASE=16:"ABCDEF",1:""),VAL=0
"RTN","MXMLPRSE",160,0)
 F CPOS=CPOS:1:LLEN+1 Q:$$NEXT(";")!EOD  D
"RTN","MXMLPRSE",161,0)
 .S DIGIT=$F(DIGITS,$$UP^XLFSTR($E(XML,CPOS)))-2,VAL=VAL*BASE+DIGIT
"RTN","MXMLPRSE",162,0)
 .D:DIGIT<0 ERROR(19)
"RTN","MXMLPRSE",163,0)
 I VAL<32,WS'[$C(VAL) D ERROR(19)
"RTN","MXMLPRSE",164,0)
 Q $C(VAL)
"RTN","MXMLPRSE",165,0)
 ; Set an entity value
"RTN","MXMLPRSE",166,0)
SETENT(NAME,VAL) ;
"RTN","MXMLPRSE",167,0)
 K ^TMP(ID,$J,"ENT",NAME)
"RTN","MXMLPRSE",168,0)
 S ^(NAME)=$NA(^(NAME)),^(NAME,1)=VAL
"RTN","MXMLPRSE",169,0)
 Q
"RTN","MXMLPRSE",170,0)
 ; Process all attributes
"RTN","MXMLPRSE",171,0)
ATTRIBS(ENAME,ATTR) ;
"RTN","MXMLPRSE",172,0)
 N TYP,MOD,DEF,ANAME
"RTN","MXMLPRSE",173,0)
 K ATTR
"RTN","MXMLPRSE",174,0)
 F  Q:'$$ATTRIB(ENAME,.ATTR)
"RTN","MXMLPRSE",175,0)
 I OPTION["V" D
"RTN","MXMLPRSE",176,0)
 .S ANAME="$"
"RTN","MXMLPRSE",177,0)
 .F  S ANAME=$O(^TMP(ID,$J,"ATT",ENAME,ANAME)) Q:'$L(ANAME)  D
"RTN","MXMLPRSE",178,0)
 ..S TYP=^(ANAME),MOD=$P(TYP,"^",2),DEF=$P(TYP,"^",3,9999),TYP=+TYP
"RTN","MXMLPRSE",179,0)
 ..I MOD=1!(MOD=3),'$D(ATTR(ANAME)) D ERROR(36,ANAME) Q
"RTN","MXMLPRSE",180,0)
 ..I MOD=3,ATTR(ANAME)'=DEF D ERROR(37,ATTR(ANAME)) Q
"RTN","MXMLPRSE",181,0)
 ..I MOD=2,'$D(ATTR(ANAME)) Q
"RTN","MXMLPRSE",182,0)
 ..S:'$D(ATTR(ANAME)) ATTR(ANAME)=DEF
"RTN","MXMLPRSE",183,0)
 Q
"RTN","MXMLPRSE",184,0)
 ; Parse attribute=value sequence
"RTN","MXMLPRSE",185,0)
 ; ENAME=Element name to which attribute belongs
"RTN","MXMLPRSE",186,0)
 ; ATTR=Local array (by reference) to receive attribute value.
"RTN","MXMLPRSE",187,0)
 ;      Format is ATTR("<attribute name>")="<attribute value>"
"RTN","MXMLPRSE",188,0)
 ; Returns 1 if successful, 0 if not.
"RTN","MXMLPRSE",189,0)
ATTRIB(ENAME,ATTR) ;
"RTN","MXMLPRSE",190,0)
 N ANAME
"RTN","MXMLPRSE",191,0)
 D READ,WS() ;p116
"RTN","MXMLPRSE",192,0)
 S ANAME=$$NAME
"RTN","MXMLPRSE",193,0)
 Q:ANAME="" 0
"RTN","MXMLPRSE",194,0)
 I $D(ATTR(ANAME)) D ERROR(4,ANAME) Q 0
"RTN","MXMLPRSE",195,0)
 D:'$D(^TMP(ID,$J,"ATT",ENAME,ANAME)) ERROR(29,ANAME)
"RTN","MXMLPRSE",196,0)
 D READ,WS() ;p116
"RTN","MXMLPRSE",197,0)
 Q:'$$NEXT("=",3) 0
"RTN","MXMLPRSE",198,0)
 D WS()
"RTN","MXMLPRSE",199,0)
 S ATTR(ANAME)=$$VALUE(1)
"RTN","MXMLPRSE",200,0)
 D CHKVAL^MXMLPRS1(ENAME,ANAME,ATTR(ANAME))
"RTN","MXMLPRSE",201,0)
 Q 1
"RTN","MXMLPRSE",202,0)
 ; Parse a processing instruction
"RTN","MXMLPRSE",203,0)
 ; Returns 1 if PI found, 0 if not.
"RTN","MXMLPRSE",204,0)
PI() N PNAME,ARGS,DONE
"RTN","MXMLPRSE",205,0)
 Q:'$$NEXT("<?") 0
"RTN","MXMLPRSE",206,0)
 S PNAME=$$NAME(2),ARGS=0
"RTN","MXMLPRSE",207,0)
 I $$UP^XLFSTR(PNAME)="XML" D ERROR(9) Q 0
"RTN","MXMLPRSE",208,0)
 D WS(1)
"RTN","MXMLPRSE",209,0)
 F  S DONE=$F(XML,"?>",CPOS) D  Q:DONE!EOD
"RTN","MXMLPRSE",210,0)
 .S ARGS=ARGS+1,ARGS(ARGS)=$E(XML,CPOS,$S(DONE:DONE-3,1:LLEN))
"RTN","MXMLPRSE",211,0)
 .S CPOS=$S(DONE:DONE,1:LLEN+1)
"RTN","MXMLPRSE",212,0)
 .D READ
"RTN","MXMLPRSE",213,0)
 I EOD D ERROR(7) Q 0
"RTN","MXMLPRSE",214,0)
 D CBK("PI",PNAME,.ARGS)
"RTN","MXMLPRSE",215,0)
 Q 1
"RTN","MXMLPRSE",216,0)
 ; Parse a comment
"RTN","MXMLPRSE",217,0)
 ; Returns 1 if comment found, 0 if not.
"RTN","MXMLPRSE",218,0)
COMMENT() Q $$PARSCT("<!--","--",">","COMMENT")
"RTN","MXMLPRSE",219,0)
 ; Parse a CDATA section
"RTN","MXMLPRSE",220,0)
 ; Returns 1 if found, 0 if not.
"RTN","MXMLPRSE",221,0)
CDATA() Q $$PARSCT("<![CDATA[","]]>","","CHARACTERS")
"RTN","MXMLPRSE",222,0)
 ; Parse a section (for CDATA and COMMENT)
"RTN","MXMLPRSE",223,0)
 ; BGN=Beginning delimiter
"RTN","MXMLPRSE",224,0)
 ; END=Ending delimiter
"RTN","MXMLPRSE",225,0)
 ; TRL=Trailing delimiter
"RTN","MXMLPRSE",226,0)
 ; TYP=Event type
"RTN","MXMLPRSE",227,0)
PARSCT(BGN,END,TRL,TYP) ;
"RTN","MXMLPRSE",228,0)
 N X
"RTN","MXMLPRSE",229,0)
 Q:'$$NEXT(BGN) 0
"RTN","MXMLPRSE",230,0)
 D EPOS
"RTN","MXMLPRSE",231,0)
 I 'LVL,TYP'="COMMENT" D ERROR(6) Q 0
"RTN","MXMLPRSE",232,0)
 F  S X=$F(XML,END,CPOS) D  Q:X!EOD
"RTN","MXMLPRSE",233,0)
 .D CBK(TYP,$E(XML,CPOS,$S(X:X-$L(END)-1,1:LLEN)))
"RTN","MXMLPRSE",234,0)
 .S CPOS=$S(X:X,1:LLEN+1)
"RTN","MXMLPRSE",235,0)
 .D READ,EPOS
"RTN","MXMLPRSE",236,0)
 I EOD D ERROR(7) Q 0
"RTN","MXMLPRSE",237,0)
 I $L(TRL),$$NEXT(TRL,3)
"RTN","MXMLPRSE",238,0)
 Q 1
"RTN","MXMLPRSE",239,0)
 ; Fetch an external entity from file or entity catalog
"RTN","MXMLPRSE",240,0)
 ; SYS=System identifier (i.e., a URL)
"RTN","MXMLPRSE",241,0)
 ; PUB=Public identifier (i.e., Entity Catalog ID) - optional
"RTN","MXMLPRSE",242,0)
 ; GBL=Optional global root to receive entity content
"RTN","MXMLPRSE",243,0)
 ; Returns global reference or null if error
"RTN","MXMLPRSE",244,0)
EXTRNL(SYS,PUB,GBL) ;
"RTN","MXMLPRSE",245,0)
 N X,Y
"RTN","MXMLPRSE",246,0)
 S PUB=$$NMLWS($G(PUB)),GBL=$G(GBL)
"RTN","MXMLPRSE",247,0)
 I '$L(GBL) D CBK("EXTERNAL",.SYS,.PUB,.GBL) Q:$L(GBL) GBL
"RTN","MXMLPRSE",248,0)
 I $L(PUB) D  Q:X $NA(^MXML(950,X,1))
"RTN","MXMLPRSE",249,0)
 .S Y=$E(PUB,1,30),X=0
"RTN","MXMLPRSE",250,0)
 .F  S X=$O(^MXML(950,"B",Y,X)) Q:'X  Q:$G(^MXML(950,X,0))=PUB
"RTN","MXMLPRSE",251,0)
 S:'$L(GBL) GBL=$$TMPGBL
"RTN","MXMLPRSE",252,0)
 ; S:$$PATH(SYS)="" SYS=PATH_SYS /VEN/SMH 2.1 commented out
"RTN","MXMLPRSE",253,0)
 N FILENAME
"RTN","MXMLPRSE",254,0)
 I $L(PATH) S FILENAME=$P(SYS,PATH,2,99) ; VEN/SMH 2.1 (path supplied)
"RTN","MXMLPRSE",255,0)
 E  S FILENAME=SYS ; VEN/SMH 2.1 (no path supplied)
"RTN","MXMLPRSE",256,0)
 S X=$S($$FTG^%ZISH(PATH,FILENAME,$NA(@GBL@(1)),$QL(GBL)+1):GBL,1:"") ; VEN/SMH 2.1
"RTN","MXMLPRSE",257,0)
 D:'$L(X) ERROR(30,$S($L(SYS):SYS,1:PUB))
"RTN","MXMLPRSE",258,0)
 Q X
"RTN","MXMLPRSE",259,0)
 ; Return a unique scratch global reference
"RTN","MXMLPRSE",260,0)
TMPGBL() N SUB
"RTN","MXMLPRSE",261,0)
 S SUB=$O(^TMP(ID,$J,$C(1)),-1)+1,^(SUB)=""
"RTN","MXMLPRSE",262,0)
 Q $NA(^(SUB))
"RTN","MXMLPRSE",263,0)
 ; Returns a SYSTEM and/or PUBLIC id
"RTN","MXMLPRSE",264,0)
 ; SYS=Returned SYSTEM id
"RTN","MXMLPRSE",265,0)
 ; PUB=Returned PUBLIC id
"RTN","MXMLPRSE",266,0)
 ; FLG=If set, SYSTEM id is optional after PUBLIC id
"RTN","MXMLPRSE",267,0)
 ; Optional return value: 0=neither, 1=PUBLIC, 2=SYSTEM
"RTN","MXMLPRSE",268,0)
SYSPUB(SYS,PUB,FLG) ;
"RTN","MXMLPRSE",269,0)
 N RTN
"RTN","MXMLPRSE",270,0)
 I $$NEXT("PUBLIC") D
"RTN","MXMLPRSE",271,0)
 .D WS(1)
"RTN","MXMLPRSE",272,0)
 .S PUB=$$VALUE(1),SYS=$$VALUE('$G(FLG)),RTN=1
"RTN","MXMLPRSE",273,0)
 E  I $$NEXT("SYSTEM") D
"RTN","MXMLPRSE",274,0)
 .D WS(1)
"RTN","MXMLPRSE",275,0)
 .S PUB="",SYS=$$VALUE(1),RTN=2
"RTN","MXMLPRSE",276,0)
 E  S (SYS,PUB)="",RTN=0
"RTN","MXMLPRSE",277,0)
 Q:$Q RTN
"RTN","MXMLPRSE",278,0)
 Q
"RTN","MXMLPRSE",279,0)
 ; Save current document location for error reporting
"RTN","MXMLPRSE",280,0)
 ; See EPOS^MXMLPRS0
"RTN","MXMLPRSE",281,0)
EPOS S ERR("XML")=XML,ERR("POS")=CPOS,ERR("LIN")=LPOS
"RTN","MXMLPRSE",282,0)
 Q
"RTN","MXMLPRSE",283,0)
 ; Setup error information
"RTN","MXMLPRSE",284,0)
ERROR(ERN,ARG) ;
"RTN","MXMLPRSE",285,0)
 N DIHELP,DIMSG,DIERR,MSG
"RTN","MXMLPRSE",286,0)
 D BLD^DIALOG(9500000+ERN,"","","MSG","")
"RTN","MXMLPRSE",287,0)
 S ERR("NUM")=ERN
"RTN","MXMLPRSE",288,0)
 S ERR("SEV")=$S($G(DIHELP):0,$G(DIMSG):1,1:2)
"RTN","MXMLPRSE",289,0)
 S ERR("MSG")=$G(MSG(1))
"RTN","MXMLPRSE",290,0)
 S ERR("ARG")=$G(ARG)
"RTN","MXMLPRSE",291,0)
 I OPTION'["W"!ERR("SEV"),OPTION["V"!(ERR("SEV")'=1) D CBK("ERROR",.ERR)
"RTN","MXMLPRSE",292,0)
 S:ERR("SEV")=2!(OPTION[ERR("SEV")) EOD=-1                             ; Stop parsing on severe error
"RTN","MXMLPRSE",293,0)
 Q
"RTN","MXMLPRSE",294,0)
 ; Shortcuts to functions/procedures defined elsewhere
"RTN","MXMLPRSE",295,0)
WS(X) Q:$Q $$WS^MXMLPRS0(.X)
"RTN","MXMLPRSE",296,0)
 D WS^MXMLPRS0(.X) Q
"RTN","MXMLPRSE",297,0)
CBK(X,Y1,Y2,Y3,Y4) D CBK^MXMLPRS0(.X,.Y1,.Y2,.Y3,.Y4) Q
"RTN","MXMLPRSE",298,0)
NEXT(X,Y) Q $$NEXT^MXMLPRS0(.X,.Y)
"RTN","MXMLTEST")
0^4^B8594598
"RTN","MXMLTEST",1,0)
MXMLTEST ;SAIC/DKM - Test XML SAX interface ;01/31/2002  17:11
"RTN","MXMLTEST",2,0)
 ;;2.1;XML PROCESSING UTILITIES;;Nov 27, 2013;Build 9
"RTN","MXMLTEST",3,0)
 ;=================================================================
"RTN","MXMLTEST",4,0)
 ; This application acts as a client to the XML parser.  It displays
"RTN","MXMLTEST",5,0)
 ; parsing events as they occur and generates a summary at the end.
"RTN","MXMLTEST",6,0)
EN(DOC,OPTION) ;
"RTN","MXMLTEST",7,0)
 N CBK,CNT
"RTN","MXMLTEST",8,0)
 W !!!,"Invoking XML Parser...",!!!
"RTN","MXMLTEST",9,0)
 D SET(.CBK),EN^MXMLPRSE(DOC,.CBK,.OPTION)
"RTN","MXMLTEST",10,0)
 S CNT=""
"RTN","MXMLTEST",11,0)
 W !!!,"Parser Summary:",!!
"RTN","MXMLTEST",12,0)
 F  S CNT=$O(CNT(CNT)) Q:CNT=""  W CNT,":",?25,CNT(CNT),!
"RTN","MXMLTEST",13,0)
 Q
"RTN","MXMLTEST",14,0)
 ; Direct entry of XML text from keyboard
"RTN","MXMLTEST",15,0)
 ; Terminate text entry with a solitary '^'
"RTN","MXMLTEST",16,0)
PASTE(OPTION) ;
"RTN","MXMLTEST",17,0)
 N X,Y,GBL
"RTN","MXMLTEST",18,0)
 S GBL=$NA(^TMP("MXMLTEST",$J))
"RTN","MXMLTEST",19,0)
 K @GBL
"RTN","MXMLTEST",20,0)
 F X=1:1 D  Q:Y="^"
"RTN","MXMLTEST",21,0)
 .W X,"> "
"RTN","MXMLTEST",22,0)
 .R Y:$G(DTIME,600),!
"RTN","MXMLTEST",23,0)
 .E  S Y="^"
"RTN","MXMLTEST",24,0)
 .S:Y'="^" @GBL@(X)=Y
"RTN","MXMLTEST",25,0)
 D EN(GBL,.OPTION)
"RTN","MXMLTEST",26,0)
 K @GBL
"RTN","MXMLTEST",27,0)
 Q
"RTN","MXMLTEST",28,0)
 ; Set the event interface entry points
"RTN","MXMLTEST",29,0)
SET(CBK) N X,Y
"RTN","MXMLTEST",30,0)
 K CBK
"RTN","MXMLTEST",31,0)
 F X=0:1 S Y=$P($T(SETX+X),";;",2) Q:Y=""  D
"RTN","MXMLTEST",32,0)
 .S CBK(Y)=$E(Y,1,8)_"^MXMLTEST"
"RTN","MXMLTEST",33,0)
 Q
"RTN","MXMLTEST",34,0)
 ; Convert special characters to \x format
"RTN","MXMLTEST",35,0)
ESC(X) N C,Y,Z
"RTN","MXMLTEST",36,0)
 F Z=1:1 S C=$E(X,Z) Q:C=""  D
"RTN","MXMLTEST",37,0)
 .S Y=$TR(C,$C(9,10,13,92),"tnc")
"RTN","MXMLTEST",38,0)
 .S:C'=Y $E(X,Z)=$S(Y="":"\\",1:"\"_Y),Z=Z+1
"RTN","MXMLTEST",39,0)
 Q X
"RTN","MXMLTEST",40,0)
SETX ;;STARTDOCUMENT
"RTN","MXMLTEST",41,0)
 ;;ENDDOCUMENT
"RTN","MXMLTEST",42,0)
 ;;DOCTYPE
"RTN","MXMLTEST",43,0)
 ;;STARTELEMENT
"RTN","MXMLTEST",44,0)
 ;;ENDELEMENT
"RTN","MXMLTEST",45,0)
 ;;CHARACTERS
"RTN","MXMLTEST",46,0)
 ;;PI
"RTN","MXMLTEST",47,0)
 ;;ERROR
"RTN","MXMLTEST",48,0)
 ;;COMMENT
"RTN","MXMLTEST",49,0)
 ;;EXTERNAL
"RTN","MXMLTEST",50,0)
 ;;NOTATION
"RTN","MXMLTEST",51,0)
 ;;
"RTN","MXMLTEST",52,0)
 ; Event interface callbacks
"RTN","MXMLTEST",53,0)
STARTDOC ;
"RTN","MXMLTEST",54,0)
ENDDOCUM W EVT,"()",!
"RTN","MXMLTEST",55,0)
 Q
"RTN","MXMLTEST",56,0)
DOCTYPE(P1,P2,P3) ;
"RTN","MXMLTEST",57,0)
 W EVT,"(""",P1,""",""",P2,""",""",P3,""")",!
"RTN","MXMLTEST",58,0)
 Q
"RTN","MXMLTEST",59,0)
STARTELE(ELE,ATR) ;
"RTN","MXMLTEST",60,0)
 D ARGS(ELE,.ATR),COUNT("Elements")
"RTN","MXMLTEST",61,0)
 Q
"RTN","MXMLTEST",62,0)
ARGS(ELE,ATR) ;
"RTN","MXMLTEST",63,0)
 N X,Y
"RTN","MXMLTEST",64,0)
 W EVT,"(""",ELE,""""
"RTN","MXMLTEST",65,0)
 S X="",Y=","""
"RTN","MXMLTEST",66,0)
 F  S X=$O(ATR(X)) Q:X=""  W Y,X,"=",$$ESC(ATR(X)) S Y=";"
"RTN","MXMLTEST",67,0)
 W $S($L(Y)=1:""")",1:")"),!
"RTN","MXMLTEST",68,0)
 Q
"RTN","MXMLTEST",69,0)
ENDELEME(ELE) ;
"RTN","MXMLTEST",70,0)
 W EVT,"(""",ELE,""")",!
"RTN","MXMLTEST",71,0)
 Q
"RTN","MXMLTEST",72,0)
CHARACTE(TXT) ;
"RTN","MXMLTEST",73,0)
 D COUNT("Non-markup Content",$L(TXT))
"RTN","MXMLTEST",74,0)
 W EVT,"(""",$$ESC(TXT),""")",!
"RTN","MXMLTEST",75,0)
 Q
"RTN","MXMLTEST",76,0)
PI(TGT,TXT) ;
"RTN","MXMLTEST",77,0)
 D ARGS(TGT,.TXT)
"RTN","MXMLTEST",78,0)
 D COUNT("Processing Instructions")
"RTN","MXMLTEST",79,0)
 Q
"RTN","MXMLTEST",80,0)
COMMENT(TXT) ;
"RTN","MXMLTEST",81,0)
 W EVT,"(""",TXT,""")",!
"RTN","MXMLTEST",82,0)
 D COUNT("Comments")
"RTN","MXMLTEST",83,0)
 Q
"RTN","MXMLTEST",84,0)
EXTERNAL(SYS,PUB,GBL) ;
"RTN","MXMLTEST",85,0)
 W EVT,"(""",SYS,""",""",PUB,""")",!
"RTN","MXMLTEST",86,0)
 D COUNT("External Entities")
"RTN","MXMLTEST",87,0)
 Q
"RTN","MXMLTEST",88,0)
NOTATION(NAME,SYS,PUB) ;
"RTN","MXMLTEST",89,0)
 W EVT,"(""",NAME,""",""",SYS,""",""",PUB,""")",!
"RTN","MXMLTEST",90,0)
 D COUNT("Notation Declarations")
"RTN","MXMLTEST",91,0)
 Q
"RTN","MXMLTEST",92,0)
COUNT(TYPE,INC) ;
"RTN","MXMLTEST",93,0)
 S CNT(TYPE)=$G(CNT(TYPE))+$G(INC,1)
"RTN","MXMLTEST",94,0)
 Q
"RTN","MXMLTEST",95,0)
ERROR(ERR) ;
"RTN","MXMLTEST",96,0)
 N X
"RTN","MXMLTEST",97,0)
 S X=$P("Warning^Validation Error^Conformance Error","^",ERR("SEV")+1)
"RTN","MXMLTEST",98,0)
 D COUNT(X_"s")
"RTN","MXMLTEST",99,0)
 W X,": ",ERR("MSG")
"RTN","MXMLTEST",100,0)
 W:$G(ERR("ARG"))'="" " (",ERR("ARG"),")"
"RTN","MXMLTEST",101,0)
 W ".  ","Line ",ERR("LIN"),", Position ",ERR("POS"),!
"RTN","MXMLTEST",102,0)
 W $TR(ERR("XML"),$C(9,10,13)," "),!,$$REPEAT^XLFSTR("-",ERR("POS")-1),"^",!!
"RTN","MXMLTEST",103,0)
 Q
"RTN","MXMLTMP1")
0^9^B66308015
"RTN","MXMLTMP1",1,0)
MXMLTMP1 ; VEN/GPL - MXMLTMPL spill over;2013-08-13  1:22 PM
"RTN","MXMLTMP1",2,0)
 ;;2.1;XML PROCESSING UTILITIES;;Nov 27, 2013;Build 9
"RTN","MXMLTMP1",3,0)
 ;
"RTN","MXMLTMP1",4,0)
INDEX(IZXML,VDX,NOINX,TEMPLATE,REDUX) ; parse XML in IZXML and produce 
"RTN","MXMLTMP1",5,0)
 ; an XPATH index; REDUX is a string to be removed from each xpath
"RTN","MXMLTMP1",6,0)
 ; ZEXCEPT: E1 ; XINDEX is making a mistake
"RTN","MXMLTMP1",7,0)
 ; GPL 7/14/09 OPTIONALLY GENERATE AN XML TEMPLATE IF PASSED BY NAME
"RTN","MXMLTMP1",8,0)
 ; TEMPLATE IS IDENTICAL TO THE PARSED XML LINE BY LINE
"RTN","MXMLTMP1",9,0)
 ; EXCEPT THAT DATA VALUES ARE REPLACED WITH @@XPATH@@ FOR THE XPATH OF THE TAG
"RTN","MXMLTMP1",10,0)
 ; GPL 5/24/09 AND OPTIONALLY PRODUCE THE VDX ARRAY PASSED BY NAME
"RTN","MXMLTMP1",11,0)
 ; @VDX@("XPATH")=VALUE
"RTN","MXMLTMP1",12,0)
 ; ex. @IZXML@("XPATH")=FIRSTLINE^LASTLINE
"RTN","MXMLTMP1",13,0)
 ; WHERE FIRSTLINE AND LASTLINE ARE THE BEGINNING AND ENDING OF THE
"RTN","MXMLTMP1",14,0)
 ; XML SECTION
"RTN","MXMLTMP1",15,0)
 ; IZXML IS PASSED BY NAME
"RTN","MXMLTMP1",16,0)
 ; IF NOINX IS SET TO 1, NO INDEX WILL BE GENERATED, BUT THE VDX WILL BE
"RTN","MXMLTMP1",17,0)
 N I,LINE,FIRST,LAST,CUR,TMP,MDX,FOUND,CURVAL,DVDX,LCNT
"RTN","MXMLTMP1",18,0)
 N MXMLSTK ; LEAVE OUT FOR DEBUGGING
"RTN","MXMLTMP1",19,0)
 I '$D(REDUX) S REDUX=""
"RTN","MXMLTMP1",20,0)
 I '$D(NOINX) S NOINX=0 ; IF NOT PASSED, GENERATE AN INDEX
"RTN","MXMLTMP1",21,0)
 N ZXML
"RTN","MXMLTMP1",22,0)
 I NOINX S ZXML=$NA(^TMP("MXMLINDEX",$J)) K @ZXML  ; TEMP PLACE FOR INDEX TO DISCARD
"RTN","MXMLTMP1",23,0)
 E  S ZXML=IZXML ; PLACE FOR INDEX TO KEEP
"RTN","MXMLTMP1",24,0)
 I '$D(@IZXML@(0)) D  ; IF COUNT NOT IN NODE 0 COUNT THEM
"RTN","MXMLTMP1",25,0)
 . S I="",LCNT=0
"RTN","MXMLTMP1",26,0)
 . F  S I=$O(@IZXML@(I)) Q:I=""  S LCNT=LCNT+1
"RTN","MXMLTMP1",27,0)
 E  S LCNT=@IZXML@(0) ; LINE COUNT PASSED IN ARRAY
"RTN","MXMLTMP1",28,0)
 I LCNT=0  D  Q  ; NO XML PASSED
"RTN","MXMLTMP1",29,0)
 . D EN^DDIOL("ERROR IN XML FILE")
"RTN","MXMLTMP1",30,0)
 S DVDX=0 ; DEFAULT DO NOT PRODUCE VDX INDEX
"RTN","MXMLTMP1",31,0)
 I $D(VDX) S DVDX=1 ; IF NAME PASSED, DO VDX
"RTN","MXMLTMP1",32,0)
 S MXMLSTK(0)=0 ; INITIALIZE STACK
"RTN","MXMLTMP1",33,0)
 N LKASD ; KILL LOOKASIDE ARRAY
"RTN","MXMLTMP1",34,0)
 D MKLASD(.LKASD,IZXML,LCNT) ;MAKE LOOK ASIDE BUFFER FOR MULTIPLES
"RTN","MXMLTMP1",35,0)
 F I=1:1:LCNT  D  ; PROCESS THE ENTIRE ARRAY
"RTN","MXMLTMP1",36,0)
 . S LINE=@IZXML@(I)
"RTN","MXMLTMP1",37,0)
 . I $D(TEMPLATE) D  ;IF TEMPLATE IS REQUESTED
"RTN","MXMLTMP1",38,0)
 . . S @TEMPLATE@(I)=$$CLEAN(LINE)
"RTN","MXMLTMP1",39,0)
 . ;W LINE,!
"RTN","MXMLTMP1",40,0)
 . S FOUND=0  ; INTIALIZED FOUND FLAG
"RTN","MXMLTMP1",41,0)
 . I LINE?.E1"<!".E S FOUND=1 ; SKIP OVER COMMENTS
"RTN","MXMLTMP1",42,0)
 . I FOUND'=1  D
"RTN","MXMLTMP1",43,0)
 . . I (LINE?.E1"<"1.E1"</".E)!(LINE?.E1"<"1.E1"/>".E)  D
"RTN","MXMLTMP1",44,0)
 . . . ; THIS IS THE CASE THERE SECTION BEGINS AND ENDS
"RTN","MXMLTMP1",45,0)
 . . . ; ON THE SAME LINE
"RTN","MXMLTMP1",46,0)
 . . . ; W "FOUND ",LINE,!
"RTN","MXMLTMP1",47,0)
 . . . S FOUND=1  ; SET FOUND FLAG
"RTN","MXMLTMP1",48,0)
 . . . S CUR=$$XNAME(LINE) ; EXTRACT THE NAME
"RTN","MXMLTMP1",49,0)
 . . . S CUR=CUR_$G(LKASD(CUR,I)) ; HANDLE MULTIPLES
"RTN","MXMLTMP1",50,0)
 . . . D PUSH("MXMLSTK",CUR) ; ADD TO THE STACK
"RTN","MXMLTMP1",51,0)
 . . . D MKMDX("MXMLSTK",.MDX,REDUX) ; GENERATE THE M INDEX
"RTN","MXMLTMP1",52,0)
 . . . ; W "MDX=",MDX,!
"RTN","MXMLTMP1",53,0)
 . . . I $D(@ZXML@(MDX))  D  ; IN THE INDEX, IS A MULTIPLE
"RTN","MXMLTMP1",54,0)
 . . . . ;I '$D(ZDUP(MDX)) S ZDUP(MDX)=2
"RTN","MXMLTMP1",55,0)
 . . . . ;E  S ZDUP(MDX)=ZDUP(MDX)+1
"RTN","MXMLTMP1",56,0)
 . . . . ;W "DUP:",MDX,!
"RTN","MXMLTMP1",57,0)
 . . . . ;I '$D(CURVAL) S CURVAL=""
"RTN","MXMLTMP1",58,0)
 . . . . ;I DVDX S @VDX@(MDX_"["_ZDUP(MDX)_"]")=CURVAL
"RTN","MXMLTMP1",59,0)
 . . . . S $P(@ZXML@(MDX),"^",2)=I ; UPDATE LAST LINE NUMBER
"RTN","MXMLTMP1",60,0)
 . . . I '$D(@ZXML@(MDX))  D  ; NOT IN THE INDEX, NOT A MULTIPLE
"RTN","MXMLTMP1",61,0)
 . . . . S @ZXML@(MDX)=I_"^"_I  ; ADD INDEX ENTRY-FIRST AND LAST
"RTN","MXMLTMP1",62,0)
 . . . . S CURVAL=$$XVAL(LINE) ; VALUE
"RTN","MXMLTMP1",63,0)
 . . . . S $P(@ZXML@(MDX),"^",3)=CURVAL ; THIRD PIECE
"RTN","MXMLTMP1",64,0)
 . . . . I DVDX S @VDX@(MDX)=CURVAL ; FILL IN VDX ARRAY IF REQUESTED
"RTN","MXMLTMP1",65,0)
 . . . . I $D(TEMPLATE) D  ; IF TEMPLATE IS REQUESTED
"RTN","MXMLTMP1",66,0)
 . . . . . S LINE=$$CLEAN(LINE) ; CLEAN OUT CONTROL CHARACTERS
"RTN","MXMLTMP1",67,0)
 . . . . . S @TEMPLATE@(I)=$P(LINE,">",1)_">@@"_MDX_"@@</"_$P(LINE,"</",2)
"RTN","MXMLTMP1",68,0)
 . . . D POP("MXMLSTK",.TMP) ; REMOVE FROM STACK
"RTN","MXMLTMP1",69,0)
 . I FOUND'=1  D  ; THE LINE DOESN'T CONTAIN THE START AND END
"RTN","MXMLTMP1",70,0)
 . . I LINE?.E1"</"1.E  D  ; LINE CONTAINS END OF A SECTION
"RTN","MXMLTMP1",71,0)
 . . . ; W "FOUND ",LINE,!
"RTN","MXMLTMP1",72,0)
 . . . S FOUND=1  ; SET FOUND FLAG
"RTN","MXMLTMP1",73,0)
 . . . S CUR=$$XNAME(LINE) ; EXTRACT THE NAME
"RTN","MXMLTMP1",74,0)
 . . . D MKMDX("MXMLSTK",.MDX) ; GENERATE THE M INDEX
"RTN","MXMLTMP1",75,0)
 . . . S $P(@ZXML@(MDX),"^",2)=I ; UPDATE LAST LINE NUMBER
"RTN","MXMLTMP1",76,0)
 . . . D POP("MXMLSTK",.TMP) ; REMOVE FROM STACK
"RTN","MXMLTMP1",77,0)
 . . . S TMP=$P(TMP,"[",1) ; REMOVE [X] FROM MULTIPLE
"RTN","MXMLTMP1",78,0)
 . . . I TMP'=CUR  D  ; MALFORMED XML, END MUST MATCH START
"RTN","MXMLTMP1",79,0)
 . . . . D EN^DDIOL("MALFORMED XML "_CUR_" LINE "_I_LINE)
"RTN","MXMLTMP1",80,0)
 . . . . D PARY^MXMLTMPL("MXMLSTK") ; PRINT OUT THE STACK FOR DEBUGING
"RTN","MXMLTMP1",81,0)
 . . . . S $EC=",U-MALFORMED-XML,"
"RTN","MXMLTMP1",82,0)
 . . . . Q
"RTN","MXMLTMP1",83,0)
 . I FOUND'=1  D  ; THE LINE MIGHT CONTAIN A SECTION BEGINNING
"RTN","MXMLTMP1",84,0)
 . . I (LINE?.E1"<"1.E)&(LINE'["?>")  D  ; BEGINNING OF A SECTION
"RTN","MXMLTMP1",85,0)
 . . . ; W "FOUND ",LINE,!
"RTN","MXMLTMP1",86,0)
 . . . S FOUND=1  ; SET FOUND FLAG
"RTN","MXMLTMP1",87,0)
 . . . S CUR=$$XNAME(LINE) ; EXTRACT THE NAME
"RTN","MXMLTMP1",88,0)
 . . . S CUR=CUR_$G(LKASD(CUR,I)) ; HANDLE MULTIPLES
"RTN","MXMLTMP1",89,0)
 . . . D PUSH("MXMLSTK",CUR) ; ADD TO THE STACK
"RTN","MXMLTMP1",90,0)
 . . . D MKMDX("MXMLSTK",.MDX) ; GENERATE THE M INDEX
"RTN","MXMLTMP1",91,0)
 . . . ; W "MDX=",MDX,!
"RTN","MXMLTMP1",92,0)
 . . . I $D(@ZXML@(MDX))  D  ; IN THE INDEX, IS A MULTIPLE
"RTN","MXMLTMP1",93,0)
 . . . . S $P(@ZXML@(MDX),"^",2)=I ; UPDATE LAST LINE NUMBER
"RTN","MXMLTMP1",94,0)
 . . . . ;B
"RTN","MXMLTMP1",95,0)
 . . . I '$D(@ZXML@(MDX))  D  ; NOT IN THE INDEX, NOT A MULTIPLE
"RTN","MXMLTMP1",96,0)
 . . . . S @ZXML@(MDX)=I_"^" ; INSERT INTO THE INDEX
"RTN","MXMLTMP1",97,0)
 S @ZXML@("INDEXED")=""
"RTN","MXMLTMP1",98,0)
 S @ZXML@("//")="1^"_LCNT ; ROOT XPATH
"RTN","MXMLTMP1",99,0)
 I NOINX K @ZXML ; DELETE UNWANTED INDEX
"RTN","MXMLTMP1",100,0)
 Q
"RTN","MXMLTMP1",101,0)
MKLASD(OUTBUF,INARY,LCNT) ; CREATE A LOOKASIDE BUFFER FOR MULTILPLES
"RTN","MXMLTMP1",102,0)
 ; ZEXCEPT: E1 ; XINDEX is making a mistake
"RTN","MXMLTMP1",103,0)
 N ZI,ZN,ZA,ZLINE,ZLINE2,CUR,CUR2
"RTN","MXMLTMP1",104,0)
 F ZI=1:1:LCNT-1  D  ; PROCESS THE ENTIRE ARRAY 
"RTN","MXMLTMP1",105,0)
 . S ZLINE=@INARY@(ZI)
"RTN","MXMLTMP1",106,0)
 . I ZI<LCNT S ZLINE2=@INARY@(ZI+1)
"RTN","MXMLTMP1",107,0)
 . I ZLINE?.E1"</"1.E  D  ; NEXT LINE CONTAINS END OF A SECTION
"RTN","MXMLTMP1",108,0)
 . . S CUR=$$XNAME(ZLINE) ; EXTRACT THE NAME
"RTN","MXMLTMP1",109,0)
 . . I (ZLINE2?.E1"<"1.E)&(ZLINE'["?>")  D  ; BEGINNING OF A SECTION
"RTN","MXMLTMP1",110,0)
 . . . S CUR2=$$XNAME(ZLINE2) ; EXTRACT THE NAME 
"RTN","MXMLTMP1",111,0)
 . . . I CUR=CUR2 D  ; IF THIS IS A MULTIPLE
"RTN","MXMLTMP1",112,0)
 . . . . S OUTBUF(CUR,ZI+1)=""
"RTN","MXMLTMP1",113,0)
 ;ZWR OUTBUF
"RTN","MXMLTMP1",114,0)
 S ZI=""
"RTN","MXMLTMP1",115,0)
 F  S ZI=$O(OUTBUF(ZI)) Q:ZI=""  D  ; FOR EACH KIND OF MULTIPLE
"RTN","MXMLTMP1",116,0)
 . S ZN=$O(OUTBUF(ZI,"")) ; LINE NUMBER OF SECOND MULTIPLE
"RTN","MXMLTMP1",117,0)
 . F  S ZN=$O(@INARY@(ZN),-1) Q:ZN=""  I $E($P(@INARY@(ZN),"<"_ZI,2),1,1)=">" Q  ;
"RTN","MXMLTMP1",118,0)
 . S OUTBUF(ZI,ZN)=""
"RTN","MXMLTMP1",119,0)
 S ZA=1,ZI="",ZN=""
"RTN","MXMLTMP1",120,0)
 F  S ZI=$O(OUTBUF(ZI)) Q:ZI=""  D  ; ADDING THE COUNT FOR THE MULIPLES [x]
"RTN","MXMLTMP1",121,0)
 . S ZN="",ZA=1
"RTN","MXMLTMP1",122,0)
 . F  S ZN=$O(OUTBUF(ZI,ZN)) Q:ZN=""  D  ;
"RTN","MXMLTMP1",123,0)
 . . S OUTBUF(ZI,ZN)="["_ZA_"]"
"RTN","MXMLTMP1",124,0)
 . . S ZA=ZA+1
"RTN","MXMLTMP1",125,0)
 Q
"RTN","MXMLTMP1",126,0)
 ;
"RTN","MXMLTMP1",127,0)
 ;
"RTN","MXMLTMP1",128,0)
CLEAN(STR,TR) ; extrinsic function; returns string
"RTN","MXMLTMP1",129,0)
 ;; Removes all non printable characters from a string.
"RTN","MXMLTMP1",130,0)
 ;; STR by Value
"RTN","MXMLTMP1",131,0)
 ;; TR IS OPTIONAL TO IMPROVE PERFORMANCE
"RTN","MXMLTMP1",132,0)
 N TR,I
"RTN","MXMLTMP1",133,0)
 I '$D(TR) D  ;
"RTN","MXMLTMP1",134,0)
 . F I=0:1:31 S TR=$G(TR)_$C(I)
"RTN","MXMLTMP1",135,0)
 . S TR=TR_$C(127)
"RTN","MXMLTMP1",136,0)
 QUIT $TR(STR,TR)
"RTN","MXMLTMP1",137,0)
 ;
"RTN","MXMLTMP1",138,0)
XNAME(ISTR)     ; FUNCTION TO EXTRACT A NAME FROM AN XML FRAG
"RTN","MXMLTMP1",139,0)
 ; ZEXCEPT: E1 ; XINDEX is making a mistake
"RTN","MXMLTMP1",140,0)
 ;  </NAME> AND <NAME ID=XNAME> WILL RETURN NAME
"RTN","MXMLTMP1",141,0)
 ; ISTR IS PASSED BY VALUE
"RTN","MXMLTMP1",142,0)
 N CUR,TMP
"RTN","MXMLTMP1",143,0)
 I ISTR?.E1"<".E  D  ; STRIP OFF LEFT BRACKET
"RTN","MXMLTMP1",144,0)
 . S TMP=$P(ISTR,"<",2)
"RTN","MXMLTMP1",145,0)
 I TMP?1"/".E  D  ; ALSO STRIP OFF SLASH IF PRESENT IE </NAME>
"RTN","MXMLTMP1",146,0)
 . S TMP=$P(TMP,"/",2)
"RTN","MXMLTMP1",147,0)
 S CUR=$P(TMP,">",1) ; EXTRACT THE NAME
"RTN","MXMLTMP1",148,0)
 ; W "CUR= ",CUR,!
"RTN","MXMLTMP1",149,0)
 I CUR?.1"_"1.A1" ".E  D  ; CONTAINS A BLANK IE NAME ID=TEST>
"RTN","MXMLTMP1",150,0)
 . S CUR=$P(CUR," ",1) ; STRIP OUT BLANK AND AFTER
"RTN","MXMLTMP1",151,0)
 ; W "CUR2= ",CUR,!
"RTN","MXMLTMP1",152,0)
 Q CUR
"RTN","MXMLTMP1",153,0)
 ;
"RTN","MXMLTMP1",154,0)
XVAL(ISTR) ; EXTRACTS THE VALUE FROM A FRAGMENT OF XML
"RTN","MXMLTMP1",155,0)
 ; <NAME>VALUE</NAME> WILL RETURN VALUE
"RTN","MXMLTMP1",156,0)
 N G
"RTN","MXMLTMP1",157,0)
 S G=$P(ISTR,">",2) ;STRIP OFF <NAME>
"RTN","MXMLTMP1",158,0)
 Q $P(G,"<",1) ; STRIP OFF </NAME> LEAVING VALUE
"RTN","MXMLTMP1",159,0)
 ;
"RTN","MXMLTMP1",160,0)
MKMDX(STK,RTN,INREDUX)  ; MAKES A MUMPS INDEX FROM THE ARRAY STK
"RTN","MXMLTMP1",161,0)
 ; RTN IS SET TO //FIRST/SECOND/THIRD FOR THREE ARRAY ELEMENTS
"RTN","MXMLTMP1",162,0)
 ; REDUX IS A STRING TO REMOVE FROM THE RESULT
"RTN","MXMLTMP1",163,0)
 S RTN=""
"RTN","MXMLTMP1",164,0)
 N I
"RTN","MXMLTMP1",165,0)
 ; W "STK= ",STK,!
"RTN","MXMLTMP1",166,0)
 I @STK@(0)>0  D  ; IF THE ARRAY IS NOT EMPTY
"RTN","MXMLTMP1",167,0)
 . S RTN="//"_@STK@(1) ; FIRST ELEMENT NEEDS NO SEMICOLON
"RTN","MXMLTMP1",168,0)
 . I @STK@(0)>1  D  ; SUBSEQUENT ELEMENTS NEED A SEMICOLON
"RTN","MXMLTMP1",169,0)
 . . F I=2:1:@STK@(0) S RTN=RTN_"/"_@STK@(I)
"RTN","MXMLTMP1",170,0)
 I $G(INREDUX)'="" S RTN=$P(RTN,INREDUX,1)_$P(RTN,INREDUX,2)
"RTN","MXMLTMP1",171,0)
 Q
"RTN","MXMLTMP1",172,0)
 ;
"RTN","MXMLTMP1",173,0)
PUSH(STK,VAL)   ; pushs VAL onto STK and updates STK(0)
"RTN","MXMLTMP1",174,0)
 ;  VAL IS A STRING AND STK IS PASSED BY NAME
"RTN","MXMLTMP1",175,0)
 ;
"RTN","MXMLTMP1",176,0)
 I '$D(@STK@(0)) S @STK@(0)=0 ; IF THE ARRAY IS EMPTY, INITIALIZE
"RTN","MXMLTMP1",177,0)
 S @STK@(0)=@STK@(0)+1 ; INCREMENT ARRAY DEPTH
"RTN","MXMLTMP1",178,0)
 S @STK@(@STK@(0))=VAL ; PUT VAL A THE END OF THE ARRAY
"RTN","MXMLTMP1",179,0)
 Q
"RTN","MXMLTMP1",180,0)
 ;
"RTN","MXMLTMP1",181,0)
POP(STK,VAL)    ; POPS THE LAST VALUE OFF THE STK AND RETURNS IT IN VAL
"RTN","MXMLTMP1",182,0)
 ; VAL AND STK ARE PASSED BY REFERENCE
"RTN","MXMLTMP1",183,0)
 ;
"RTN","MXMLTMP1",184,0)
 I @STK@(0)<1 D  ; IF ARRAY IS EMPTY
"RTN","MXMLTMP1",185,0)
 . S VAL=""
"RTN","MXMLTMP1",186,0)
 . S @STK@(0)=0
"RTN","MXMLTMP1",187,0)
 I @STK@(0)>0  D  ;
"RTN","MXMLTMP1",188,0)
 . S VAL=@STK@(@STK@(0))
"RTN","MXMLTMP1",189,0)
 . K @STK@(@STK@(0))
"RTN","MXMLTMP1",190,0)
 . S @STK@(0)=@STK@(0)-1 ; NEW DEPTH OF THE ARRAY
"RTN","MXMLTMP1",191,0)
 Q
"RTN","MXMLTMP1",192,0)
 ;
"RTN","MXMLTMP1",193,0)
PUSHA(ADEST,ASRC) ; PUSH ASRC ONTO ADEST, BOTH PASSED BY NAME
"RTN","MXMLTMP1",194,0)
 ;
"RTN","MXMLTMP1",195,0)
 N ZGI
"RTN","MXMLTMP1",196,0)
 F ZGI=1:1:@ASRC@(0) D  ; FOR ALL OF THE SOURCE ARRAY
"RTN","MXMLTMP1",197,0)
 . D PUSH(ADEST,@ASRC@(ZGI)) ; PUSH ONE ELEMENT
"RTN","MXMLTMP1",198,0)
 Q
"RTN","MXMLTMP1",199,0)
 ;
"RTN","MXMLTMP1",200,0)
TRIM(THEXML) ; TAKES OUT ALL NULL ELEMENTS
"RTN","MXMLTMP1",201,0)
 ; THEXML IS PASSED BY NAME
"RTN","MXMLTMP1",202,0)
 ; ZEXCEPT: MXMLDEBUG
"RTN","MXMLTMP1",203,0)
 N I,J,TMPXML,DEL,FOUND
"RTN","MXMLTMP1",204,0)
 S FOUND=0
"RTN","MXMLTMP1",205,0)
 I $G(MXMLDEBUG) D EN^DDIOL("DELETING EMPTY ELEMENTS")
"RTN","MXMLTMP1",206,0)
 F I=1:1:(@THEXML@(0)-1) D  ; LOOP THROUGH ENTIRE ARRAY
"RTN","MXMLTMP1",207,0)
 . S J=@THEXML@(I)
"RTN","MXMLTMP1",208,0)
 . N JM,JP,JPX ; JMINUS AND JPLUS
"RTN","MXMLTMP1",209,0)
 . S JM=@THEXML@(I-1) ; LINE BEFORE
"RTN","MXMLTMP1",210,0)
 . S JP=@THEXML@(I+1) ; LINE AFTER
"RTN","MXMLTMP1",211,0)
 . S JPX=$TR(JP,"/") ; REMOVE THE SLASH
"RTN","MXMLTMP1",212,0)
 . I J=JPX D  ; AN EMPTY ELEMENT ON TWO LINES (<tag>\n</tag>)
"RTN","MXMLTMP1",213,0)
 . . I $G(MXMLDEBUG) D EN^DDIOL(I_J_JP)
"RTN","MXMLTMP1",214,0)
 . . S FOUND=1 ; FOUND SOMETHING TO BE DELETED
"RTN","MXMLTMP1",215,0)
 . . S DEL(I)="" ; SET LINE TO DELETE
"RTN","MXMLTMP1",216,0)
 . . S DEL(I+1)="" ; SET NEXT LINE TO DELETE
"RTN","MXMLTMP1",217,0)
 . I J["><" D  ; AN EMPTY ELEMENT ON ONE LINE (<tag></tag>)
"RTN","MXMLTMP1",218,0)
 . . I $G(MXMLDEBUG) D EN^DDIOL(I_J)
"RTN","MXMLTMP1",219,0)
 . . S FOUND=1 ; FOUND SOMETHING TO BE DELETED
"RTN","MXMLTMP1",220,0)
 . . S DEL(I)="" ; SET THE EMPTY LINE UP TO BE DELETED
"RTN","MXMLTMP1",221,0)
 . . I JM=JPX D  ; if surrounding tags only contained us, and we're deleted, remove surrounding tags too.
"RTN","MXMLTMP1",222,0)
 . . . I $G(MXMLDEBUG) D EN^DDIOL(I_JM_J_JPX)
"RTN","MXMLTMP1",223,0)
 . . . S DEL(I-1)=""
"RTN","MXMLTMP1",224,0)
 . . . S DEL(I+1)="" ; SET THE SURROUNDING LINES FOR DEL
"RTN","MXMLTMP1",225,0)
 ; I J'["><" D PUSH("TMPXML",J)
"RTN","MXMLTMP1",226,0)
 I FOUND D  ; NEED TO DELETE THINGS
"RTN","MXMLTMP1",227,0)
 . F I=1:1:@THEXML@(0) D  ; COPY ARRAY LEAVING OUT DELELTED LINES
"RTN","MXMLTMP1",228,0)
 . . I '$D(DEL(I)) D  ; IF THE LINE IS NOT DELETED
"RTN","MXMLTMP1",229,0)
 . . . D PUSH("TMPXML",@THEXML@(I)) ; COPY TO TMPXML ARRAY
"RTN","MXMLTMP1",230,0)
 . D CP^MXMLTMPL("TMPXML",THEXML) ; REPLACE THE XML WITH THE COPY
"RTN","MXMLTMP1",231,0)
 Q:$Q FOUND Q
"RTN","MXMLTMP1",232,0)
 ;
"RTN","MXMLTMPL")
0^10^B113793891
"RTN","MXMLTMPL",1,0)
MXMLTMPL   ; VEN/GPL - XML templating utilities;2013-07-26  6:22 PM
"RTN","MXMLTMPL",2,0)
 ;;2.1;XML PROCESSING UTILITIES;;Nov 27, 2013;Build 9
"RTN","MXMLTMPL",3,0)
 ;
"RTN","MXMLTMPL",4,0)
QUERY(IARY,XPATH,OARY)  ; RETURNS THE XML ARRAY MATCHING THE XPATH EXPRESSION
"RTN","MXMLTMPL",5,0)
 ; XPATH IS OF THE FORM "//FIRST/SECOND/THIRD"
"RTN","MXMLTMPL",6,0)
 ; IARY AND OARY ARE PASSED BY NAME
"RTN","MXMLTMPL",7,0)
 I '$D(@IARY@("INDEXED"))  D  ; INDEX IS NOT PRESENT IN IARY
"RTN","MXMLTMPL",8,0)
 . D INDEX^MXMLTMP1(IARY) ; GENERATE AN INDEX FOR THE XML
"RTN","MXMLTMPL",9,0)
 N FIRST,LAST ; FIRST AND LAST LINES OF ARRAY TO RETURN
"RTN","MXMLTMPL",10,0)
 N TMP,I,J,QXPATH
"RTN","MXMLTMPL",11,0)
 S FIRST=1
"RTN","MXMLTMPL",12,0)
 I '$D(@IARY@(0)) D  ; LINE COUNT NOT IN ZERO NODE
"RTN","MXMLTMPL",13,0)
 . S @IARY@(0)=$O(@IARY@("//"),-1) ; THIS SHOULD USUALLY WORK
"RTN","MXMLTMPL",14,0)
 S LAST=@IARY@(0) ; FIRST AND LAST DEFAULT TO ROOT
"RTN","MXMLTMPL",15,0)
 I XPATH'="//" D  ; NOT A ROOT QUERY
"RTN","MXMLTMPL",16,0)
 . S TMP=@IARY@(XPATH) ; LOOK UP LINE VALUES
"RTN","MXMLTMPL",17,0)
 . S FIRST=$P(TMP,"^",1)
"RTN","MXMLTMPL",18,0)
 . S LAST=$P(TMP,"^",2)
"RTN","MXMLTMPL",19,0)
 K @OARY
"RTN","MXMLTMPL",20,0)
 S @OARY@(0)=+LAST-FIRST+1
"RTN","MXMLTMPL",21,0)
 S J=1
"RTN","MXMLTMPL",22,0)
 FOR I=FIRST:1:LAST  D
"RTN","MXMLTMPL",23,0)
 . S @OARY@(J)=@IARY@(I) ; COPY THE LINE TO OARY
"RTN","MXMLTMPL",24,0)
 . S J=J+1
"RTN","MXMLTMPL",25,0)
 ; ZWR OARY
"RTN","MXMLTMPL",26,0)
 Q
"RTN","MXMLTMPL",27,0)
 ;
"RTN","MXMLTMPL",28,0)
START(ISTR)     ; EXTRINSIC TO RETURN THE STARTING LINE FROM AN INDEX
"RTN","MXMLTMPL",29,0)
 ; TYPE STRING WITH THREE PIECES ARRAY;START;FINISH
"RTN","MXMLTMPL",30,0)
 ; COMPANION TO FINISH ; IDX IS PASSED BY NAME
"RTN","MXMLTMPL",31,0)
 Q $P(ISTR,";",2)
"RTN","MXMLTMPL",32,0)
 ;
"RTN","MXMLTMPL",33,0)
FINISH(ISTR)    ; EXTRINSIC TO RETURN THE LAST LINE FROM AN INDEX
"RTN","MXMLTMPL",34,0)
 ; TYPE STRING WITH THREE PIECES ARRAY;START;FINISH
"RTN","MXMLTMPL",35,0)
 Q $P(ISTR,";",3)
"RTN","MXMLTMPL",36,0)
 ;
"RTN","MXMLTMPL",37,0)
ARRAY(ISTR)     ; EXTRINSIC TO RETURN THE ARRAY REFERENCE FROM AN INDEX
"RTN","MXMLTMPL",38,0)
 ; TYPE STRING WITH THREE PIECES ARRAY;START;FINISH
"RTN","MXMLTMPL",39,0)
 Q $P(ISTR,";",1)
"RTN","MXMLTMPL",40,0)
 ;
"RTN","MXMLTMPL",41,0)
BUILD(BLIST,BDEST)      ; A COPY MACHINE THAT TAKE INSTRUCTIONS IN ARRAY BLIST
"RTN","MXMLTMPL",42,0)
 ; ZEXCEPT: MXMLDEBUG
"RTN","MXMLTMPL",43,0)
 ; WHICH HAVE ARRAY;START;FINISH AND COPIES THEM TO DEST
"RTN","MXMLTMPL",44,0)
 ; DEST IS CLEARED TO START
"RTN","MXMLTMPL",45,0)
 ; USES PUSH TO DO THE COPY
"RTN","MXMLTMPL",46,0)
 N I
"RTN","MXMLTMPL",47,0)
 K @BDEST
"RTN","MXMLTMPL",48,0)
 F I=1:1:@BLIST@(0) D  ; FOR EACH INSTRUCTION IN BLIST
"RTN","MXMLTMPL",49,0)
 . N J,ATMP
"RTN","MXMLTMPL",50,0)
 . S ATMP=$$ARRAY(@BLIST@(I))
"RTN","MXMLTMPL",51,0)
 . I $G(MXMLDEBUG) D EN^DDIOL("ATMP="_ATMP)
"RTN","MXMLTMPL",52,0)
 . I $G(MXMLDEBUG) D EN^DDIOL(@BLIST@(I))
"RTN","MXMLTMPL",53,0)
 . F J=$$START(@BLIST@(I)):1:$$FINISH(@BLIST@(I)) D  ;
"RTN","MXMLTMPL",54,0)
 . . ; FOR EACH LINE IN THIS INSTR
"RTN","MXMLTMPL",55,0)
 . . I $G(MXMLDEBUG) D EN^DDIOL("BDEST= "_BDEST)
"RTN","MXMLTMPL",56,0)
 . . I $G(MXMLDEBUG) D EN^DDIOL("ATMP= "_@ATMP@(J))
"RTN","MXMLTMPL",57,0)
 . . D PUSH^MXMLTMP1(BDEST,@ATMP@(J))
"RTN","MXMLTMPL",58,0)
 Q
"RTN","MXMLTMPL",59,0)
 ;
"RTN","MXMLTMPL",60,0)
QUEUE(BLST,ARRAY,FIRST,LAST)    ; ADD AN ENTRY TO A BLIST
"RTN","MXMLTMPL",61,0)
 ; ZEXCEPT: MXMLDEBUG
"RTN","MXMLTMPL",62,0)
 ;
"RTN","MXMLTMPL",63,0)
 I $G(MXMLDEBUG) D EN^DDIOL("QUEUEING "_BLST)
"RTN","MXMLTMPL",64,0)
 D PUSH^MXMLTMP1(BLST,ARRAY_";"_FIRST_";"_LAST)
"RTN","MXMLTMPL",65,0)
 Q
"RTN","MXMLTMPL",66,0)
 ;
"RTN","MXMLTMPL",67,0)
CP(CPSRC,CPDEST)        ; COPIES CPSRC TO CPDEST BOTH PASSED BY NAME
"RTN","MXMLTMPL",68,0)
 ; ZEXCEPT: MXMLDEBUG
"RTN","MXMLTMPL",69,0)
 ; KILLS CPDEST FIRST
"RTN","MXMLTMPL",70,0)
 N CPINSTR
"RTN","MXMLTMPL",71,0)
 I $G(MXMLDEBUG) D EN^DDIOL("MADE IT TO COPY "_CPSRC_" TO "_CPDEST)
"RTN","MXMLTMPL",72,0)
 I @CPSRC@(0)<1 D  QUIT  ; BAD LENGTH
"RTN","MXMLTMPL",73,0)
 . D EN^DDIOL("ERROR IN COPY BAD SOURCE LENGTH: "_CPSRC)
"RTN","MXMLTMPL",74,0)
 ; I '$D(@CPDEST@(0)) S @CPDEST@(0)=0 ; IF THE DEST IS EMPTY, INIT
"RTN","MXMLTMPL",75,0)
 D QUEUE("CPINSTR",CPSRC,1,@CPSRC@(0)) ; BLIST FOR ENTIRE ARRAY
"RTN","MXMLTMPL",76,0)
 D BUILD("CPINSTR",CPDEST)
"RTN","MXMLTMPL",77,0)
 Q
"RTN","MXMLTMPL",78,0)
 ;
"RTN","MXMLTMPL",79,0)
QOPEN(QOBLIST,QOXML,QOXPATH)    ; ADD ALL BUT THE LAST LINE OF QOXML TO QOBLIST
"RTN","MXMLTMPL",80,0)
 ; ZEXCEPT: MXMLDEBUG
"RTN","MXMLTMPL",81,0)
 ; WARNING NEED TO DO QCLOSE FOR SAME XML BEFORE CALLING BUILD
"RTN","MXMLTMPL",82,0)
 ; QOXPATH IS OPTIONAL - WILL OPEN INSIDE THE XPATH POINT
"RTN","MXMLTMPL",83,0)
 ; USED TO INSERT CHILDREN NODES
"RTN","MXMLTMPL",84,0)
 I @QOXML@(0)<1 D  QUIT  ; MALFORMED XML
"RTN","MXMLTMPL",85,0)
 . D EN^DDIOL("MALFORMED XML PASSED TO QOPEN: "_QOXML)
"RTN","MXMLTMPL",86,0)
 I $G(MXMLDEBUG) D EN^DDIOL("DOING QOPEN")
"RTN","MXMLTMPL",87,0)
 N S1,E1,QOT,QOTMP
"RTN","MXMLTMPL",88,0)
 S S1=1 ; OPEN FROM THE BEGINNING OF THE XML
"RTN","MXMLTMPL",89,0)
 I $D(QOXPATH) D  ; XPATH PROVIDED
"RTN","MXMLTMPL",90,0)
 . D QUERY(QOXML,QOXPATH,"QOT") ; INSURE INDEX
"RTN","MXMLTMPL",91,0)
 . S E1=$P(@QOXML@(QOXPATH),"^",2)-1
"RTN","MXMLTMPL",92,0)
 I '$D(QOXPATH) D  ; NO XPATH PROVIDED, OPEN AT ROOT
"RTN","MXMLTMPL",93,0)
 . S E1=@QOXML@(0)-1
"RTN","MXMLTMPL",94,0)
 D QUEUE(QOBLIST,QOXML,S1,E1)
"RTN","MXMLTMPL",95,0)
 ; S QOTMP=QOXML_"^"_S1_"^"_E1
"RTN","MXMLTMPL",96,0)
 ; D PUSH(QOBLIST,QOTMP)
"RTN","MXMLTMPL",97,0)
 Q
"RTN","MXMLTMPL",98,0)
 ;
"RTN","MXMLTMPL",99,0)
QCLOSE(QCBLIST,QCXML,QCXPATH)   ; CLOSE XML AFTER A QOPEN
"RTN","MXMLTMPL",100,0)
 ; ZEXCEPT: MXMLDEBUG
"RTN","MXMLTMPL",101,0)
 ; ADDS THE LIST LINE OF QCXML TO QCBLIST
"RTN","MXMLTMPL",102,0)
 ; USED TO FINISH INSERTING CHILDERN NODES
"RTN","MXMLTMPL",103,0)
 ; QCXPATH IS OPTIONAL - IF PROVIDED, WILL CLOSE UNTIL THE END
"RTN","MXMLTMPL",104,0)
 ; IF QOPEN WAS CALLED WITH XPATH, QCLOSE SHOULD BE TOO
"RTN","MXMLTMPL",105,0)
 I @QCXML@(0)<1 D  QUIT  ; MALFORMED XML
"RTN","MXMLTMPL",106,0)
 . D EN^DDIOL("MALFORMED XML PASSED TO QCLOSE: "_QCXML)
"RTN","MXMLTMPL",107,0)
 I $G(MXMLDEBUG) D EN^DDIOL("GOING TO CLOSE")
"RTN","MXMLTMPL",108,0)
 N S1,E1,QCT,QCTMP
"RTN","MXMLTMPL",109,0)
 S E1=@QCXML@(0) ; CLOSE UNTIL THE END OF THE XML
"RTN","MXMLTMPL",110,0)
 I $D(QCXPATH) D  ; XPATH PROVIDED
"RTN","MXMLTMPL",111,0)
 . D QUERY(QCXML,QCXPATH,"QCT") ; INSURE INDEX
"RTN","MXMLTMPL",112,0)
 . S S1=$P(@QCXML@(QCXPATH),"^",2) ; REMAINING XML
"RTN","MXMLTMPL",113,0)
 I '$D(QCXPATH) D  ; NO XPATH PROVIDED, CLOSE AT ROOT
"RTN","MXMLTMPL",114,0)
 . S S1=@QCXML@(0)
"RTN","MXMLTMPL",115,0)
 D QUEUE(QCBLIST,QCXML,S1,E1)
"RTN","MXMLTMPL",116,0)
 ; D PUSH(QCBLIST,QCXML_";"_S1_";"_E1)
"RTN","MXMLTMPL",117,0)
 Q
"RTN","MXMLTMPL",118,0)
 ;
"RTN","MXMLTMPL",119,0)
INSERT(INSXML,INSNEW,INSXPATH)  ; INSERT INSNEW INTO INSXML AT THE
"RTN","MXMLTMPL",120,0)
 ; ZEXCEPT: MXMLDEBUG
"RTN","MXMLTMPL",121,0)
 ; INSXPATH XPATH POINT INSXPATH IS OPTIONAL - IF IT IS
"RTN","MXMLTMPL",122,0)
 ; OMITTED, INSERTION WILL BE AT THE ROOT
"RTN","MXMLTMPL",123,0)
 ; NOTE INSERT IS NON DESTRUCTIVE AND WILL ADD THE NEW
"RTN","MXMLTMPL",124,0)
 ; XML AT THE END OF THE XPATH POINT
"RTN","MXMLTMPL",125,0)
 ; INSXML AND INSNEW ARE PASSED BY NAME INSXPATH IS A VALUE
"RTN","MXMLTMPL",126,0)
 N INSBLD,INSTMP
"RTN","MXMLTMPL",127,0)
 I $G(MXMLDEBUG) D EN^DDIOL("DOING INSERT "_INSXML_" "_INSNEW_" "_INSXPATH)
"RTN","MXMLTMPL",128,0)
 I $G(MXMLDEBUG),$O(@INSXML@("")) N G1 F G1=1:1:@INSXML@(0) D EN^DDIOL(@INSXML@(G1))
"RTN","MXMLTMPL",129,0)
 I '$D(@INSXML@(1)) D  QUIT  ; INSERT INTO AN EMPTY ARRAY
"RTN","MXMLTMPL",130,0)
 . D CP^MXMLTMPL(INSNEW,INSXML) ; JUST COPY INTO THE OUTPUT
"RTN","MXMLTMPL",131,0)
 I $D(@INSXML@(1)) D  ; IF ORIGINAL ARRAY IS NOT EMPTY
"RTN","MXMLTMPL",132,0)
 . I '$D(@INSXML@(0)) S @INSXML@(0)=$O(@INSXML@(""),-1) ;SET LENGTH
"RTN","MXMLTMPL",133,0)
 . I $D(INSXPATH) D  ; XPATH PROVIDED
"RTN","MXMLTMPL",134,0)
 . . D QOPEN("INSBLD",INSXML,INSXPATH) ; COPY THE BEFORE
"RTN","MXMLTMPL",135,0)
 . . I $G(MXMLDEBUG) D PARY^MXMLTMPL("INSBLD")
"RTN","MXMLTMPL",136,0)
 . I '$D(INSXPATH) D  ; NO XPATH PROVIDED, OPEN AT ROOT
"RTN","MXMLTMPL",137,0)
 . . D QOPEN("INSBLD",INSXML,"//") ; OPEN WITH ROOT XPATH
"RTN","MXMLTMPL",138,0)
 . I '$D(@INSNEW@(0)) S @INSNEW@(0)=$O(@INSNEW@(""),-1) ;SIZE OF XML
"RTN","MXMLTMPL",139,0)
 . D QUEUE("INSBLD",INSNEW,1,@INSNEW@(0)) ; COPY IN NEW XML
"RTN","MXMLTMPL",140,0)
 . I $D(INSXPATH) D  ; XPATH PROVIDED
"RTN","MXMLTMPL",141,0)
 . . D QCLOSE("INSBLD",INSXML,INSXPATH) ; CLOSE WITH XPATH
"RTN","MXMLTMPL",142,0)
 . I '$D(INSXPATH) D  ; NO XPATH PROVIDED, CLOSE AT ROOT
"RTN","MXMLTMPL",143,0)
 . . D QCLOSE("INSBLD",INSXML,"//") ; CLOSE WITH ROOT XPATH
"RTN","MXMLTMPL",144,0)
 . D BUILD("INSBLD","INSTMP") ; PUT RESULTS IN INDEST
"RTN","MXMLTMPL",145,0)
 . D CP^MXMLTMPL("INSTMP",INSXML) ; COPY BUFFER TO SOURCE
"RTN","MXMLTMPL",146,0)
 Q
"RTN","MXMLTMPL",147,0)
 ;
"RTN","MXMLTMPL",148,0)
INSINNER(INNXML,INNNEW,INNXPATH)        ; INSERT THE INNER XML OF INNNEW
"RTN","MXMLTMPL",149,0)
 ; INTO INNXML AT THE INNXPATH XPATH POINT
"RTN","MXMLTMPL",150,0)
 ;
"RTN","MXMLTMPL",151,0)
 N INNBLD,UXPATH
"RTN","MXMLTMPL",152,0)
 N INNTBUF
"RTN","MXMLTMPL",153,0)
 S INNTBUF=$NA(^TMP($J,"INNTBUF"))
"RTN","MXMLTMPL",154,0)
 K @INNTBUF
"RTN","MXMLTMPL",155,0)
 I '$D(INNXPATH) D  ; XPATH NOT PASSED
"RTN","MXMLTMPL",156,0)
 . S UXPATH="//" ; USE ROOT XPATH
"RTN","MXMLTMPL",157,0)
 I $D(INNXPATH) S UXPATH=INNXPATH ; USE THE XPATH THAT'S PASSED
"RTN","MXMLTMPL",158,0)
 I '$D(@INNXML@(0)) D  ; INNXML IS EMPTY
"RTN","MXMLTMPL",159,0)
 . D QUEUE^MXMLTMPL("INNBLD",INNNEW,2,@INNNEW@(0)-1) ; JUST INNER
"RTN","MXMLTMPL",160,0)
 . D BUILD("INNBLD",INNXML)
"RTN","MXMLTMPL",161,0)
 I @INNXML@(0)>0  D  ; NOT EMPTY
"RTN","MXMLTMPL",162,0)
 . D QOPEN("INNBLD",INNXML,UXPATH) ;
"RTN","MXMLTMPL",163,0)
 . D QUEUE("INNBLD",INNNEW,2,@INNNEW@(0)-1) ; JUST INNER XML
"RTN","MXMLTMPL",164,0)
 . D QCLOSE("INNBLD",INNXML,UXPATH)
"RTN","MXMLTMPL",165,0)
 . D BUILD("INNBLD",INNTBUF) ; BUILD TO BUFFER
"RTN","MXMLTMPL",166,0)
 . D CP(INNTBUF,INNXML) ; COPY BUFFER TO DEST
"RTN","MXMLTMPL",167,0)
 K @INNTBUF
"RTN","MXMLTMPL",168,0)
 Q
"RTN","MXMLTMPL",169,0)
 ;
"RTN","MXMLTMPL",170,0)
INSB4(XDEST,XNEW) ; INSERT XNEW AT THE BEGINNING OF XDEST
"RTN","MXMLTMPL",171,0)
 ; ZEXCEPT: MXMLDEBUG
"RTN","MXMLTMPL",172,0)
 ; BUT XDEST AN XNEW ARE PASSED BY NAME
"RTN","MXMLTMPL",173,0)
 N XBLD,XTMP
"RTN","MXMLTMPL",174,0)
 D QUEUE("XBLD",XDEST,1,1) ; NEED TO PRESERVE SECTION ROOT
"RTN","MXMLTMPL",175,0)
 D QUEUE("XBLD",XNEW,1,@XNEW@(0)) ; ALL OF NEW XML FIRST
"RTN","MXMLTMPL",176,0)
 D QUEUE("XBLD",XDEST,2,@XDEST@(0)) ; FOLLOWED BY THE REST OF SECTION
"RTN","MXMLTMPL",177,0)
 D BUILD("XBLD","XTMP") ; BUILD THE RESULT
"RTN","MXMLTMPL",178,0)
 D CP("XTMP",XDEST) ; COPY TO THE DESTINATION
"RTN","MXMLTMPL",179,0)
 I $G(MXMLDEBUG) D PARY("XDEST")
"RTN","MXMLTMPL",180,0)
 Q
"RTN","MXMLTMPL",181,0)
 ;
"RTN","MXMLTMPL",182,0)
REPLACE(REXML,RENEW,REXPATH)    ; REPLACE THE XML AT THE XPATH POINT
"RTN","MXMLTMPL",183,0)
 ; ZEXCEPT: MXMLDEBUG
"RTN","MXMLTMPL",184,0)
 ; WITH RENEW - NOTE THIS WILL DELETE WHAT WAS THERE BEFORE
"RTN","MXMLTMPL",185,0)
 ; REXML AND RENEW ARE PASSED BY NAME XPATH IS A VALUE
"RTN","MXMLTMPL",186,0)
 ; THE DELETED XML IS PUT IN ^TMP($J,"REPLACE_OLD")
"RTN","MXMLTMPL",187,0)
 N REBLD,XFIRST,XLAST,OLD,XNODE,RTMP
"RTN","MXMLTMPL",188,0)
 S OLD=$NA(^TMP($J,"REPLACE_OLD"))
"RTN","MXMLTMPL",189,0)
 K @OLD
"RTN","MXMLTMPL",190,0)
 D QUERY(REXML,REXPATH,OLD) ; CREATE INDEX, TEST XPATH, MAKE OLD
"RTN","MXMLTMPL",191,0)
 S XNODE=@REXML@(REXPATH) ; PULL OUT FIRST AND LAST LINE PTRS
"RTN","MXMLTMPL",192,0)
 S XFIRST=$P(XNODE,"^",1)
"RTN","MXMLTMPL",193,0)
 S XLAST=$P(XNODE,"^",2)
"RTN","MXMLTMPL",194,0)
 I RENEW="" D  ; WE ARE DELETING A SECTION, MUST SAVE THE TAG
"RTN","MXMLTMPL",195,0)
 . D QUEUE("REBLD",REXML,1,XFIRST) ; THE BEFORE
"RTN","MXMLTMPL",196,0)
 . D QUEUE("REBLD",REXML,XLAST,@REXML@(0)) ; THE REST
"RTN","MXMLTMPL",197,0)
 I RENEW'="" D  ; NEW XML IS NOT NULL
"RTN","MXMLTMPL",198,0)
 . D QUEUE("REBLD",REXML,1,XFIRST-1) ; THE BEFORE
"RTN","MXMLTMPL",199,0)
 . D QUEUE("REBLD",RENEW,1,@RENEW@(0)) ; THE NEW
"RTN","MXMLTMPL",200,0)
 . D QUEUE("REBLD",REXML,XLAST+1,@REXML@(0)) ; THE REST
"RTN","MXMLTMPL",201,0)
 I $G(MXMLDEBUG) D EN^DDIOL("REPLACE PREBUILD")
"RTN","MXMLTMPL",202,0)
 I $G(MXMLDEBUG) D PARY("REBLD")
"RTN","MXMLTMPL",203,0)
 D BUILD("REBLD","RTMP")
"RTN","MXMLTMPL",204,0)
 K @REXML ; KILL WHAT WAS THERE
"RTN","MXMLTMPL",205,0)
 D CP("RTMP",REXML) ; COPY IN THE RESULT
"RTN","MXMLTMPL",206,0)
 K @OLD
"RTN","MXMLTMPL",207,0)
 Q
"RTN","MXMLTMPL",208,0)
 ;
"RTN","MXMLTMPL",209,0)
DELETE(REXML,REXPATH)    ; DELETE THE XML AT THE XPATH POINT
"RTN","MXMLTMPL",210,0)
 ; ZEXCEPT: MXMLDEBUG
"RTN","MXMLTMPL",211,0)
 ; REXML IS PASSED BY NAME XPATH IS A VALUE
"RTN","MXMLTMPL",212,0)
 N REBLD,XFIRST,XLAST,OLD,XNODE,RTMP
"RTN","MXMLTMPL",213,0)
 S OLD=$NA(^TMP($J,"REPLACE_OLD"))
"RTN","MXMLTMPL",214,0)
 K @OLD
"RTN","MXMLTMPL",215,0)
 D QUERY(REXML,REXPATH,OLD) ; CREATE INDEX, TEST XPATH, MAKE OLD
"RTN","MXMLTMPL",216,0)
 S XNODE=@REXML@(REXPATH) ; PULL OUT FIRST AND LAST LINE PTRS
"RTN","MXMLTMPL",217,0)
 S XFIRST=$P(XNODE,"^",1)
"RTN","MXMLTMPL",218,0)
 S XLAST=$P(XNODE,"^",2)
"RTN","MXMLTMPL",219,0)
 D QUEUE("REBLD",REXML,1,XFIRST-1) ; THE BEFORE
"RTN","MXMLTMPL",220,0)
 D QUEUE("REBLD",REXML,XLAST+1,@REXML@(0)) ; THE REST
"RTN","MXMLTMPL",221,0)
 I $G(MXMLDEBUG) D PARY("REBLD")
"RTN","MXMLTMPL",222,0)
 D BUILD("REBLD","RTMP")
"RTN","MXMLTMPL",223,0)
 K @REXML ; KILL WHAT WAS THERE
"RTN","MXMLTMPL",224,0)
 D CP("RTMP",REXML) ; COPY IN THE RESULT
"RTN","MXMLTMPL",225,0)
 K @OLD
"RTN","MXMLTMPL",226,0)
 Q
"RTN","MXMLTMPL",227,0)
 ;
"RTN","MXMLTMPL",228,0)
MISSING(IXML,OARY)      ; SEARTH THROUGH INXLM AND PUT ANY @@X@@ VARS IN OARY
"RTN","MXMLTMPL",229,0)
 ; W "Reporting on the missing",!
"RTN","MXMLTMPL",230,0)
 ; W OARY
"RTN","MXMLTMPL",231,0)
 I '$D(@IXML@(0)) D EN^DDIOL("MALFORMED XML PASSED TO MISSING") Q
"RTN","MXMLTMPL",232,0)
 N I
"RTN","MXMLTMPL",233,0)
 S @OARY@(0)=0 ; INITIALIZED MISSING COUNT
"RTN","MXMLTMPL",234,0)
 F I=1:1:@IXML@(0)  D   ; LOOP THROUGH WHOLE ARRAY
"RTN","MXMLTMPL",235,0)
 . I @IXML@(I)?.E1"@@".E D  ; MISSING VARIABLE HERE
"RTN","MXMLTMPL",236,0)
 . . D PUSH^MXMLTMP1(OARY,$P(@IXML@(I),"@@",2)) ; ADD TO OUTARY
"RTN","MXMLTMPL",237,0)
 . . Q
"RTN","MXMLTMPL",238,0)
 Q
"RTN","MXMLTMPL",239,0)
 ;
"RTN","MXMLTMPL",240,0)
MAP(IXML,INARY,OXML) ; SUBSTITUTE MULTIPLE @@X@@ VARS WITH VALUES IN INARY
"RTN","MXMLTMPL",241,0)
 ; ZEXCEPT: MXMLDEBUG
"RTN","MXMLTMPL",242,0)
 ; AND PUT THE RESULTS IN OXML
"RTN","MXMLTMPL",243,0)
 N XCNT
"RTN","MXMLTMPL",244,0)
 I '$D(IXML) D EN^DDIOL("MALFORMED XML PASSED TO MAP") Q
"RTN","MXMLTMPL",245,0)
 I '$D(@IXML@(0)) D  ; INITIALIZE COUNT
"RTN","MXMLTMPL",246,0)
 . S XCNT=$O(@IXML@(""),-1)
"RTN","MXMLTMPL",247,0)
 E  S XCNT=@IXML@(0) ;COUNT
"RTN","MXMLTMPL",248,0)
 I $O(@INARY@(""))="" D EN^DDIOL("EMPTY ARRAY PASSED TO MAP") Q
"RTN","MXMLTMPL",249,0)
 N I,J,TNAM,TVAL,TSTR
"RTN","MXMLTMPL",250,0)
 S @OXML@(0)=XCNT ; TOTAL LINES IN OUTPUT
"RTN","MXMLTMPL",251,0)
 F I=1:1:XCNT  D   ; LOOP THROUGH WHOLE ARRAY
"RTN","MXMLTMPL",252,0)
 . S @OXML@(I)=@IXML@(I) ; COPY THE LINE TO OUTPUT
"RTN","MXMLTMPL",253,0)
 . I @OXML@(I)?.E1"@@".E D  ; IS THERE A VARIABLE HERE?
"RTN","MXMLTMPL",254,0)
 . . S TSTR=$P(@IXML@(I),"@@",1) ; INIT TO PART BEFORE VARS
"RTN","MXMLTMPL",255,0)
 . . F J=2:2:10  D  Q:$P(@IXML@(I),"@@",J+2)=""  ; QUIT IF NO MORE VARS
"RTN","MXMLTMPL",256,0)
 . . . I $G(MXMLDEBUG) D EN^DDIOL("IN MAPPING LOOP: "_TSTR)
"RTN","MXMLTMPL",257,0)
 . . . S TNAM=$P(@OXML@(I),"@@",J) ; EXTRACT THE VARIABLE NAME
"RTN","MXMLTMPL",258,0)
 . . . S TVAL="@@"_$P(@IXML@(I),"@@",J)_"@@" ; DEFAULT UNCHANGED
"RTN","MXMLTMPL",259,0)
 . . . I $D(@INARY@(TNAM))  D  ; IS THE VARIABLE IN THE MAP?
"RTN","MXMLTMPL",260,0)
 . . . . I '$D(@INARY@(TNAM,"F")) D  ; NOT A SPECIAL FIELD
"RTN","MXMLTMPL",261,0)
 . . . . . S TVAL=@INARY@(TNAM) ; PULL OUT MAPPED VALUE
"RTN","MXMLTMPL",262,0)
 . . . . E   ; PROCESS A FILEMAN FIELD
"RTN","MXMLTMPL",263,0)
 . . . S TVAL=$$SYMENC^MXMLUTL(TVAL) ;MAKE SURE THE VALUE IS XML SAFE
"RTN","MXMLTMPL",264,0)
 . . . S TSTR=TSTR_TVAL_$P(@IXML@(I),"@@",J+1) ; ADD VAR AND PART AFTER
"RTN","MXMLTMPL",265,0)
 . . S @OXML@(I)=TSTR ; COPY LINE WITH MAPPED VALUES
"RTN","MXMLTMPL",266,0)
 . . I $G(MXMLDEBUG) D EN^DDIOL(TSTR)
"RTN","MXMLTMPL",267,0)
 I $G(MXMLDEBUG) D EN^DDIOL("MAPPED")
"RTN","MXMLTMPL",268,0)
 Q
"RTN","MXMLTMPL",269,0)
 ;
"RTN","MXMLTMPL",270,0)
PARY(GLO,ZN)       ;PRINT AN ARRAY
"RTN","MXMLTMPL",271,0)
 ; IF ZN=-1 NO LINE NUMBERS
"RTN","MXMLTMPL",272,0)
 N I
"RTN","MXMLTMPL",273,0)
 F I=1:1:@GLO@(0) D  ;
"RTN","MXMLTMPL",274,0)
 . I $G(ZN)=-1 D EN^DDIOL(@GLO@(I))
"RTN","MXMLTMPL",275,0)
 . E  D EN^DDIOL(I_" "_@GLO@(I))
"RTN","MXMLTMPL",276,0)
 Q
"RTN","MXMLTMPL",277,0)
 ;
"RTN","MXMLTMPL",278,0)
H2ARY(IARYRTN,IHASH,IPRE) ; CONVERT IHASH TO RETURN ARRAY
"RTN","MXMLTMPL",279,0)
 ; IPRE IS OPTIONAL PREFIX FOR THE ELEMENTS. USED FOR MUPTIPLES 1^"VAR"^VALUE
"RTN","MXMLTMPL",280,0)
 I '$D(IPRE) S IPRE=""
"RTN","MXMLTMPL",281,0)
 N H2I S H2I=""
"RTN","MXMLTMPL",282,0)
 ; W $O(@IHASH@(H2I)),!
"RTN","MXMLTMPL",283,0)
 F  S H2I=$O(@IHASH@(H2I)) Q:H2I=""  D  ; FOR EACH ELEMENT OF THE HASH
"RTN","MXMLTMPL",284,0)
 . I $QS(H2I,$QL(H2I))="M" D  Q  ; SPECIAL CASE FOR MULTIPLES
"RTN","MXMLTMPL",285,0)
 . . ;W H2I_"^"_@IHASH@(H2I),!
"RTN","MXMLTMPL",286,0)
 . . N IH,IHI,IH2,IH2A,IH3
"RTN","MXMLTMPL",287,0)
 . . S IH=$NA(@IHASH@(H2I)) ;
"RTN","MXMLTMPL",288,0)
 . . S IH2A=$O(@IH@("")) ; SKIP OVER MULTIPLE DISCRIPTOR
"RTN","MXMLTMPL",289,0)
 . . S IH2=$NA(@IH@(IH2A)) ; PAST THE "M","DIRETIONS" FOR EXAMPLE
"RTN","MXMLTMPL",290,0)
 . . S IHI="" ; INDEX INTO "M" MULTIPLES
"RTN","MXMLTMPL",291,0)
 . . F  S IHI=$O(@IH2@(IHI)) Q:IHI=""  D  ; FOR EACH SUB-MULTIPLE
"RTN","MXMLTMPL",292,0)
 . . . ; W @IH@(IHI)
"RTN","MXMLTMPL",293,0)
 . . . S IH3=$NA(@IH2@(IHI))
"RTN","MXMLTMPL",294,0)
 . . . ; W "HEY",IH3,!
"RTN","MXMLTMPL",295,0)
 . . . D H2ARY(.IARYRTN,IH3,IPRE_";"_IHI) ; RECURSIVE CALL - INDENTED ELEMENTS
"RTN","MXMLTMPL",296,0)
 . . ; W IH,!
"RTN","MXMLTMPL",297,0)
 . . ; W "C0CZZ",!
"RTN","MXMLTMPL",298,0)
 . . ; W $NA(@IHASH@(H2I)),!
"RTN","MXMLTMPL",299,0)
 . . Q  ;
"RTN","MXMLTMPL",300,0)
 . D PUSH^MXMLTMP1(IARYRTN,IPRE_"^"_H2I_"^"_@IHASH@(H2I))
"RTN","MXMLTMPL",301,0)
 . ; W @IARYRTN@(0),!
"RTN","MXMLTMPL",302,0)
 Q
"RTN","MXMLTMPL",303,0)
 ;
"RTN","MXMLTMPL",304,0)
XVARS(XVRTN,XVIXML) ; RETURNS AN ARRAY XVRTN OF ALL UNIQUE VARIABLES
"RTN","MXMLTMPL",305,0)
 ; DEFINED IN INPUT XML XVIXML BY @@VAR@@
"RTN","MXMLTMPL",306,0)
 ; XVRTN AND XVIXML ARE PASSED BY NAME
"RTN","MXMLTMPL",307,0)
 ;
"RTN","MXMLTMPL",308,0)
 N XVI,XVTMP,XVT
"RTN","MXMLTMPL",309,0)
 F XVI=1:1:@XVIXML@(0) D  ; FOR ALL LINES OF THE XML
"RTN","MXMLTMPL",310,0)
 . S XVT=@XVIXML@(XVI)
"RTN","MXMLTMPL",311,0)
 . I XVT["@@" S XVTMP($P(XVT,"@@",2))=XVI
"RTN","MXMLTMPL",312,0)
 D H2ARY(XVRTN,"XVTMP")
"RTN","MXMLTMPL",313,0)
 Q
"RTN","MXMLTMPL",314,0)
 ;
"RTN","MXMLTMPL",315,0)
DXVARS(DXIN) ;DISPLAY ALL VARIABLES IN A TEMPLATE
"RTN","MXMLTMPL",316,0)
 N DVARS ; PUT VARIABLE NAME RESULTS IN ARRAY HERE
"RTN","MXMLTMPL",317,0)
 D XVARS("DVARS",DXIN) ; PULL OUT VARS
"RTN","MXMLTMPL",318,0)
 D PARY^MXMLTMPL("DVARS") ;AND DISPLAY THEM
"RTN","MXMLTMPL",319,0)
 Q
"RTN","MXMLTMPL",320,0)
 ;
"RTN","MXMLTMPL",321,0)
TEST ; Run all the test cases
"RTN","MXMLTMPL",322,0)
 D TEST^MXMLTMPT QUIT
"RTN","MXMLTMPT")
0^11^B205394209
"RTN","MXMLTMPT",1,0)
MXMLTMPT   ; VEN/GPL/SMH - XML Templater TEST CASES ;2013-08-13  12:00 PM
"RTN","MXMLTMPT",2,0)
 ;;2.1;XML PROCESSING UTILITIES;;Nov 27, 2013;Build 9
"RTN","MXMLTMPT",3,0)
TEST ; M-Unit Entry point for Unit Testing
"RTN","MXMLTMPT",4,0)
 S IO=$PRINCIPAL
"RTN","MXMLTMPT",5,0)
 N DIQUIET S DIQUIET=1
"RTN","MXMLTMPT",6,0)
 D DT^DICRW
"RTN","MXMLTMPT",7,0)
 D:$L($T(EN^XTMUNIT)) EN^XTMUNIT($T(+0),1)
"RTN","MXMLTMPT",8,0)
 QUIT
"RTN","MXMLTMPT",9,0)
 ;
"RTN","MXMLTMPT",10,0)
STARTUP ; M-Unit Start-up
"RTN","MXMLTMPT",11,0)
 QUIT
"RTN","MXMLTMPT",12,0)
 ;
"RTN","MXMLTMPT",13,0)
SHUTDOWN ; M-Unit Stop
"RTN","MXMLTMPT",14,0)
 QUIT
"RTN","MXMLTMPT",15,0)
 ;
"RTN","MXMLTMPT",16,0)
SETUP ; M-Unit each Step set-up
"RTN","MXMLTMPT",17,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",18,0)
 K MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",19,0)
 DO INITXML0,INITXML1,INITXML2
"RTN","MXMLTMPT",20,0)
 QUIT
"RTN","MXMLTMPT",21,0)
 ;
"RTN","MXMLTMPT",22,0)
TEARDOWN ; M-Unit each Step Tear-down
"RTN","MXMLTMPT",23,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",24,0)
 K MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",25,0)
 QUIT
"RTN","MXMLTMPT",26,0)
 ;
"RTN","MXMLTMPT",27,0)
INITXML0 ; Init 1
"RTN","MXMLTMPT",28,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",29,0)
 D PUSH^MXMLTMP1($NA(MXMLARR0),"FIRST")
"RTN","MXMLTMPT",30,0)
 D PUSH^MXMLTMP1($NA(MXMLARR0),"SECOND")
"RTN","MXMLTMPT",31,0)
 D PUSH^MXMLTMP1($NA(MXMLARR0),"THIRD")
"RTN","MXMLTMPT",32,0)
 D PUSH^MXMLTMP1($NA(MXMLARR0),"FOURTH")
"RTN","MXMLTMPT",33,0)
 QUIT
"RTN","MXMLTMPT",34,0)
 ;
"RTN","MXMLTMPT",35,0)
INITXML1 ; Init 2
"RTN","MXMLTMPT",36,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",37,0)
 D PUSH^MXMLTMP1($NA(MXMLARR1),"<FIRST>")
"RTN","MXMLTMPT",38,0)
 D PUSH^MXMLTMP1($NA(MXMLARR1),"<SECOND>")
"RTN","MXMLTMPT",39,0)
 D PUSH^MXMLTMP1($NA(MXMLARR1),"<THIRD>")
"RTN","MXMLTMPT",40,0)
 D PUSH^MXMLTMP1($NA(MXMLARR1),"<FOURTH>@@DATA1@@</FOURTH>")
"RTN","MXMLTMPT",41,0)
 D PUSH^MXMLTMP1($NA(MXMLARR1),"<FIFTH>")
"RTN","MXMLTMPT",42,0)
 D PUSH^MXMLTMP1($NA(MXMLARR1),"@@DATA2@@")
"RTN","MXMLTMPT",43,0)
 D PUSH^MXMLTMP1($NA(MXMLARR1),"</FIFTH>")
"RTN","MXMLTMPT",44,0)
 D PUSH^MXMLTMP1($NA(MXMLARR1),"<SIXTH ID=""SELF"" />")
"RTN","MXMLTMPT",45,0)
 D PUSH^MXMLTMP1($NA(MXMLARR1),"</THIRD>")
"RTN","MXMLTMPT",46,0)
 D PUSH^MXMLTMP1($NA(MXMLARR1),"<SECOND>")
"RTN","MXMLTMPT",47,0)
 D PUSH^MXMLTMP1($NA(MXMLARR1),"</SECOND>")
"RTN","MXMLTMPT",48,0)
 D PUSH^MXMLTMP1($NA(MXMLARR1),"</SECOND>")
"RTN","MXMLTMPT",49,0)
 D PUSH^MXMLTMP1($NA(MXMLARR1),"</FIRST>")
"RTN","MXMLTMPT",50,0)
 QUIT
"RTN","MXMLTMPT",51,0)
INITXML2 ; Init 3
"RTN","MXMLTMPT",52,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",53,0)
 D PUSH^MXMLTMP1($NA(MXMLARR2),"<FIRST>")
"RTN","MXMLTMPT",54,0)
 D PUSH^MXMLTMP1($NA(MXMLARR2),"<SECOND>")
"RTN","MXMLTMPT",55,0)
 D PUSH^MXMLTMP1($NA(MXMLARR2),"<THIRD>")
"RTN","MXMLTMPT",56,0)
 D PUSH^MXMLTMP1($NA(MXMLARR2),"<FOURTH>DATA1</FOURTH>")
"RTN","MXMLTMPT",57,0)
 D PUSH^MXMLTMP1($NA(MXMLARR2),"<FOURTH>")
"RTN","MXMLTMPT",58,0)
 D PUSH^MXMLTMP1($NA(MXMLARR2),"DATA2")
"RTN","MXMLTMPT",59,0)
 D PUSH^MXMLTMP1($NA(MXMLARR2),"</FOURTH>")
"RTN","MXMLTMPT",60,0)
 D PUSH^MXMLTMP1($NA(MXMLARR2),"</THIRD>")
"RTN","MXMLTMPT",61,0)
 D PUSH^MXMLTMP1($NA(MXMLARR2),"<_SECOND>")
"RTN","MXMLTMPT",62,0)
 D PUSH^MXMLTMP1($NA(MXMLARR2),"<FOURTH>DATA3</FOURTH>")
"RTN","MXMLTMPT",63,0)
 D PUSH^MXMLTMP1($NA(MXMLARR2),"</_SECOND>")
"RTN","MXMLTMPT",64,0)
 D PUSH^MXMLTMP1($NA(MXMLARR2),"</SECOND>")
"RTN","MXMLTMPT",65,0)
 D PUSH^MXMLTMP1($NA(MXMLARR2),"</FIRST>")
"RTN","MXMLTMPT",66,0)
 QUIT
"RTN","MXMLTMPT",67,0)
 ;
"RTN","MXMLTMPT",68,0)
PUSH ; @TEST - Test PUSH
"RTN","MXMLTMPT",69,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",70,0)
 D CHKEQ^XTMUNIT(MXMLARR0(0),4,"Only 4 elements were expected.")
"RTN","MXMLTMPT",71,0)
 D CHKEQ^XTMUNIT(MXMLARR0(MXMLARR0(0)),"FOURTH","Last pushed element should be FOURTH")
"RTN","MXMLTMPT",72,0)
 QUIT
"RTN","MXMLTMPT",73,0)
 ;
"RTN","MXMLTMPT",74,0)
PUSHPOP ; @TEST - Test PUSH and POP
"RTN","MXMLTMPT",75,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",76,0)
 N %
"RTN","MXMLTMPT",77,0)
 D POP^MXMLTMP1($NA(MXMLARR0),.%)
"RTN","MXMLTMPT",78,0)
 D CHKEQ^XTMUNIT(%,"FOURTH","Poped element should be FOURTH")
"RTN","MXMLTMPT",79,0)
 D CHKEQ^XTMUNIT(MXMLARR0(0),3,"Only 3 elements should be left")
"RTN","MXMLTMPT",80,0)
 D CHKEQ^XTMUNIT(MXMLARR0(MXMLARR0(0)),"THIRD","Last pushed element should be THIRD")
"RTN","MXMLTMPT",81,0)
 ;
"RTN","MXMLTMPT",82,0)
 N %
"RTN","MXMLTMPT",83,0)
 D POP^MXMLTMP1($NA(MXMLARR0),.%)
"RTN","MXMLTMPT",84,0)
 D CHKEQ^XTMUNIT(%,"THIRD","Poped element should be FOURTH")
"RTN","MXMLTMPT",85,0)
 D CHKEQ^XTMUNIT(MXMLARR0(0),2,"Only 2 elements should be left")
"RTN","MXMLTMPT",86,0)
 D CHKEQ^XTMUNIT(MXMLARR0(MXMLARR0(0)),"SECOND","Last pushed element should be THIRD")
"RTN","MXMLTMPT",87,0)
 QUIT
"RTN","MXMLTMPT",88,0)
 ;
"RTN","MXMLTMPT",89,0)
MKMDX ; @TEST - Test MKMDX
"RTN","MXMLTMPT",90,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",91,0)
 N %
"RTN","MXMLTMPT",92,0)
 D MKMDX^MXMLTMP1($NA(MXMLARR0),.%)
"RTN","MXMLTMPT",93,0)
 D CHKEQ^XTMUNIT(%,"//FIRST/SECOND/THIRD/FOURTH")
"RTN","MXMLTMPT",94,0)
 QUIT
"RTN","MXMLTMPT",95,0)
 ;
"RTN","MXMLTMPT",96,0)
XNAME ; @TEST - Test XNAME
"RTN","MXMLTMPT",97,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",98,0)
 D CHKEQ^XTMUNIT($$XNAME^MXMLTMP1("<FOURTH>DATA1</FOURTH>"),"FOURTH","XNAME failed")
"RTN","MXMLTMPT",99,0)
 D CHKEQ^XTMUNIT($$XNAME^MXMLTMP1("<SIXTH  ID=""SELF"" />"),"SIXTH","XNAME failed")
"RTN","MXMLTMPT",100,0)
 D CHKEQ^XTMUNIT($$XNAME^MXMLTMP1("</THIRD>"),"THIRD","XNAME failed")
"RTN","MXMLTMPT",101,0)
 QUIT
"RTN","MXMLTMPT",102,0)
 ;
"RTN","MXMLTMPT",103,0)
XVARS ; @TEST - Test XVARS
"RTN","MXMLTMPT",104,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",105,0)
 N GTMP,GTMP2
"RTN","MXMLTMPT",106,0)
 D PUSH^MXMLTMP1($NA(GTMP),"<VALUE1>@@VAR1@@ and @@VAR1a@@</VALUE1>")
"RTN","MXMLTMPT",107,0)
 D PUSH^MXMLTMP1($NA(GTMP),"<VALUE2>nothing to see here</VALUE2>")
"RTN","MXMLTMPT",108,0)
 D PUSH^MXMLTMP1($NA(GTMP),"<VALUE3>@@VAR3@@</VALUE3>")
"RTN","MXMLTMPT",109,0)
 D XVARS^MXMLTMPL($NA(GTMP2),$NA(GTMP))
"RTN","MXMLTMPT",110,0)
 ; ZWRITE GTMP,GTMP2
"RTN","MXMLTMPT",111,0)
 D CHKEQ^XTMUNIT(GTMP2(1),"^VAR1^1")
"RTN","MXMLTMPT",112,0)
 QUIT
"RTN","MXMLTMPT",113,0)
 ;
"RTN","MXMLTMPT",114,0)
INDEX ; @TEST - Test INDEX
"RTN","MXMLTMPT",115,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",116,0)
 D INDEX^MXMLTMP1($NA(MXMLARR1))
"RTN","MXMLTMPT",117,0)
 D CHKEQ^XTMUNIT(MXMLARR1("//FIRST/SECOND"),"2^12")
"RTN","MXMLTMPT",118,0)
 D CHKEQ^XTMUNIT(MXMLARR1("//FIRST/SECOND/THIRD"),"3^9")
"RTN","MXMLTMPT",119,0)
 D CHKEQ^XTMUNIT(MXMLARR1("//FIRST/SECOND/THIRD/FIFTH"),"5^7")
"RTN","MXMLTMPT",120,0)
 D CHKEQ^XTMUNIT(MXMLARR1("//FIRST/SECOND/THIRD/FOURTH"),"4^4^@@DATA1@@")
"RTN","MXMLTMPT",121,0)
 D CHKEQ^XTMUNIT(MXMLARR1("//FIRST/SECOND/THIRD/SIXTH"),"8^8^")
"RTN","MXMLTMPT",122,0)
 D CHKEQ^XTMUNIT(MXMLARR1("//FIRST"),"1^13")
"RTN","MXMLTMPT",123,0)
 QUIT
"RTN","MXMLTMPT",124,0)
 ;
"RTN","MXMLTMPT",125,0)
INDEX2 ; @TEST - Test INDEX ; again
"RTN","MXMLTMPT",126,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",127,0)
 D INDEX^MXMLTMP1($NA(MXMLARR2))
"RTN","MXMLTMPT",128,0)
 D CHKEQ^XTMUNIT(MXMLARR2("//FIRST/SECOND"),"2^12")
"RTN","MXMLTMPT",129,0)
 D CHKEQ^XTMUNIT(MXMLARR2("//FIRST/SECOND/_SECOND"),"9^11")
"RTN","MXMLTMPT",130,0)
 D CHKEQ^XTMUNIT(MXMLARR2("//FIRST/SECOND/_SECOND/FOURTH"),"10^10^DATA3")
"RTN","MXMLTMPT",131,0)
 D CHKEQ^XTMUNIT(MXMLARR2("//FIRST/SECOND/THIRD"),"3^8")
"RTN","MXMLTMPT",132,0)
 D CHKEQ^XTMUNIT(MXMLARR2("//FIRST/SECOND/THIRD/FOURTH[1]"),"4^4^DATA1")
"RTN","MXMLTMPT",133,0)
 D CHKEQ^XTMUNIT(MXMLARR2("//FIRST"),"1^13")
"RTN","MXMLTMPT",134,0)
 QUIT
"RTN","MXMLTMPT",135,0)
 ;
"RTN","MXMLTMPT",136,0)
MISSING ; @TEST - Test MISSING (@@element@@ that need to be filled out)
"RTN","MXMLTMPT",137,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",138,0)
 K ^TMP($J)
"RTN","MXMLTMPT",139,0)
 D MISSING^MXMLTMPL($NA(MXMLARR1),$NA(^TMP($J,"MISSINGTEST")))
"RTN","MXMLTMPT",140,0)
 D CHKEQ^XTMUNIT(^TMP($J,"MISSINGTEST",1),"DATA1")
"RTN","MXMLTMPT",141,0)
 D CHKEQ^XTMUNIT(^TMP($J,"MISSINGTEST",2),"DATA2")
"RTN","MXMLTMPT",142,0)
 K ^TMP($J)
"RTN","MXMLTMPT",143,0)
 QUIT
"RTN","MXMLTMPT",144,0)
 ;
"RTN","MXMLTMPT",145,0)
MAP ; @TEST - Test MAP. Maps values to missing elements.
"RTN","MXMLTMPT",146,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",147,0)
 K ^TMP($J)
"RTN","MXMLTMPT",148,0)
 N MAPARY S MAPARY=$NA(^TMP($J,"MAPVALUES"))
"RTN","MXMLTMPT",149,0)
 N OUTARY S OUTARY=$NA(^TMP($J,"MAPTEST"))
"RTN","MXMLTMPT",150,0)
 S @MAPARY@("DATA2")="VALUE2"
"RTN","MXMLTMPT",151,0)
 D MAP^MXMLTMPL($NA(MXMLARR1),MAPARY,OUTARY)
"RTN","MXMLTMPT",152,0)
 ; ZWRITE @OUTARY@(*)
"RTN","MXMLTMPT",153,0)
 D CHKEQ^XTMUNIT(@OUTARY@(6),"VALUE2")
"RTN","MXMLTMPT",154,0)
 K ^TMP($J)
"RTN","MXMLTMPT",155,0)
 QUIT
"RTN","MXMLTMPT",156,0)
 ;
"RTN","MXMLTMPT",157,0)
MAP2 ; @TEST - Test MAP for multiple values.
"RTN","MXMLTMPT",158,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",159,0)
 K ^TMP($J)
"RTN","MXMLTMPT",160,0)
 N MAPARY S MAPARY=$NA(^TMP($J,"MAPVALUES"))
"RTN","MXMLTMPT",161,0)
 N OUTARY S OUTARY=$NA(^TMP($J,"MAPTEST"))
"RTN","MXMLTMPT",162,0)
 S @MAPARY@("DATA1")="VALUE1"
"RTN","MXMLTMPT",163,0)
 S @MAPARY@("DATA2")="VALUE2"
"RTN","MXMLTMPT",164,0)
 S @MAPARY@("DATA3")="VALUE3"
"RTN","MXMLTMPT",165,0)
 S MXMLARR1(4)="<FOURTH>@@DATA1@@ AND @@DATA3@@</FOURTH>"
"RTN","MXMLTMPT",166,0)
 D MAP^MXMLTMPL($NA(MXMLARR1),MAPARY,OUTARY)
"RTN","MXMLTMPT",167,0)
 ; D PARY^MXMLTMPL(OUTARY)
"RTN","MXMLTMPT",168,0)
 D CHKEQ^XTMUNIT(@OUTARY@(4),"<FOURTH>VALUE1 AND VALUE3</FOURTH>")
"RTN","MXMLTMPT",169,0)
 K ^TMP($J)
"RTN","MXMLTMPT",170,0)
 QUIT
"RTN","MXMLTMPT",171,0)
 ;
"RTN","MXMLTMPT",172,0)
QUEUE ; @TEST - Test QUEUE - Adds entries to build list
"RTN","MXMLTMPT",173,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",174,0)
 N BTLIST
"RTN","MXMLTMPT",175,0)
 D QUEUE^MXMLTMPL($NA(BTLIST),$NA(MXMLARR1),2,3)
"RTN","MXMLTMPT",176,0)
 D QUEUE^MXMLTMPL($NA(BTLIST),$NA(MXMLARR1),4,5)
"RTN","MXMLTMPT",177,0)
 ; ZWRITE BTLIST
"RTN","MXMLTMPT",178,0)
 D CHKEQ^XTMUNIT($P(BTLIST(2),";",2),4)
"RTN","MXMLTMPT",179,0)
 QUIT
"RTN","MXMLTMPT",180,0)
 ;
"RTN","MXMLTMPT",181,0)
QUERY ; @TEST - Test XPATH-like QUERY
"RTN","MXMLTMPT",182,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",183,0)
 N G2
"RTN","MXMLTMPT",184,0)
 D QUERY^MXMLTMPL($NA(MXMLARR1),"//FIRST/SECOND/THIRD/FOURTH",$NA(G2))
"RTN","MXMLTMPT",185,0)
 D CHKEQ^XTMUNIT(G2(1),"<FOURTH>@@DATA1@@</FOURTH>")
"RTN","MXMLTMPT",186,0)
 QUIT
"RTN","MXMLTMPT",187,0)
 ;
"RTN","MXMLTMPT",188,0)
BUILD ; @TEST - Test Build return off QUEUE[d] lists..
"RTN","MXMLTMPT",189,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",190,0)
 N BTLIST
"RTN","MXMLTMPT",191,0)
 D QUEUE^MXMLTMPL($NA(BTLIST),$NA(MXMLARR1),2,3)
"RTN","MXMLTMPT",192,0)
 D QUEUE^MXMLTMPL($NA(BTLIST),$NA(MXMLARR1),4,5)
"RTN","MXMLTMPT",193,0)
 N G3
"RTN","MXMLTMPT",194,0)
 D BUILD^MXMLTMPL($NA(BTLIST),$NA(G3))
"RTN","MXMLTMPT",195,0)
 ;ZWRITE MXMLARR1,BTLIST,G3
"RTN","MXMLTMPT",196,0)
 D CHKEQ^XTMUNIT(G3(4),"<FIFTH>")
"RTN","MXMLTMPT",197,0)
 QUIT
"RTN","MXMLTMPT",198,0)
 ;
"RTN","MXMLTMPT",199,0)
CP ; @TEST - Copy Arrays
"RTN","MXMLTMPT",200,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",201,0)
 N G2
"RTN","MXMLTMPT",202,0)
 D CP^MXMLTMPL($NA(MXMLARR1),$NA(G2))
"RTN","MXMLTMPT",203,0)
 ;ZWRITE G2
"RTN","MXMLTMPT",204,0)
 D CHKEQ^XTMUNIT(G2(0),13)
"RTN","MXMLTMPT",205,0)
 QUIT
"RTN","MXMLTMPT",206,0)
 ;
"RTN","MXMLTMPT",207,0)
QOPEN ; @TEST - Create build list to copy all lines except last
"RTN","MXMLTMPT",208,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",209,0)
 N GBL
"RTN","MXMLTMPT",210,0)
 D QOPEN^MXMLTMPL($NA(GBL),$NA(MXMLARR1))
"RTN","MXMLTMPT",211,0)
 ;ZWRITE MXMLARR1
"RTN","MXMLTMPT",212,0)
 ;ZWRITE GBL
"RTN","MXMLTMPT",213,0)
 D CHKEQ^XTMUNIT($P(GBL(1),";",3),12)
"RTN","MXMLTMPT",214,0)
 N DEST ; destination
"RTN","MXMLTMPT",215,0)
 D BUILD^MXMLTMPL($NA(GBL),$NA(DEST))
"RTN","MXMLTMPT",216,0)
 ;ZWRITE DEST
"RTN","MXMLTMPT",217,0)
 D CHKEQ^XTMUNIT(DEST(DEST(0)),"</SECOND>")
"RTN","MXMLTMPT",218,0)
 QUIT
"RTN","MXMLTMPT",219,0)
 ;
"RTN","MXMLTMPT",220,0)
QOPEN2 ; @TEST - Create partial build list to copy XPATH contents
"RTN","MXMLTMPT",221,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",222,0)
 N GBL
"RTN","MXMLTMPT",223,0)
 D QOPEN^MXMLTMPL($NA(GBL),$NA(MXMLARR1),"//FIRST/SECOND")
"RTN","MXMLTMPT",224,0)
 ;ZWRITE MXMLARR1,GBL
"RTN","MXMLTMPT",225,0)
 N G2
"RTN","MXMLTMPT",226,0)
 D BUILD^MXMLTMPL($NA(GBL),$NA(G2))
"RTN","MXMLTMPT",227,0)
 D CHKEQ^XTMUNIT(G2(G2(0)),"</SECOND>")
"RTN","MXMLTMPT",228,0)
 QUIT
"RTN","MXMLTMPT",229,0)
 ;
"RTN","MXMLTMPT",230,0)
QCLOSE ; @TEST - Create build list to copy last line
"RTN","MXMLTMPT",231,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",232,0)
 N GBL
"RTN","MXMLTMPT",233,0)
 D QCLOSE^MXMLTMPL($NA(GBL),$NA(MXMLARR1))
"RTN","MXMLTMPT",234,0)
 ;ZWRITE MXMLARR1,GBL
"RTN","MXMLTMPT",235,0)
 N G2
"RTN","MXMLTMPT",236,0)
 D BUILD^MXMLTMPL($NA(GBL),$NA(G2))
"RTN","MXMLTMPT",237,0)
 D CHKEQ^XTMUNIT(G2(G2(0)),"</FIRST>")
"RTN","MXMLTMPT",238,0)
 QUIT
"RTN","MXMLTMPT",239,0)
QCLOSE2 ; @TEST - Create build list to copy last line based off XPATH
"RTN","MXMLTMPT",240,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",241,0)
 N GBL,G2
"RTN","MXMLTMPT",242,0)
 D QCLOSE^MXMLTMPL($NA(GBL),$NA(MXMLARR1),"//FIRST/SECOND/THIRD")
"RTN","MXMLTMPT",243,0)
 ;ZWRITE MXMLARR1,GBL
"RTN","MXMLTMPT",244,0)
 D CHKEQ^XTMUNIT($P(GBL(1),";",3),13)
"RTN","MXMLTMPT",245,0)
 D BUILD^MXMLTMPL($NA(GBL),$NA(G2))
"RTN","MXMLTMPT",246,0)
 D CHKEQ^XTMUNIT(G2(G2(0)),"</FIRST>")
"RTN","MXMLTMPT",247,0)
 D CHKEQ^XTMUNIT(G2(1),"</THIRD>")
"RTN","MXMLTMPT",248,0)
 QUIT
"RTN","MXMLTMPT",249,0)
INSERT ; @TEST - Test insertion of XML at end of XPATH
"RTN","MXMLTMPT",250,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",251,0)
 N GBL,G2,G3,G4
"RTN","MXMLTMPT",252,0)
 D QUERY^MXMLTMPL($NA(MXMLARR1),"//FIRST/SECOND/THIRD/FIFTH",$NA(G2))
"RTN","MXMLTMPT",253,0)
 ; ZWRITE MXMLARR1,G2
"RTN","MXMLTMPT",254,0)
 D INSERT^MXMLTMPL($NA(MXMLARR1),$NA(G2),"//FIRST/SECOND/THIRD")
"RTN","MXMLTMPT",255,0)
 ; ZWRITE MXMLARR1
"RTN","MXMLTMPT",256,0)
 ; ZWRITE G2
"RTN","MXMLTMPT",257,0)
 ; ZWRITE:$D(G3) G3
"RTN","MXMLTMPT",258,0)
 D INSERT^MXMLTMPL($NA(G3),$NA(G2),"//")
"RTN","MXMLTMPT",259,0)
 D CHKEQ^XTMUNIT(G2(1),MXMLARR1(9))
"RTN","MXMLTMPT",260,0)
 QUIT
"RTN","MXMLTMPT",261,0)
REPLACE ; @TEST - Test REPLACE of XML
"RTN","MXMLTMPT",262,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",263,0)
 N G2
"RTN","MXMLTMPT",264,0)
 D QUERY^MXMLTMPL($NA(MXMLARR1),"//FIRST/SECOND/THIRD/FIFTH",$NA(G2))
"RTN","MXMLTMPT",265,0)
 ; ZWRITE MXMLARR1,G2
"RTN","MXMLTMPT",266,0)
 D REPLACE^MXMLTMPL($NA(MXMLARR1),$NA(G2),"//FIRST/SECOND")
"RTN","MXMLTMPT",267,0)
 ; ZWRITE MXMLARR1
"RTN","MXMLTMPT",268,0)
 D CHKEQ^XTMUNIT(MXMLARR1(2),"<FIFTH>")
"RTN","MXMLTMPT",269,0)
 QUIT
"RTN","MXMLTMPT",270,0)
 ;
"RTN","MXMLTMPT",271,0)
INSINNER ; @TEST - Test Insert Inner source XML into end of dest XML XPATH
"RTN","MXMLTMPT",272,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",273,0)
 N G2
"RTN","MXMLTMPT",274,0)
 D QUERY^MXMLTMPL($NA(MXMLARR1),"//FIRST/SECOND/THIRD",$NA(G2))
"RTN","MXMLTMPT",275,0)
 ; ZWRITE MXMLARR1,G2
"RTN","MXMLTMPT",276,0)
 D INSINNER^MXMLTMPL($NA(MXMLARR1),$NA(G2),"//FIRST/SECOND/THIRD")
"RTN","MXMLTMPT",277,0)
 ; ZWRITE MXMLARR1
"RTN","MXMLTMPT",278,0)
 D CHKEQ^XTMUNIT(MXMLARR1(10),"<FIFTH>")
"RTN","MXMLTMPT",279,0)
 QUIT
"RTN","MXMLTMPT",280,0)
INSINNE2 ; @TEST - Test Insert Inner source XML into end of dest XML
"RTN","MXMLTMPT",281,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",282,0)
 N G2
"RTN","MXMLTMPT",283,0)
 D QUERY^MXMLTMPL($NA(MXMLARR1),"//FIRST/SECOND/THIRD",$NA(G2))
"RTN","MXMLTMPT",284,0)
 ;ZWRITE G2
"RTN","MXMLTMPT",285,0)
 D INSINNER^MXMLTMPL($NA(G2),$NA(G2))
"RTN","MXMLTMPT",286,0)
 ;ZWRITE G2
"RTN","MXMLTMPT",287,0)
 D CHKEQ^XTMUNIT(G2(8),"<FIFTH>")
"RTN","MXMLTMPT",288,0)
 QUIT
"RTN","MXMLTMPT",289,0)
PUSHA ; @TEST - Push All
"RTN","MXMLTMPT",290,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",291,0)
 N GTMP,GTMP2
"RTN","MXMLTMPT",292,0)
 D PUSH^MXMLTMP1($NA(GTMP),"A")
"RTN","MXMLTMPT",293,0)
 D PUSH^MXMLTMP1($NA(GTMP2),"B")
"RTN","MXMLTMPT",294,0)
 D PUSH^MXMLTMP1($NA(GTMP2),"C")
"RTN","MXMLTMPT",295,0)
 D PUSHA^MXMLTMP1($NA(GTMP),$NA(GTMP2))
"RTN","MXMLTMPT",296,0)
 ; ZWRITE GTMP,GTMP2
"RTN","MXMLTMPT",297,0)
 D CHKEQ^XTMUNIT(GTMP(3),"C")
"RTN","MXMLTMPT",298,0)
 D CHKEQ^XTMUNIT(GTMP(0),3)
"RTN","MXMLTMPT",299,0)
 QUIT
"RTN","MXMLTMPT",300,0)
H2ARY ; @TEST - Convert a Hash to a return array (return(n)="key^value")
"RTN","MXMLTMPT",301,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",302,0)
 N GTMP,GTMP2
"RTN","MXMLTMPT",303,0)
 S GTMP("TEST1")=1
"RTN","MXMLTMPT",304,0)
 S GTMP("TEST2")=4
"RTN","MXMLTMPT",305,0)
 S GTMP("TEST3")=8
"RTN","MXMLTMPT",306,0)
 D H2ARY^MXMLTMPL($NA(GTMP2),$NA(GTMP))
"RTN","MXMLTMPT",307,0)
 D CHKEQ^XTMUNIT(GTMP2(0),3)
"RTN","MXMLTMPT",308,0)
 D CHKEQ^XTMUNIT(GTMP2(2),"^TEST2^4")
"RTN","MXMLTMPT",309,0)
 QUIT
"RTN","MXMLTMPT",310,0)
 ;
"RTN","MXMLTMPT",311,0)
TRIM ; @TEST - Trim an XML array
"RTN","MXMLTMPT",312,0)
 ; ZEXCEPT: MXMLARR0,MXMLARR1,MXMLARR2
"RTN","MXMLTMPT",313,0)
 N MXMLARR0
"RTN","MXMLTMPT",314,0)
 D PUSH^MXMLTMP1($NA(MXMLARR0),"<Books>")
"RTN","MXMLTMPT",315,0)
 D PUSH^MXMLTMP1($NA(MXMLARR0),"<Book>")
"RTN","MXMLTMPT",316,0)
 D PUSH^MXMLTMP1($NA(MXMLARR0),"<Title>Pride and Prejudice</Title>")
"RTN","MXMLTMPT",317,0)
 D PUSH^MXMLTMP1($NA(MXMLARR0),"<Author></Author>")
"RTN","MXMLTMPT",318,0)
 D PUSH^MXMLTMP1($NA(MXMLARR0),"<Length>")
"RTN","MXMLTMPT",319,0)
 D PUSH^MXMLTMP1($NA(MXMLARR0),"</Length>")
"RTN","MXMLTMPT",320,0)
 D PUSH^MXMLTMP1($NA(MXMLARR0),"</Book>")
"RTN","MXMLTMPT",321,0)
 D PUSH^MXMLTMP1($NA(MXMLARR0),"</Books>")
"RTN","MXMLTMPT",322,0)
 D TRIM^MXMLTMP1($NA(MXMLARR0))
"RTN","MXMLTMPT",323,0)
 D CHKEQ^XTMUNIT(MXMLARR0(0),5)
"RTN","MXMLTMPT",324,0)
 ZWRITE MXMLARR0
"RTN","MXMLTMPT",325,0)
 QUIT
"RTN","MXMLTMPT",326,0)
 ;
"RTN","MXMLTMPT",327,0)
 ;
"RTN","MXMLTMPT",328,0)
 ;
"RTN","MXMLTMPT",329,0)
DEMO ; Demo program.
"RTN","MXMLTMPT",330,0)
 ;
"RTN","MXMLTMPT",331,0)
CREATE ; Create Template
"RTN","MXMLTMPT",332,0)
 N MXMLTEMPLATE
"RTN","MXMLTMPT",333,0)
 D PUSH^MXMLTMP1($NA(MXMLTEMPLATE),$$XMLHDR^MXMLUTL())
"RTN","MXMLTMPT",334,0)
 D PUSH^MXMLTMP1($NA(MXMLTEMPLATE),"<Books>")
"RTN","MXMLTMPT",335,0)
 D PUSH^MXMLTMP1($NA(MXMLTEMPLATE),"<LastUpdated date=""@@LASTUP@@"" />")
"RTN","MXMLTMPT",336,0)
 D PUSH^MXMLTMP1($NA(MXMLTEMPLATE),"<Book>")
"RTN","MXMLTMPT",337,0)
 D PUSH^MXMLTMP1($NA(MXMLTEMPLATE),"<Author>@@AUTHOR@@</Author>")
"RTN","MXMLTMPT",338,0)
 D PUSH^MXMLTMP1($NA(MXMLTEMPLATE),"<Title>@@TITLE@@</Title>")
"RTN","MXMLTMPT",339,0)
 D PUSH^MXMLTMP1($NA(MXMLTEMPLATE),"<Description>@@DES@@</Description>")
"RTN","MXMLTMPT",340,0)
 D PUSH^MXMLTMP1($NA(MXMLTEMPLATE),"</Book>")
"RTN","MXMLTMPT",341,0)
 D PUSH^MXMLTMP1($NA(MXMLTEMPLATE),"</Books>")
"RTN","MXMLTMPT",342,0)
 Q
"RTN","MXMLTMPT",343,0)
PARY1 ; Print Array
"RTN","MXMLTMPT",344,0)
 W "Printing pushed template",!
"RTN","MXMLTMPT",345,0)
 D PARY^MXMLTMPL($NA(MXMLTEMPLATE))
"RTN","MXMLTMPT",346,0)
 ;
"RTN","MXMLTMPT",347,0)
MISS1 ; Print elements needing to be resolved
"RTN","MXMLTMPT",348,0)
 N MXMLMISS
"RTN","MXMLTMPT",349,0)
 D MISSING^MXMLTMPL($NA(MXMLTEMPLATE),$NA(MXMLMISS))
"RTN","MXMLTMPT",350,0)
 ;
"RTN","MXMLTMPT",351,0)
PARY11 ; Print Array
"RTN","MXMLTMPT",352,0)
 W "Printing unresolved placeholder elements",!
"RTN","MXMLTMPT",353,0)
 D PARY^MXMLTMPL($NA(MXMLMISS))
"RTN","MXMLTMPT",354,0)
 K MXMLMISS
"RTN","MXMLTMPT",355,0)
 ;
"RTN","MXMLTMPT",356,0)
MAP1 ; Map the Date
"RTN","MXMLTMPT",357,0)
 N DATE S DATE=$$FMTE^XLFDT($$NOW^XLFDT())
"RTN","MXMLTMPT",358,0)
 N MXMLHASH S MXMLHASH("LASTUP")=DATE
"RTN","MXMLTMPT",359,0)
 K DATE
"RTN","MXMLTMPT",360,0)
 ;
"RTN","MXMLTMPT",361,0)
 N MXMLOUTPUT
"RTN","MXMLTMPT",362,0)
 D MAP^MXMLTMPL($NA(MXMLTEMPLATE),$NA(MXMLHASH),$NA(MXMLOUTPUT))
"RTN","MXMLTMPT",363,0)
 K MXMLHASH
"RTN","MXMLTMPT",364,0)
 ;
"RTN","MXMLTMPT",365,0)
PARY2 ; Print Array
"RTN","MXMLTMPT",366,0)
 W !
"RTN","MXMLTMPT",367,0)
 W "Printing template with mapped date",!
"RTN","MXMLTMPT",368,0)
 D PARY^MXMLTMPL($NA(MXMLOUTPUT))
"RTN","MXMLTMPT",369,0)
 W !
"RTN","MXMLTMPT",370,0)
 W "Original: ",!
"RTN","MXMLTMPT",371,0)
 D PARY^MXMLTMPL($NA(MXMLTEMPLATE))
"RTN","MXMLTMPT",372,0)
 ;
"RTN","MXMLTMPT",373,0)
SWAP ; Swap the output into the original
"RTN","MXMLTMPT",374,0)
 K MXMLTEMPLATE
"RTN","MXMLTMPT",375,0)
 M MXMLTEMPLATE=MXMLOUTPUT
"RTN","MXMLTMPT",376,0)
 K MXMLOUTPUT
"RTN","MXMLTMPT",377,0)
 ;
"RTN","MXMLTMPT",378,0)
QUERY1 ; Grab the books parts to use as a repeating segment
"RTN","MXMLTMPT",379,0)
 N MXMLBOOKSXML
"RTN","MXMLTMPT",380,0)
 D QUERY^MXMLTMPL($NA(MXMLTEMPLATE),"//Books/Book",$NA(MXMLBOOKSXML))
"RTN","MXMLTMPT",381,0)
 ;
"RTN","MXMLTMPT",382,0)
PARY3 ; Print Array
"RTN","MXMLTMPT",383,0)
 W !,"Printing the Books XML segement",!
"RTN","MXMLTMPT",384,0)
 D PARY^MXMLTMPL($NA(MXMLBOOKSXML))
"RTN","MXMLTMPT",385,0)
 ;
"RTN","MXMLTMPT",386,0)
MAP3 ; Make second map
"RTN","MXMLTMPT",387,0)
 N MXMLHASH
"RTN","MXMLTMPT",388,0)
 S MXMLHASH("AUTHOR")="Lord Byron"
"RTN","MXMLTMPT",389,0)
 S MXMLHASH("TITLE")="Don Juan"
"RTN","MXMLTMPT",390,0)
 S MXMLHASH("DES")="A swipe at the traditional Don Juan story, the hero goes clueless into various adventures and many romantic conquests"
"RTN","MXMLTMPT",391,0)
 N MXMLOUTPUTLB
"RTN","MXMLTMPT",392,0)
 D MAP^MXMLTMPL($NA(MXMLBOOKSXML),$NA(MXMLHASH),$NA(MXMLOUTPUTLB))
"RTN","MXMLTMPT",393,0)
 K MXMLHASH
"RTN","MXMLTMPT",394,0)
 ;
"RTN","MXMLTMPT",395,0)
PARY4 ; Print Array
"RTN","MXMLTMPT",396,0)
 W !,"Printing Mapped Book segment",!
"RTN","MXMLTMPT",397,0)
 D PARY^MXMLTMPL($NA(MXMLOUTPUTLB))
"RTN","MXMLTMPT",398,0)
 ;
"RTN","MXMLTMPT",399,0)
REPLACE1 ; Replace the original Books segment with the new segment
"RTN","MXMLTMPT",400,0)
 D REPLACE^MXMLTMPL($NA(MXMLTEMPLATE),$NA(MXMLOUTPUTLB),"//Books/Book")
"RTN","MXMLTMPT",401,0)
 K MXMLOUTPUT
"RTN","MXMLTMPT",402,0)
 ;
"RTN","MXMLTMPT",403,0)
PARY5 ; Print Array
"RTN","MXMLTMPT",404,0)
 W !,"Printing original template after mapped segment is inserted",!
"RTN","MXMLTMPT",405,0)
 D PARY^MXMLTMPL($NA(MXMLTEMPLATE))
"RTN","MXMLTMPT",406,0)
 ;
"RTN","MXMLTMPT",407,0)
MAP4 ; Make another book map
"RTN","MXMLTMPT",408,0)
 N MXMLHASH
"RTN","MXMLTMPT",409,0)
 S MXMLHASH("AUTHOR")="Samuel Butler"
"RTN","MXMLTMPT",410,0)
 S MXMLHASH("TITLE")="The way of all Flesh"
"RTN","MXMLTMPT",411,0)
 S MXMLHASH("DES")="A semi-autobiographical novel which attacks Victorian-era hypocrisy."
"RTN","MXMLTMPT",412,0)
 N MXMLOUTPUTSB
"RTN","MXMLTMPT",413,0)
 D MAP^MXMLTMPL($NA(MXMLBOOKSXML),$NA(MXMLHASH),$NA(MXMLOUTPUTSB))
"RTN","MXMLTMPT",414,0)
 K MXMLHASH
"RTN","MXMLTMPT",415,0)
 ;
"RTN","MXMLTMPT",416,0)
PARY6 ; Print Array
"RTN","MXMLTMPT",417,0)
 W !,"Printing Mapped Book segment",!
"RTN","MXMLTMPT",418,0)
 D PARY^MXMLTMPL($NA(MXMLOUTPUTSB))
"RTN","MXMLTMPT",419,0)
 ;
"RTN","MXMLTMPT",420,0)
INSINN1 ; Insert inner portion of Books XML before the end of the Books section
"RTN","MXMLTMPT",421,0)
 D INSINNER^MXMLTMPL($NA(MXMLTEMPLATE),$NA(MXMLOUTPUTSB),"//Books/Book")
"RTN","MXMLTMPT",422,0)
 ;
"RTN","MXMLTMPT",423,0)
PARY7 ; Print Array
"RTN","MXMLTMPT",424,0)
 W !,"Printing original template after second mapped section is inserted",!
"RTN","MXMLTMPT",425,0)
 D PARY^MXMLTMPL($NA(MXMLTEMPLATE))
"RTN","MXMLTMPT",426,0)
 W !,"Incorrect XML produced",!
"RTN","MXMLTMPT",427,0)
 ;
"RTN","MXMLTMPT",428,0)
DEL1 ; Delete Books section
"RTN","MXMLTMPT",429,0)
 D REPLACE^MXMLTMPL($NA(MXMLTEMPLATE),"","//Books/Book")
"RTN","MXMLTMPT",430,0)
 ;
"RTN","MXMLTMPT",431,0)
PARY8 ; Print Array
"RTN","MXMLTMPT",432,0)
 W !,"Printing a template without the books section which just got deleted."
"RTN","MXMLTMPT",433,0)
 D PARY^MXMLTMPL($NA(MXMLTEMPLATE))
"RTN","MXMLTMPT",434,0)
 W !,"Printing both mapped arrays",!
"RTN","MXMLTMPT",435,0)
 D PARY^MXMLTMPL($NA(MXMLOUTPUTLB))
"RTN","MXMLTMPT",436,0)
 D PARY^MXMLTMPL($NA(MXMLOUTPUTSB))
"RTN","MXMLTMPT",437,0)
 ;
"RTN","MXMLTMPT",438,0)
INSINN2 ; Insert inner portion of Books XML again of Byron's Don Juan
"RTN","MXMLTMPT",439,0)
 D INSINNER^MXMLTMPL($NA(MXMLTEMPLATE),$NA(MXMLOUTPUTLB),"//Books/Book")
"RTN","MXMLTMPT",440,0)
 ;
"RTN","MXMLTMPT",441,0)
PARY9 ; Print Array
"RTN","MXMLTMPT",442,0)
 W !!,"Printing template with Don Juan"
"RTN","MXMLTMPT",443,0)
 D PARY^MXMLTMPL($NA(MXMLTEMPLATE))
"RTN","MXMLTMPT",444,0)
 ;
"RTN","MXMLTMPT",445,0)
INSERT1 ; Insert all of the Butler's Way of all Flesh into template under Books
"RTN","MXMLTMPT",446,0)
 D INSERT^MXMLTMPL($NA(MXMLTEMPLATE),$NA(MXMLOUTPUTSB),"//Books")
"RTN","MXMLTMPT",447,0)
 ;
"RTN","MXMLTMPT",448,0)
PARY0 ; Print Array
"RTN","MXMLTMPT",449,0)
 W !!,"Printing template with both books in it"
"RTN","MXMLTMPT",450,0)
 D PARY^MXMLTMPL($NA(MXMLTEMPLATE))
"RTN","MXMLTMPT",451,0)
 ;
"RTN","MXMLTMPT",452,0)
QUIT QUIT
"RTN","MXMLTMPT",453,0)
 ;
"RTN","MXMLTMPT",454,0)
PUSHPOP2 ; Push and Pop
"RTN","MXMLTMPT",455,0)
 N KBAN
"RTN","MXMLTMPT",456,0)
 D PUSH^MXMLTMP1($NA(KBAN),"Test1")
"RTN","MXMLTMPT",457,0)
 D PUSH^MXMLTMP1($NA(KBAN),"Test2")
"RTN","MXMLTMPT",458,0)
 N KBANVAL
"RTN","MXMLTMPT",459,0)
 D POP^MXMLTMP1($NA(KBAN),.KBANVAL)
"RTN","MXMLTMPT",460,0)
 W KBANVAL,! ; Test2
"RTN","MXMLTMPT",461,0)
 QUIT
"RTN","MXMLTMPT",462,0)
 ;
"RTN","MXMLTMPT",463,0)
TRIM2 ; - Trim an XML array
"RTN","MXMLTMPT",464,0)
 N MXMLARR0
"RTN","MXMLTMPT",465,0)
 D PUSH^MXMLTMP1($NA(MXMLARR0),"<Books>")
"RTN","MXMLTMPT",466,0)
 D PUSH^MXMLTMP1($NA(MXMLARR0),"<Book>")
"RTN","MXMLTMPT",467,0)
 D PUSH^MXMLTMP1($NA(MXMLARR0),"<Title>Pride and Prejudice</Title>")
"RTN","MXMLTMPT",468,0)
 D PUSH^MXMLTMP1($NA(MXMLARR0),"<Author></Author>")
"RTN","MXMLTMPT",469,0)
 D PUSH^MXMLTMP1($NA(MXMLARR0),"<Length>")
"RTN","MXMLTMPT",470,0)
 D PUSH^MXMLTMP1($NA(MXMLARR0),"</Length>")
"RTN","MXMLTMPT",471,0)
 D PUSH^MXMLTMP1($NA(MXMLARR0),"</Book>")
"RTN","MXMLTMPT",472,0)
 D PUSH^MXMLTMP1($NA(MXMLARR0),"</Books>")
"RTN","MXMLTMPT",473,0)
 D TRIM^MXMLTMP1($NA(MXMLARR0))
"RTN","MXMLTMPT",474,0)
 ZWRITE MXMLARR0
"RTN","MXMLTMPT",475,0)
 QUIT
"RTN","MXMLUTL")
0^12^B1706569
"RTN","MXMLUTL",1,0)
MXMLUTL ;mjk/alb - MXML Build Utilities ;12/11/2002  15:30
"RTN","MXMLUTL",2,0)
 ;;2.1;XML PROCESSING UTILITIES;;Nov 27, 2013;Build 9
"RTN","MXMLUTL",3,0)
 QUIT
"RTN","MXMLUTL",4,0)
 ;
"RTN","MXMLUTL",5,0)
XMLHDR() ; -- provides current XML standard header 
"RTN","MXMLUTL",6,0)
 QUIT "<?xml version=""1.0"" encoding=""utf-8"" ?>"
"RTN","MXMLUTL",7,0)
 ;
"RTN","MXMLUTL",8,0)
SYMENC(STR) ; -- replace reserved xml symbols with their encoding.
"RTN","MXMLUTL",9,0)
 N A,I,X,Y,Z,NEWSTR,QT
"RTN","MXMLUTL",10,0)
 S (Y,Z)="",QT=""""
"RTN","MXMLUTL",11,0)
 I STR["&" S NEWSTR=STR D  S STR=Y_Z
"RTN","MXMLUTL",12,0)
 . F X=1:1  S Y=Y_$PIECE(NEWSTR,"&",X)_"&amp;",Z=$PIECE(STR,"&",X+1,999) Q:Z'["&"
"RTN","MXMLUTL",13,0)
 I STR["<" F  S STR=$PIECE(STR,"<",1)_"&lt;"_$PIECE(STR,"<",2,99) Q:STR'["<"
"RTN","MXMLUTL",14,0)
 I STR[">" F  S STR=$PIECE(STR,">",1)_"&gt;"_$PIECE(STR,">",2,99) Q:STR'[">"
"RTN","MXMLUTL",15,0)
 I STR["'" F  S STR=$PIECE(STR,"'",1)_"&apos;"_$PIECE(STR,"'",2,99) Q:STR'["'"
"RTN","MXMLUTL",16,0)
 I STR[QT F  S STR=$PIECE(STR,QT,1)_"&quot;"_$PIECE(STR,QT,2,99) Q:STR'[QT
"RTN","MXMLUTL",17,0)
 ;
"RTN","MXMLUTL",18,0)
 F I=1:1:$L(STR) D
"RTN","MXMLUTL",19,0)
 . S X=$E(STR,I)
"RTN","MXMLUTL",20,0)
 . S A=$A(X)
"RTN","MXMLUTL",21,0)
 . IF A<31 S STR=$P(STR,X,1)_$P(STR,X,2,99)
"RTN","MXMLUTL",22,0)
 Q STR
"RTN","MXMLUTL",23,0)
 ;
"VER")
8.0^22.0
"^DD",950,950,0)
FIELD^^1^2
"^DD",950,950,0,"DT")
2990628
"^DD",950,950,0,"IX","B",950,.01)

"^DD",950,950,0,"NM","XML ENTITY CATALOG")

"^DD",950,950,0,"VRPK")
XT
"^DD",950,950,.01,0)
ID^RFX^^0;1^S X=$$NMLWS^MXMLPRSE(X) K:$L(X)>250!'$L(X) X
"^DD",950,950,.01,1,0)
^.1^^-1
"^DD",950,950,.01,1,1,0)
950^B
"^DD",950,950,.01,1,1,1)
S ^MXML(950,"B",$E(X,1,30),DA)=""
"^DD",950,950,.01,1,1,2)
K ^MXML(950,"B",$E(X,1,30),DA)
"^DD",950,950,.01,3)
Answer must be 1-250 characters in length.
"^DD",950,950,.01,"DT")
2991122
"^DD",950,950,1,0)
VALUE^950.01^^1;0
"^DD",950,950.01,0)
VALUE SUB-FIELD^^.01^1
"^DD",950,950.01,0,"DT")
2990628
"^DD",950,950.01,0,"NM","VALUE")

"^DD",950,950.01,0,"UP")
950
"^DD",950,950.01,.01,0)
VALUE^WL^^0;1^Q
"^DD",950,950.01,.01,"DT")
2990628
"^DIC",950,950,0)
XML ENTITY CATALOG^950
"^DIC",950,950,0,"GL")
^MXML(950,
"^DIC",950,"B","XML ENTITY CATALOG",950)

**END**
**END**
